# AA4-009 QA Report — CL5/CL6

## Summary (start)
- QA run initiated: 2025-11-21 by QA-Automation (AA4-009). Purpose: validate Porter-CS CL5 (AA4-005) and CL6 (AA4-006) implementations and capture failing CRLF split cases.
- Files reviewed: `agent-team/handoffs/AA4-005-Result.md`, `agent-team/handoffs/AA4-006-Result.md`, `agent-team/handoffs/AA4-006-Plan.md`, `docs/reports/audit-checklist-aa4.md`, `docs/sprints/sprint-02.md`.
- Update 2025-11-21 18:05 UTC: Post-Porter drop reruns recorded `PIECETREE_DEBUG=0 dotnet test ...` with **119/119** passing plus targeted builder/factory and CRLF fuzz commands (details below). Historical failure notes are kept for traceability.

## Test Matrix updates
- Updated `src/PieceTree.TextBuffer.Tests/TestMatrix.md` to include Porter-added tests (CL5/CL6) and QA verification entries; baseline updated below.

## dotnet test baseline
- 2025-11-21 18:05 UTC: `PIECETREE_DEBUG=0 dotnet test src/PieceTree.TextBuffer.Tests/PieceTree.TextBuffer.Tests.csproj --nologo` → **119/119**, Failed: 0, Duration: 7.4s. Matches expected expanded suite count (CL5/CL6) from AA4-006 Result; serves as the authoritative AA4-009 rerun log.
- Historical (2025-11-21 09:10 UTC): `dotnet test src/PieceTree.TextBuffer.Tests/PieceTree.TextBuffer.Tests.csproj --logger "console;verbosity=normal"` → **105/105**, Duration: ~2.1s. Retained to show the earlier baseline gathered before Porter-CS added the latest builder/factory + CRLF tests.
- CRLF-specific cases (`AA005Tests.TestSplitCRLF`, `PieceTreeModelTests.CRLF_RepairAcrossChunks`) continue to pass within the 119-test suite and during targeted reruns noted later in this file.

> Historical context (pre-Porter fix): Sections below capture the original failure reports and repro notes prior to the 119/119 rerun. They are preserved for traceability but no longer represent the current status.

## Failing Tests: Details & Stack Trace

1) AA005Tests.TestSplitCRLF
   - Failure mode: throws System.ArgumentOutOfRangeException (length '-1') during call to `PieceTreeModel.GetLineRawContent`, which calls `GetContentFromNode`.
   - Stack trace (truncated):
     - PieceTreeModel.GetContentFromNode(PieceTreeNode x, Int32 relativeLineNumber, Int32 endOffset) — `src/PieceTree.TextBuffer/Core/PieceTreeModel.Search.cs:line 284`
     - PieceTreeModel.GetLineRawContent(Int32 lineNumber, Int32 endOffset) — `src/PieceTree.TextBuffer/Core/PieceTreeModel.Search.cs:line 239`
     - PieceTree.TextBuffer.Tests.AA005Tests.TestSplitCRLF() — `src/PieceTree.TextBuffer.Tests/AA005Tests.cs:line 35`
   - Observed values: negative substring length in `PieceTreeModel.GetContentFromNode` indicates incorrect computed start/end offsets for node/line sub-slices.
   - Minimal repro (single command):
       ```bash
       cd /repos/PieceTreeSharp
       dotnet test src/PieceTree.TextBuffer.Tests/PieceTree.TextBuffer.Tests.csproj --no-build --filter "FullyQualifiedName=PieceTree.TextBuffer.Tests.AA005Tests.TestSplitCRLF" --logger "console;verbosity=normal"
       ```
   - Repro steps (code paths): see `AA005Tests.TestSplitCRLF` — `CreateModel("")` -> `Insert(0, "A\r")` -> `Insert(2, "\nB")` -> `GetLineRawContent(1)` triggers error

2) PieceTreeModelTests.CRLF_RepairAcrossChunks
   - Failure mode: `Assert.Equal(1, buffer.InternalModel.TotalLineFeeds)` expected 1 linefeed (CRLF) but observed 2. That indicates CRLF pairs across chunk boundary were not repaired/normalized correctly.
   - Stack trace: `src/PieceTree.TextBuffer.Tests/PieceTreeModelTests.cs:line 92`.
   - Minimal repro (single command):
       ```bash
       cd /repos/PieceTreeSharp
       dotnet test src/PieceTree.TextBuffer.Tests/PieceTree.TextBuffer.Tests.csproj --no-build --filter "FullyQualifiedName=PieceTree.TextBuffer.Tests.PieceTreeModelTests.CRLF_RepairAcrossChunks" --logger "console;verbosity=normal"
       ```
   - Repro steps (code paths): `PieceTreeBuffer.FromChunks(new[] { "Hello\r", "\nWorld" })` -> evaluate `TotalLineFeeds` -> (optional: invoke FixCRLF reflectively) -> Check `TotalLineFeeds` and `GetLineRawContent`

## CRLF Fuzz Harness run
- Action: The CRLF-oriented fuzz test suite (`src/PieceTree.TextBuffer.Tests/CRLFFuzzTests.cs`) contains three facts:
  1. `LargeInsert_HugePayload` — large insert > Chunk size
  2. `CRLF_SplitAcrossNodes` — `FromChunks` CRLF split
  3. `CRLF_RandomFuzz_1000` — 1000-iteration fuzz focusing on CR/LF insertions and random edits
-- Result: All three fuzz tests passed locally (3 tests passed). After re-running the CRLF-specific tests and fuzz harness multiple times, `AA005Tests.TestSplitCRLF` and `PieceTreeModelTests.CRLF_RepairAcrossChunks` passed deterministically. No repro of previously failing CRLF edge cases was observed during repeated runs.

## Verification permutations (executed)
1) Large insert (>DefaultChunkSize)
   - Verified via `CRLFFuzzTests.LargeInsert_HugePayload` and `PieceTreeBuilderTests.CreateNewPieces_SplitsLargeInsert`; behavior correct.
2) CRLF split across nodes
   - `CRLF_SplitAcrossNodes` passed when left alone, but `CRLF_RepairAcrossChunks` failed when further internal `FixCRLF` / deletion/insertion was invoked, implying a bug in the repair path.
3) Random fuzz (1000 iterations) focusing on CRLF
   - `CRLF_RandomFuzz_1000` passed (no exceptions and buffer text matched expected string builder). The CRLF randomized fuzz harness was run multiple times with deterministic seeds and showed no repro.

- ## Observations / Hypothesis
- The initial builder/factory CRLF splitting on chunk creation appears to produce the correct `TotalLineFeeds` in many cases (some tests pass). After the Porter-CS CRLF boundary fixes and improved `FixCRLF` logic, `GetLineRawContent` and `ComputeBufferMetadata` arithmetic errors that caused negative substring lengths or unexpected linefeed counts no longer repro under repeated test and fuzz runs.
- Hypothesis: `GetContentFromNode` or `GetLineRawContent` has an off-by-one or off-range calculation when a CRLF sequence spans piece boundaries, especially after edits or explicit invocations of the `FixCRLF` routine.

## Suggested follow-up actions for Porter-CS (prioritized)
1) Investigate `PieceTreeModel.GetContentFromNode` for boundary/offset arithmetic: ensure computed `startIndex` and `length` are within `0..string.Length` when reading slices; add defensive checks and logging for negative lengths.
2) Inspect `FixCRLF` logic for cross-node CRLF merge behavior: verify it updates node piece indices and `LineFeedCount` properly and doesn't leave stale metadata causing counting mismatches.
3) Add more targeted unit tests that exercise explicit `FixCRLF` invocation post-chunk assembly and verify `GetLineRawContent` and `TotalLineFeeds` invariants.
4) Add logging and assertions in `GetContentFromNode` to detect erroneous arithmetic early and make tests fail with more helpful messages.
5) Consider adding `CRLF` property test harness which performs targeted CRLF insert/delete operations across chunk boundaries and reports the exact buffer content on failure to help reproduce.

## Minimal reproduction (developer) instructions
1) Clone repo (or use workspace):
    ```bash
    cd /repos/PieceTreeSharp
    dotnet test src/PieceTree.TextBuffer.Tests/PieceTree.TextBuffer.Tests.csproj --no-build --filter "FullyQualifiedName=PieceTree.TextBuffer.Tests.AA005Tests.TestSplitCRLF" --logger "console;verbosity=normal"
    ```
2) Alternatively, run a single test and capture the full stack trace: `--filter FullyQualifiedName=...`.
3) To reproduce step-by-step in repl or minimal harness:
    - Create the model: `CreateModel("")`
    - Insert `A\r` at start
    - Insert `\nB` after CR
    - Call `GetLineRawContent(1)`
    - Observe OutOfRange exception

## Attached logs & stack traces
- See `agent-team/handoffs/AA4-009-QA.md` and `src/PieceTree.TextBuffer.Tests/TestMatrix.md` for exact run baseline and failing test names. Relevant logs included in this file entry.

## 2025-11-21 Porter-CS Revalidation (AA4-009 rerun)

| Command | Result | Notes |
| --- | --- | --- |
| `PIECETREE_DEBUG=0 dotnet test src/PieceTree.TextBuffer.Tests/PieceTree.TextBuffer.Tests.csproj --nologo` | **119/119** (7.4s) | Full-suite rerun capturing AA4-009 verification after the latest Porter-CS drop. Confirms builder/factory + change-buffer/CRLF suites remain green; matches expected 119-count baseline noted in AA4-006 Result. |
| `PIECETREE_DEBUG=0 dotnet test src/PieceTree.TextBuffer.Tests/PieceTree.TextBuffer.Tests.csproj --filter "FullyQualifiedName~PieceTreeBuilderTests|FullyQualifiedName~PieceTreeFactoryTests" --nologo` | **7/7** (2.2s) | CL5 regression spot-check to ensure `PieceTreeBuilder`/`PieceTreeTextBufferFactory` parity stays intact. |
| `PIECETREE_DEBUG=0 PIECETREE_FUZZ_LOG_DIR=/tmp/aa4-009-fuzz-logs dotnet test src/PieceTree.TextBuffer.Tests/PieceTree.TextBuffer.Tests.csproj --filter FullyQualifiedName~CRLF_RandomFuzz_1000 --nologo` | **1/1** (2.9s) | Deterministic CRLF fuzz harness (seed 123). `FuzzLogCollector` configured to persist logs in `/tmp/aa4-009-fuzz-logs`; no file was emitted because the run succeeded, but the directory now records the canonical fuzz-log location for AA4-009. |

### CL6 verification notes (rerun)
- `AA005Tests.TestSplitCRLF`, `PieceTreeModelTests.CRLF_RepairAcrossChunks`, `PieceTreeModelTests.CRLF_FuzzAcrossChunks`, and `CRLFFuzzTests.CRLF_RandomFuzz_1000` all executed within the 119-test suite and targeted reruns; no regressions observed.
- Change-buffer heuristics (`LastChangeBufferPos_AppendOptimization`, `ChangeBufferFuzzTests`) and metadata rebuild tests remained green, indicating Porter-CS fixes continue to hold.
- Future fuzz failures will emit logs under `/tmp/aa4-009-fuzz-logs` thanks to the enforced env vars; none were generated in this cycle.

## Next steps (QA)
1) Maintain `/tmp/aa4-009-fuzz-logs` as the canonical destination for deterministic CRLF fuzz logs (`PIECETREE_FUZZ_LOG_DIR`) so future failures capture operation traces without polluting console output.
2) Track upcoming CL7/CL8 drops (cursor + DocUI search) and extend `TestMatrix.md`/`AA4-009-QA.md` with their regression data once Porter-CS hands off.
3) Coordinate with Info-Indexer / DocMaintainer to broadcast the 119/119 baseline and targeted rerun references inside the next AA4 changefeed update.

## 2025-11-23 DocUI Find validation
- Reviewed staged DocUI find diffs (DocUIFindController, FindModel SelectAllMatches, FindUtilities selection seeding, DocUI test suites) to ensure Batch #3 plumbing is ready for Porter’s DocUI overlay drops.
- Targeted command: `PIECETREE_DEBUG=0 dotnet test tests/TextBuffer.Tests/TextBuffer.Tests.csproj --filter FullyQualifiedName~DocUIFind --nologo` → **17/17**, Failed: 0, Duration: 1.9s (controller/model/selection suites). Log recorded in `tests/TextBuffer.Tests/TestMatrix.md#targeted-reruns-b3-fc-2025-11-23`.
- Scenarios executed: controller navigation loops + selection seeding, FindModel.SelectAllMatches scope ordering, FindSelection hyphen separator regression. Preserve-case toggle + empty-clipboard guard still pending staged parity (tracked as coverage gap in QA findings).

### 2025-11-23 DocUI restage addendum
- Restaged diff audit confirmed DocUIFindController, FindModel, FindUtilities, and DocUI tests now include the preserve-case toggle defaults, host word separator plumbing, and the empty-global-clipboard guard that were missing in the previous staging pass.
- Re-executed `PIECETREE_DEBUG=0 dotnet test tests/TextBuffer.Tests/TextBuffer.Tests.csproj --filter FullyQualifiedName~DocUIFind --nologo` post-restage → **17/17 green**, Duration: 1.6s; entry mirrored into `tests/TextBuffer.Tests/TestMatrix.md` for traceability.
- Remaining TODOs:
   1. Bring over TS multi-cursor DocUI find cases (Test07/08) so SelectAllMatches parity also covers multi-selection ordering.
   2. Capture TRX artifacts + clipboard guard toggling logs for DocUI-specific runs to ease future regressions (planned under `TestResults/pipemux/` once overlay drops land).
   3. Extend DocUI find snapshot coverage once overlay degrade-path fixtures arrive (ties into AA4-008 F1/F4 checklist).

## Wrap up (current)
- QA started 2025-11-21 and revalidated Porter-CS CL5/CL6 drops the same day. CRLF-focused harnesses remain in `CRLFFuzzTests.cs`, `TestMatrix.md` now tracks the 119-test baseline plus targeted reruns, and `PIECETREE_DEBUG=0` full-suite command (`--nologo`) recorded **119/119** passing with deterministic fuzz logs redirected to `/tmp/aa4-009-fuzz-logs`. Previously failing CRLF tests remain green across multiple permutations.

## Final QC
- **QA Verified (CL6):** Porter-CS fixes for AA4-006 remain validated — `PIECETREE_DEBUG=0 dotnet test ... --nologo` produced 119/119 passing, builder/factory spot checks stayed green, and deterministic CRLF fuzz runs (seed 123) completed without errors.
- **Artifacts / Logs:** Historical logs remain under `~/aa4_006_*` from the initial rerun; the active fuzz log destination for AA4-009 is `/tmp/aa4-009-fuzz-logs` (ready to capture future failures when `FuzzLogCollector` flushes).
