# AA2-003 – C# Search/Interaction Parity Audit

## Findings
| Missing Feature | Risk | Files | Notes |
| --- | --- | --- | --- |
| Capture-group exposure & regex semantics not aligned | High – advanced find/replace with backreferences cannot behave like VS Code; zero-length regexes on astral chars can hang | ts/src/vs/editor/common/model/textModelSearch.ts, ts/src/vs/base/common/strings.ts, src/PieceTree.TextBuffer/Core/PieceTreeSearcher.cs, src/PieceTree.TextBuffer/Core/SearchTypes.cs, src/PieceTree.TextBuffer/Core/PieceTreeModel.cs | TS `createFindMatch` always returns `FindMatch.captures` when requested and its `Searcher.next` advances by whole code points while regexes are created with the `u` flag (`strings.createRegExp`). The C# port only fills `FindMatch.Matches` inside `FindMatchesLineByLine`, exposes no public API that accepts `captureMatches`, and `PieceTreeModel.ExecuteSearch` still throws. Worse, `PieceTreeSearcher.Next` advances `_lastIndex++` for empty matches, so a pattern like `(?=)` on `U+1F600` splits the surrogate pair and can loop forever, and .NET regexes reject modern escapes such as `\u{1F600}` that VS Code accepts. |
| Unicode word boundary classifier missing | High – whole-word search is wrong for any locale that is not basic ASCII and ignores custom separators supplied by callers | ts/src/vs/editor/common/core/wordCharacterClassifier.ts, src/PieceTree.TextBuffer/Core/SearchTypes.cs | VS Code builds a `WordCharacterClassifier` that honors the editor’s `wordSeparators` option and, when available, uses `Intl.Segmenter` to detect word breaks per locale. The C# `WordCharacterClassifier` ignores the provided separators entirely and deems only `[0-9A-Za-z_]` as word characters, so `wordSeparators` are silently ignored and scripts such as Hindi, Japanese, etc. can never satisfy `` or “match whole word”. |
| Multiline search lacks LF normalization and cannot span piece boundaries | High – regexes containing newlines stop matching once the document splits into multiple pieces or when the file is CRLF, so results diverge from VS Code | ts/src/vs/editor/common/model/textModelSearch.ts, src/PieceTree.TextBuffer/Core/PieceTreeModel.Search.cs | TS routes multiline patterns through `_doFindMatchesMultiline/_doFindNextMatchMultiline`, joins the entire range with `model.getValueInRange(..., EndOfLinePreference.LF)`, and uses `LineFeedCounter` to re-map ranges so matches can cross any line or piece while still working in CRLF files. The C# searcher never builds a normalized buffer: `FindMatchesLineByLine` feeds newline-free strings into `FindMatchesInLine`, and even when it calls `FindMatchesInNode` it stops at each node boundary. As soon as edits create multiple pieces, a pattern like `foo\nbar` or `^begin.*end$` simply never matches even though TS handles it. |
| TextModel search APIs (`findNextMatch`, `findMatches`, `replaceMatches`) absent | Medium – editor features that rely on these entry points cannot call into the buffer at all | ts/src/vs/editor/common/model/textModel.ts, ts/src/vs/editor/contrib/find/browser/findModel.ts, src/PieceTree.TextBuffer/TextModel.cs, src/PieceTree.TextBuffer/Core/PieceTreeModel.cs | VS Code’s `ITextModel` exposes `findMatches`, `findNextMatch`, `findPreviousMatch`, and the find/replace UI builds on those plus `replace`/`replaceAll`. The C# `TextModel` has no search methods, and `PieceTreeModel.ExecuteSearch` still throws `NotSupportedException`, so there is no surface to request matches, capture data, or replacements. |

## Tests to add
- Add a regression test that calls the eventual `TextModel.findMatches` with `captureMatches=true` on a pattern like `(l(in)e)` to assert the returned `FindMatch.Matches` mirrors VS Code and that zero-length regexes over astral code points do not hang the C# searcher.
- Extend the search tests with whole-word scenarios covering (a) a custom `wordSeparators` string (e.g., `` `~! ``) and (b) a Unicode-only word such as `नमस्ते`, proving that the classifier respects separators and locale-aware segmentation.
- Port a multiline CRLF test from `textModelSearch.test.ts` where the buffer contains `\r\n` line endings and the pattern spans two lines (e.g., `line\nnext`) to demonstrate the current walker stops at node/line boundaries.
- Once public APIs exist, add an integration test that exercises `findNextMatch`, `findPreviousMatch`, and a replace-all flow to ensure results are identical to the TS suite for both regex and literal patterns.

## Remediation priority
1. Implement the multiline search path (LF-normalized concatenation + LineFeedCounter equivalent) so regexes containing newlines behave like VS Code regardless of CRLF files or piece boundaries.
2. Port the full `WordCharacterClassifier` (including `wordSeparators` parsing and optional `Intl.Segmenter` data) to restore accurate whole-word queries outside ASCII.
3. Expose the `TextModel` search methods and hook them to `PieceTreeModel`, returning capture data and wiring them into replace flows; remove the `ExecuteSearch` stub.
4. Align regex semantics by mirroring `strings.createRegExp` flags and updating `PieceTreeSearcher` to advance by code point, and add tests for .NET regex feature gaps (e.g., `\u{...}` escapes) so parity decisions are explicit.
