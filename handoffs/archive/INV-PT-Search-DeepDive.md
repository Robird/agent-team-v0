# INV-PT-Search-DeepDive – 2025-11-26

## Scope
- Plan: ALIGN-20251126 (role: Investigator Mira Chen) – focus on `GetAccumulatedValue`, `_lastChangeBufferPos`, CRLF append/`hitCRLF`, and search cache invalidation.
- Files inspected: `src/TextBuffer/Core/PieceTreeModel.Search.cs`, `PieceTreeModel.Edit.cs`, `PieceTreeModel.cs`, `PieceTreeSearchCache.cs`; TS references from `ts/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.ts`.

## Summary Table (deviation → action)
| Area | Current C# behavior | TS reference | Required change |
| --- | --- | --- | --- |
| `GetAccumulatedValue` & callers (`PieceTreeModel.Search.cs` L194-L385) | Scans chars inside the piece for every call, ignoring `ChunkBuffer.LineStarts`; `NodeAt2` therefore performs two tree walks and re-scans slices, and `GetLineRawContent`/`FindMatches` hit the same O(n) loop repeatedly. Cross-piece CRLF also miscounts because the helper never looks beyond the local span. | `pieceTreeBase.ts` L1310-L1392 (`getAccumulatedValue`, `nodeAt2`, `getLineRawContent`) uses precomputed `lineStarts` offsets and stores `(node, nodeStartOffset, nodeStartLine)` in the cache so the tree is only traversed once per query. | Reimplement `GetAccumulatedValue` to mirror the TS math (`lineStarts[piece.start.line + index + 1] - lineStarts[piece.start.line] - piece.start.column`) and update `NodeAt2`/`GetLineRawContent` to reuse the cached `(node,line)` tuple. This restores O(1) line lookup and prevents CR/LF splits from drifting offsets. |
| Change-buffer append (`AppendToChangeBufferNode`, `PieceTreeModel.Edit.cs` L224-L262) | Appends straight into `_buffers[0]` via `ChunkBuffer.Append` after `AdjustCarriageReturnFromNext`. Missing the TS `hitCRLF` branch, so when the existing change-buffer node ends with `\r` and the new text starts with `\n`, `_buffers[0].LineStarts` keeps both entries and `_lastChangeBufferPos` stays one column behind. Subsequent inserts report doubled line counts. | `pieceTreeBase.ts` L1434-L1498 (`appendToNode`) detects `hitCRLF = endWithCR(node) && startWithLF(value)`, pops the last line-start entry, rewinds `_lastChangeBufferPos`, and only then appends. | Port the `hitCRLF` logic: detect CR/LF boundary before calling `ChunkBuffer.Append`, remove the stale line-start, rewind `_lastChangeBufferPos`, and invalidate the affected cache range so CR/LF pairs continue to count as a single break. |
| Change-buffer chunk creation (`CreateNewPieces`, `PieceTreeModel.Edit.cs` L699-L734) | Relies on `ChunkBuffer.Append(text)` with no bridge when buffer 0 ends with `\r` and the new chunk starts with `\n`; `_lastChangeBufferPos` simply jumps to the end cursor returned by the append. When CR/LF is split across two `CreateNewPieces` calls, the CR half is already classified as a full line break; adding the LF keeps the extra line-start, so later inserts begin one column too early. | `pieceTreeBase.ts` L1189-L1236 inserts a sentinel (`'_' + text`), shifts the incoming `lineStarts` by `startOffset+1`, and bumps `_lastChangeBufferPos` before writing so the CR from the previous chunk merges with the LF in the new chunk. | Replicate the TS bridge: detect CR-at-end/LF-at-start, temporarily advance `_lastChangeBufferPos`, shift the incoming `lineStarts`, append the sentinel char so `_buffers[0]` retains monotonic offsets, and backfill the cache invalidation the way TS does. |
| Search cache invalidation (`PieceTreeSearchCache.cs` L87-L133 + insert/delete callers) | `_searchCache.InvalidateRange(Math.Max(0, offset-1), value.Length+2)` only drops entries intersecting the edit span. Nodes to the right keep stale `nodeStartOffset`, so a cached node returned after an insert reports `remainder = offset - oldStart`, i.e., the entry thinks it still begins before the edit (example: cache node at 100, insert 5 chars at 0 → cache still reports start 100 while real start is 105). | TS `PieceTreeSearchCache` never tries partial invalidation; after edits `computeBufferMetadata` resets `_length` and consumers rely on the single-entry cache being dropped when its node detaches. The cached `nodeStartOffset` is only valid while the tree remains unmodified. | Align invalidation semantics with TS: either drop the cache completely (`Clear()`) on every insert/delete or call `InvalidateRange(mutationStart, int.MaxValue)` so everything at/after the mutation offset is recomputed. Without this, `NodeAt`/`nodeAt2` can return incorrect remainders immediately after edits. |

## Instrumentation & Test Notes
- Deterministic `PieceTreeModelTests`: capture offsets for a representative TS document (mix of CRLF/LF) and assert `GetOffsetAt`, `GetLineContent`, and `FindMatchesLineByLine` stay in sync after randomized inserts/deletes. Mirror TS fixtures from `pieceTreeBase.test.ts` for line-offset parity.
- Add a focused regression test where `_buffers[0]` ends with `\r` and successive inserts start with `\n` to prove `_lastChangeBufferPos` and `TotalLineFeeds` stay stable once `hitCRLF` parity lands.
- Extend the existing deterministic/fuzz harness (ALIGN plan) so cache diagnostics log which entries survive edits; add an assertion that any insert/delete clears the cache or that cached offsets monotonically increase, catching future invalidation slips.

## Open Questions / Risks for Porter & QA
- Clearing the entire search cache on each mutation is the safest parity move, but it changes the custom `InvalidateRange` API we exposed to other components—confirm with Porter whether to keep the API (and call it with `int.MaxValue`) or to collapse to the TS behavior.
- Bridging via sentinel (`'_' + text`) changes the observable contents of `_buffers[0]`; QA needs to confirm that snapshots/tests reading buffer 0 directly are tolerant of the placeholder byte.
- `ChunkBuffer.Append` currently has no hooks for CRLF bridging; once we port `hitCRLF`, verify whether the helper should live at the buffer level (affects other change-buffer users) or only inside `PieceTreeModel`.
- Fuzz plan: QA to schedule the CRLF + cache fuzz harness (per ALIGN) once the fixes land so we can capture before/after telemetry for `_lastChangeBufferPos` drift.
