# AA2-004 – Diff & Decorations Parity Audit

## Findings
| Area | Risk | Files | Notes |
| --- | --- | --- | --- |
| Prettify / optimize sequence passes absent | High – DocUI will surface noisy diffs (every whitespace-only shift or comma insertion shows as independent ops instead of TS’s merged spans) which degrades review readability | ts/src/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.ts, ts/src/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.ts, src/PieceTree.TextBuffer/Diff/DiffComputer.cs | TS runs multiple prettification passes (`optimizeSequenceDiffs`, `removeShortMatches`, `extendDiffsToEntireWordIfAppropriate`, `removeVeryShortMatchingLinesBetweenDiffs`, etc.) after Myers/DP alignment, plus line/char refinement that respects trim-whitespace and subword extensions. The C# `DiffComputer` is a bare Myers split that only trims shared prefixes/suffixes and concatenates adjacent exact continuations, so whitespace-only edits never shift, char-level merges are missing, and no `shouldMakePrettyDiff` equivalent exists. Result: large sequences of small insert/delete hunks, no minified view, and MarkdownRenderer consumers must absorb every raw op. |
| Move heuristics missing | Medium – moved blocks render as delete+insert pairs, hiding intent and preventing move-highlighting scenarios from TS (`computeMoves`) | ts/src/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.ts, ts/src/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.ts, src/PieceTree.TextBuffer/Diff/DiffComputer.cs | TS optionally (`options.computeMoves`) hashes trimmed lines, runs `computeMovedLines`, and re-diffs each detected move so UI consumers can colorize moved text. The C# port never attempts move detection (no hashes, no `MovedText`), so any move shows as unrelated delete/insert which is especially confusing inside doc-review flows where relocations are common. |
| Decoration model lacks stickiness modes beyond a naive list adjuster | High – cursor/selections drift or fail to collapse the way VS Code expects, and update cost is O(N) per edit | ts/src/vs/editor/common/model/intervalTree.ts, ts/src/vs/editor/common/model/textModel.ts, src/PieceTree.TextBuffer/Decorations/IntervalTree.cs, src/PieceTree.TextBuffer/Decorations/ModelDecoration.cs, src/PieceTree.TextBuffer/Rendering/MarkdownRenderer.cs | TS stores decorations in three red-black interval trees, honoring `TrackedRangeStickiness` variants, `collapseOnReplaceEdit`, `forceMoveMarkers`, injected text, overview ruler lanes, `showIfCollapsed`, line heights, etc., all resolved lazily via cached version ids. C# keeps a flat `List<ModelDecoration>` and only nudges offsets with a simplified stickiness check; there is no collapse-on-replace, no glyph/margin metadata, and no injected-text split. Large documents pay O(decorations) per edit, and visual behaviors like “select, type to collapse” or “margin-only decoration” simply cannot match TS. |
| Decoration ownership + delta events absent | Medium – no way to scope updates per editor/view, DocUI can’t know which decorations changed, and undo/redo parity breaks | ts/src/vs/editor/common/model/textModel.ts (DecorationsTrees + DidChangeDecorationsEmitter), ts/src/vs/editor/common/model/intervalTree.ts, src/PieceTree.TextBuffer/TextModel.cs | TS tracks `ownerId`, cached version ids, and fires `onDidChangeDecorations` with affected line info whenever `deltaDecorations` runs; nodes carry ids/options so controllers can diff state. C# `TextModel` exposes only `AddDecoration`/`GetDecorationsInRange`, never stores owners, never bumps per-decoration versions, and never raises decoration delta events—only `OnDidChangeContent` exists. Features that rely on owner filtering (like diff view vs inline view) or expect decorators to observe version counters have no parity path. |

## Tests to add
- Diff parity fixture that runs the TS `DefaultLinesDiffComputer` and the C# `DiffComputer` over scenarios with (a) whitespace-only indentation shifts, (b) punctuation insertions (`, Foo`), and (c) small unchanged islands between long edits to prove the C# output explodes into multiple hunks and to establish expected prettified output.
- Move-detection regression where the same block is removed from the top and inserted at the bottom while `computeMoves` is enabled in TS; assert the C# port surfaces the move as delete+insert so we have a failing test prior to implementing hashing + `MovedText` plumbing.
- Decoration stickiness & collapse tests: create a zero-length decoration with `AlwaysGrowsWhenTypingAtEdges`, type before/after, and replace the entire range with `collapseOnReplaceEdit=true`; compare offsets between TS interval tree behavior and the C# list implementation to capture the current drift.
- Event/owner test: issue `deltaDecorations` in TS and ensure `onDidChangeDecorations` reports affected owners/version bumps; assert the C# `TextModel` provides no equivalent so the gap is codified.

## Remediation priority
1. Port the TS diff pipeline (DP/Myers hybrid + `optimizeSequenceDiffs`, whitespace scanning, char-level refinement, and trim-aware prettify toggles) so DocUI consumers get minified outputs that match VS Code.
2. Implement move detection by hashing trimmed lines and mirroring `computeMovedLines`/`MovedText` so DocUI can highlight relocated paragraphs instead of treating them as independent edits.
3. Replace the list-based decoration store with a proper interval tree that mirrors TS metadata (`ownerId`, overview ruler, injected text, glyph margin, `collapseOnReplaceEdit`, `forceMoveMarkers`) and keeps updates O(log N).
4. Add decoration ownership + delta events to `TextModel` (matching `DidChangeDecorationsEmitter` semantics) so views can subscribe to scoped updates, and wire version counters/cached ranges just like TS.
