# PORT-PT-Search-Step12-INV

Investigator-TS review for Action 1 from `docs/reports/alignment-audit/00-summary.md` ("PORT-PT-Search-Plan Step1/2"). Scope covers `src/TextBuffer/Core/PieceTreeModel.Edit.cs`, `PieceTreeModel.Search.cs`, `PieceTreeSearchCache.cs` versus the VS Code references (`pieceTreeTextBuffer.ts`, `pieceTreeTextBufferSearch.ts`, `pieceTreeBase.ts`). Anchors: [`docs/reports/migration-log.md#sprint04-r1-r11`](../../docs/reports/migration-log.md#sprint04-r1-r11), [`agent-team/indexes/README.md#delta-2025-11-26-sprint04-r1-r11`](../indexes/README.md#delta-2025-11-26-sprint04-r1-r11), [`agent-team/handoffs/WS1-PORT-CRLF-Result.md`](WS1-PORT-CRLF-Result.md) (`#delta-2025-11-26-ws1-port-crlf`), and fuzz/search baselines (`#delta-2025-11-24-b3-piecetree-fuzz`).

## Gaps
- `NodeAt2` still performs two RB-tree walks (`PieceTreeModel.Search.cs`): it converts `(line,column)` to an offset via `GetOffsetAt()` then calls `NodeAt()`, never reusing the tuple that TS stores in `_searchCache`. `_searchCache.Remember()` is invoked without `nodeStartLineNumber`, so `TryGetByLine()` always misses. TS `pieceTreeTextBuffer.ts#nodeAt2` caches `(node, nodeStartOffset, nodeStartLine)` once and hands that tuple to `getValueInRange`, `getLineContent`, and `findMatches`. Today every call to `GetLineCharCode`, `GetLineRawContent`, `GetValueInRange`, `FindMatchesLineByLine`, and `GetPositionAt` re-traverses the tree, leaving the Step1 tuple reuse from `PORT-PT-Search-Plan.md` unimplemented.
- `GetAccumulatedValue` (same file) only subtracts two `LineStarts` entries and never inspects neighbor pieces, so the CRLF bridge described in [`WS1-PORT-CRLF-Result.md`](WS1-PORT-CRLF-Result.md) can still shift offsets when the placeholder `_` entry is present. TS falls back to scanning when `ShouldCheckCRLF()` is true and peeks at the preceding `\r`/next `\n` before finalizing the delta, keeping `_lastChangeBufferPos` stable; the C# helper ignores `_lastChangeBufferPos` entirely and therefore miscounts when Step2 hit detection collapses a CRLF pair across nodes.
- Tuple reuse hot paths keep rehydrating offsets: `GetLineRawContent`/`GetLineContent` recompute `relativeLineNumber` and call `GetAccumulatedValue` twice per line, `GetLineCharCode` and `GetValueInRange` invoke `NodeAt2` for every query, and `FindMatchesLineByLine` repeatedly calls `NodeAt2` inside the per-line loop. TS `pieceTreeTextBufferSearch.ts` threads the cached tuple (and the line delta) across these helpers to avoid re-traversal; the C# implementations never pass `nodeStartLineNumber`, so `_searchCache` cannot warm up for any of these hot paths.
- `PieceTreeSearchCache` diagnostics stop at `CacheHit/Miss/ClearedAfterEdit` under `#if DEBUG` (`PieceTreeSearchCache.cs`). The Step1 plan called for exposing `EntriesRemaining` plus production-safe telemetry via `PieceTreeModel.Diagnostics.SearchCacheSnapshot`, but release builds still drop all counters, no telemetry event is fired, and no test asserts cache health (`PieceTreeSearchRegressionTests` and fuzz harnesses cannot observe hits/misses). The cache also never records the line number for offset-based inserts, so Info-Indexer cannot quantify tuple reuse regressions.
- Cache invalidation remains best-effort: edits call `_searchCache.InvalidateRange(mutationStart, mutationLength)` in `PieceTreeModel.Insert/Delete/FixCRLF`, whereas TS clears every entry whose start offset is `>= mutationOffset`. Because Step1 tuple reuse is absent, survivors retain stale `nodeStartOffset` values and feed wrong data back into `GetLineRawContent`. No changefeed documents this deviation, so Info-Indexer cannot close the WS1 story even though `#delta-2025-11-26-ws1-port-crlf` captured the CRLF bridge half of the work.

## Requirements
- Reimplement `NodeAt2` exactly like `pieceTreeTextBuffer.ts`: resolve `(line,column)` by descending the tree once, populate `_searchCache.Remember(node, nodeStartOffset, nodeStartLineNumber)`, and return that tuple directly. Update `NodeHit` to carry the cached line delta so downstream callers stop invoking `GetOffsetAt()` a second time.
- Make `GetAccumulatedValue` hybrid-aware: use the current `LineStarts` math when `_eolNormalized && _eol == "\n"`, but fall back to a span scan when `ShouldCheckCRLF()` indicates bridging, peeking at the previous `\r`/next `\n` so `_lastChangeBufferPos` stays in sync with the placeholder technique from `WS1-PORT-CRLF-Result.md`.
- Thread the tuple through every hot path (`GetLineRawContent`, `GetLineContent`, `GetLineCharCode`, `GetValueInRange`, `FindMatchesLineByLine`, `FindMatchesInNode`, `GetPositionAt`). Each of these methods should accept either an existing `NodeHit` or the cached `(node,startLine)` from `_searchCache` to avoid additional tree walks.
- Extend `PieceTreeSearchCache` diagnostics per plan: add `EntriesRemaining` and `LastInvalidatedRange`, expose `SearchCacheSnapshot` in release builds via `PieceTreeModel.Diagnostics`, and surface a telemetry hook so `PieceTreeSearchRegressionTests`/`PieceTreeFuzzHarnessTests` can assert hit/miss ratios (no more `#if DEBUG` guard on the counters themselves). Emit an event whenever `Clear()` or `InvalidateRange()` drops an entry so Info-Indexer can measure cache churn.
- Align invalidation semantics with TS: introduce `InvalidateFromOffset(int offset)` that simply clears entries `>= offset` and call it from every mutation site (Insert/Delete/FixCRLF/CreateNewPieces). Keep `InvalidateRange` only for targeted diagnostics, but ensure the edit path always performs the full clear so tuple reuse never sees stale nodes.

## Test Evidence (re-run after Step1/2 lands)
- `dotnet test tests/TextBuffer.Tests/TextBuffer.Tests.csproj --filter CRLFFuzzTests --nologo` (`#delta-2025-11-26-ws1-port-crlf`) – proves `_lastChangeBufferPos` and the CRLF bridge still behave after the new `GetAccumulatedValue` path.
- `dotnet test tests/TextBuffer.Tests/TextBuffer.Tests.csproj --filter PieceTreeSearchRegressionTests --nologo` (`tests/TextBuffer.Tests/TestMatrix.md#ws5-qa`) – validates `FindMatchesLineByLine`, `GetLineRawContent`, and `GetLineCharCode` parity once tuple reuse is live.
- `dotnet test tests/TextBuffer.Tests/TextBuffer.Tests.csproj --filter PieceTreeSearchOffsetCacheTests --nologo` (`#delta-2025-11-25-b3-search-offset`) – ensures `_searchCache` hits survive edits now that invalidation semantics changed.
- `dotnet test tests/TextBuffer.Tests/TextBuffer.Tests.csproj --filter PieceTreeDeterministicTests --nologo` (`#delta-2025-11-25-b3-piecetree-deterministic-crlf`) – confirms `GetOffsetAt`/`GetPositionAt` results match TS after the new `GetAccumulatedValue` math.
- `dotnet test tests/TextBuffer.Tests/TextBuffer.Tests.csproj --filter PieceTreeFuzzHarnessTests --nologo` (`#delta-2025-11-24-b3-piecetree-fuzz`) – stresses tuple reuse + cache invalidation under random CR/LF inserts; harness should assert the new diagnostics snapshot (hits vs misses) once per run.

## Doc hooks & changefeed instructions
- **Info-Indexer:** create a dedicated `delta-2025-11-27-ws1-port-search-step12` row in `agent-team/indexes/README.md` and `docs/reports/migration-log.md` once tuple reuse + diagnostics land; link it back to `#delta-2025-11-26-ws1-port-crlf` so the CRLF+search story is fully traceable. Update the WS1 summary in `agent-team/task-board.md` and `docs/sprints/sprint-04.md` to state that Step1/2 is now complete rather than "tuple reuse deferred".
- **DocMaintainer:** refresh `tests/TextBuffer.Tests/TestMatrix.md#ws1-port` with the rerun commands above and record the new diagnostic assertions; add cross-links to `PieceTreeModel.Search.cs` and `PieceTreeSearchCache.cs` so future audits see where the tuple/telemetry landed.
- **Planner/AGENTS:** once Info-Indexer publishes the new delta, update `AGENTS.md` and the Sprint 04 log (`docs/sprints/sprint-04.md`) to close out Action 1 and move any remaining WS1 backlog items into WS5 (testing) or AA4 CL7 (cursor/word). Mention the new changefeed in `agent-team/handoffs/PORT-PT-Search-Plan.md` so downstream Porters consume the same anchor.
- **Telemetry note:** when Diagnostics are exposed, add a short note to `src/TextBuffer/README.md` under the search section describing the new `SearchCacheSnapshot` hook and reference `docs/reports/migration-log.md#sprint04-r1-r11` so Info-Indexer has a canonical doc location to cite.
