# AA2-001 – PieceTree Advanced Behavior Audit

## Findings
| Missing Feature | Risk | Files | Notes |
| --- | --- | --- | --- |
| CRLF boundary repair is not ported | High – deleting or inserting across split `\r\n` leaves stray `\r` or `\n`, so text content and line counts diverge | `src/PieceTree.TextBuffer/Core/PieceTreeModel.Edit.cs` L224-L270, L318-L344 vs `ts/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.ts` L948-L1016 & L1600-L1740 | C# never calls `ValidateCRLFWithNextNode` (it does not exist) after split deletions, and the existing `ValidateCRLFWithPrevNode` only decrements `LineFeedCount` without actually moving characters or creating the replacement `\r\n` piece like TS `fixCRLF`. Any delete that spans piece boundaries can either drop the `\n` half or double-count `\r`, corrupting the buffer and `_lineCnt`. |
| Aggregated length / line-feed metadata not recomputed after edits | High – multi-line inserts/deletes leave `TotalLength`, `TotalLineFeeds`, and any API using `_root.Aggregated*` stale | `src/PieceTree.TextBuffer/Core/PieceTreeModel.cs` L24-L35, `PieceTreeNode.cs` L120-L154, `PieceTreeModel.Edit.cs` L363-L423 | TS always calls `computeBufferMetadata()` (L1315-L1345) after each mutation, but C# removal helpers (`DeleteNodeHead`, `DeleteNodeTail`, `ShrinkNode`) never call `RecomputeMetadataUpwards`. After a multi-line delete, `_root.AggregatedLength` still reflects the pre-edit document, so consumers that rely on `TotalLength`/`GetOffsetAt` will misbehave even if the on-disk text changed correctly. |
| Piece count invariant is broken | Medium – `PieceTreeModel.PieceCount` drifts immediately after the first edit, so diagnostics that rely on it cannot trust the value | `src/PieceTree.TextBuffer/Core/PieceTreeModel.cs` L17-L35, L137-L171 | `_count` is reset during `NormalizeEOL` and incremented in `InsertPieceAtEnd`, but none of the editing paths (`Insert`, `Delete`, `RbInsert*`, `RbDelete`) update it. TS derives piece count on demand; the exposed C# property now diverges from the actual number of tree nodes and can underflow after deletions. |
| Search cache retains deleted nodes when removing a whole piece | High – `NodeAt` can return a detached node, leading to undefined traversal or crashes during subsequent edits | `src/PieceTree.TextBuffer/Core/PieceTreeModel.Edit.cs` L224-L230, `PieceTreeNode.cs` L63-L75, `PieceTreeSearchCache.cs` L54-L90 vs TS `pieceTreeBase.ts` L1315-L1345 | When `Delete` excises an entire node, we never call `_searchCache.InvalidateFromOffset`. Unlike TS (whose `TreeNode.detach()` sets `parent = null` and whose `computeBufferMetadata()` always validates the cache), the C# detach pins `Parent = Sentinel`, so `CacheEntry.IsValid` never drops the entry. The cache therefore keeps returning a node that is no longer in the tree, and any subsequent `NodeAt`/`GetLineContent` that hits it will operate on garbage state. |

## Tests to add
- Port a CRLF regression test (e.g., delete spanning the `\r|\n` boundary from `pieceTreeTextBuffer.test.ts` around L900) into `PieceTree.TextBuffer.Tests` to assert the buffer still reads `\r\n` and the line count stays constant after the edit.
- Add a multi-line edit test that compares `TotalLength`, `TotalLineFeeds`, and `GetLinesRawContent()` after a delete/insert round-trip to ensure metadata tracks the actual string length.
- Add a cache invalidation test that primes `PieceTreeSearchCache` via `NodeAt`, deletes the referenced node entirely, and asserts the next `NodeAt` call returns the new successor instead of the detached node.
- Cover `PieceCount` by starting from a multi-piece buffer, performing inserts/deletes, and asserting `PieceCount` matches the actual inorder traversal count.

## Suggested remediation priority
1. Restore the CRLF repair pipeline (port `fixCRLF`, `validateCRLFWithNextNode`, and the `adjustCarriageReturnFromNext` helpers) before enabling mixed-line-ending edits – this is a user-visible data corruption risk.
2. Fix metadata recomputation (`RecomputeMetadataUpwards` or an explicit `computeBufferMetadata` equivalent) so `TotalLength`/`TotalLineFeeds` stay correct after every edit.
3. Address `_searchCache` invalidation for whole-node deletes (either call `InvalidateFromOffset` or align `Detach` semantics with TS) to prevent stale cache entries.
4. Update `_count` maintenance as part of routine insert/delete bookkeeping to keep diagnostics meaningful.
