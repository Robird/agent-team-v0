## Overview
- Sprint anchor `docs/sprints/sprint-02.md` (CL6 – ChangeBuffer/CRLF/large edits parity) and task card `agent-team/task-board.md` → `AA4-002` target completing TS↔C# parity checks ahead of CL6 sign-off.
- Compared TS `pieceTreeTextBufferBase.ts` / `pieceTreeTextBuffer.ts` with C# `PieceTreeModel.*`, `PieceTreeBuilder`, `ChunkBuffer`, and `PieceTreeSearchCache` to map change-buffer reuse, CRLF repair, chunking, and cache/metadata behavior.
- Changefeed checkpoint already consumed: `agent-team/indexes/README.md#delta-2025-11-20`; findings below seed the next delta once fixes land.

## Findings
| # | Severity | Gap | TS Reference | C# Reference | Description | Proposed Fix | Blocking Risk |
|---|----------|-----|--------------|--------------|-------------|--------------|---------------|
| 1 | High | Change-buffer append heuristics never fire | `ts/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.ts` (`insert`, `appendToNode`, `createNewPieces`) | `src/PieceTree.TextBuffer/Core/PieceTreeModel.Edit.cs` (`Insert`) & `PieceTreeBuilder.cs` | TS appends small edits into buffer `0` when `_lastChangeBufferPos` matches the target node, avoiding new chunks. The C# port always allocates new `ChunkBuffer`s (`CreateNewPieces` comment: "TODO... append to change buffer"), so repeated typing explodes buffer count, fragmenting metadata and starving cache locality. | Implement the same append fast-path: track last change-buffer node, allow `_buffers[0]` growth until `AverageBufferSize`, and reuse nodes when edits target the tail, then recompute metadata once. | High – Without change-buffer reuse we cannot meet CL6 performance parity; buffer explosion also stresses GC.
| 2 | High | `_lastChangeBufferPos` state missing | `pieceTreeBase.ts` fields `_lastChangeBufferPos` & logic in `createNewPieces` | No equivalent in `PieceTreeModel` or `ChunkBuffer` | TS tracks the last cursor inside buffer `0` to compute start/end cursors for future inserts and to repair CRLF joins when appending. The C# port lacks any state, so even if we add append heuristics later we cannot compute cursors or update line starts, and CR/LF merges in buffer `0` are impossible. | Introduce `_lastChangeBufferPos` (line/column) inside `PieceTreeModel`, seed it during build, update it whenever `_buffers[0]` grows, and plumb it through `CreateNewPieces`/`Insert` exactly like TS. | High – prerequisite for any change-buffer reuse work; without it, edits keep allocating new buffers and the CRLF repair path cannot know local context.
| 3 | High | CRLF repair/validation stubs | `pieceTreeBase.ts` (`shouldCheckCRLF`, `endWithCR`, `startWithLF`, `adjustCarriageReturnFromNext`, `validateCRLFWithPrevNode/NextNode`, `fixCRLF`, CR-aware insert/delete branches) | `PieceTreeModel.Edit.cs` (`InsertContentToNodeLeft/Right`, `Insert`, `Delete`, `FixCRLF`) | TS aggressively detects `\r` / `\n` splits when inserting or deleting, moving the stray byte to the correct piece and updating metadata. The C# port leaves TODOs, never inspects newly inserted text for dangling CR/LF, and uses a simplified `FixCRLF` that only fires when two existing nodes already expose `\r`/`\n`. Result: inserting `"\r"` before a node that begins with `\n` or deleting inside a CRLF pair produces double line-feeds or orphaned carriage returns, throwing off offsets and search results. | Port the full CRLF handling (including `adjustCarriageReturnFromNext`, `startWithLF` checks against inserted strings, node trimming when values start/end with newline, and the post-insert validation cascade) and ensure delete paths recompute LF deltas before running `ValidateCRLF*`. | High – CRLF corruption breaks `GetLineContent` parity and prevents CL6 sign-off for CRLF files.
| 4 | Medium | `AverageBufferSize` chunk splitting not implemented | `pieceTreeBase.ts` (`AverageBufferSize`, `createNewPieces` splitting, surrogate protection) | `PieceTreeModel.Edit.cs` (`CreateNewPieces`) | TS splits large inserts (~64KB) into multiple pieces (respecting CR at split boundary and surrogate pairs) to keep tree depth stable. C# currently allocates one `ChunkBuffer` per edit regardless of size ("TODO: Handle large text splitting"), so pasting a multi-MB block produces a single oversized piece that makes tree rotations, substring scans, and normalization work quadratic. | Adopt the TS chunking algorithm: loop while `text.length > AverageBufferSize`, split before CR/surrogate boundaries, push each chunk (with precomputed line starts) into `_buffers`, and return an array of `PieceSegment`s. | Medium – large edits regress perf/memory and can stall CL6 parity benchmarks, though functionality survives.
| 5 | Medium | Line-feed metadata mismatched (`GetLineFeedCnt`) | `pieceTreeBase.ts` (`getLineFeedCnt` handling CRLF boundary columns) | `PieceTreeModel.Edit.cs` (`GetLineFeedCnt` simply returns `end.Line - start.Line`) | TS treats CRLF specially: when `end` cursor lands between `\r` and `\n`, it still counts one LF so metadata stays accurate. The C# helper ignores columns entirely, so splitting a node between `\r`|`\n` drops a line feed, making `LineFeedsLeft`, `GetOffsetAt`, and search results off-by-one. | Port the TS implementation, using `LineStarts` and buffer slices to detect `\r\n` pairs and adjust counts when `end.Column > 0` but the next char is `\n` preceded by `\r`. Update every caller (delete, shrink, split, CRLF fix). | Medium – metadata drift causes incorrect offsets once CRLF pairs are edited, blocking change-buffer parity on Windows files.
| 6 | Medium | Search-cache invalidation is coarse and lacks metadata-aware cleanup | TS `pieceTreeBase.ts` drives `_searchCache.validate` selectively inside edit branches and again via `computeBufferMetadata()` | `PieceTreeModel.Edit.cs` indiscriminately calls `_searchCache.InvalidateFromOffset(offset)` at entry/exit; no equivalent to `computeBufferMetadata` revalidation | TS only drops cache entries whose start offsets fall inside the mutation, letting cached `nodeAt` hits survive edits that do not touch them, and it performs one final `_searchCache.validate(this._length)` when metadata is recomputed. The C# port evicts the entire suffix on every edit and never revalidates against the latest `TotalLength`, so `GetLineContent`/`nodeAt` always walk the tree after each keystroke and stale cache entries may linger after non-insert rebuilds (e.g., normalization) because no global validation runs. | Mirror TS behavior: add a `ComputeBufferMetadata` helper that recomputes `_root.Aggregated*` plus `_lineCount/_length`, calling `_searchCache.validate(TotalLength)` at the end, and replace the coarse `_searchCache.InvalidateFromOffset(offset)` calls with branch-specific invalidations so unaffected caches survive. | Medium – currently a perf gap (cache never hits), which undermines CL6 "change-buffer reuse" KPIs tied to efficient search operations.

## Proposed Fixes
1. **Restore change-buffer semantics**: add `_lastChangeBufferPos`, port TS `appendToNode` heuristics, and teach `CreateNewPieces` to reuse buffer `0` until `AverageBufferSize` is reached.
2. **Port newline integrity logic**: migrate `shouldCheckCRLF`, `startWithLF`/`endWithCR`, `adjustCarriageReturnFromNext`, and the TS `getLineFeedCnt` so inserts/deletes keep metadata and CRLF pairs consistent.
3. **Improve structural hygiene**: implement TS-style chunk splitting, targeted search-cache validation, and a `ComputeBufferMetadata` pass so metadata/search caches converge with the JS reference implementation.

## Validation Hooks
- Extend `src/PieceTree.TextBuffer.Tests/PieceTreeBaseTests.cs` with cases that repeatedly insert small snippets at the caret, verifying buffer `0` growth, node counts, and absence of buffer explosions.
- Add CRLF integrity tests to `src/PieceTree.TextBuffer.Tests/PieceTreeNormalizationTests.cs` covering inserts/deletes that land between `\r` and `\n`, asserting line counts and `GetLineContent` outputs stay in sync with the TS model.
- Augment `src/PieceTree.TextBuffer.Tests/PieceTreeSearchTests.cs` (or a new `PieceTreeBuilderTests`) with scenarios that exercise the search cache before/after edits, ensuring `nodeAt` hits are preserved when edits occur elsewhere and invalidated when CRLF repairs mutate earlier nodes.

## References / Next Steps
- Use these findings to brief Porter and plan the CL6 fixes; reference this audit plus the sprint anchor when filing work items.
- When the fixes land, the changefeed entry should mention: `ts/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.ts`, `ts/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.ts`, `src/PieceTree.TextBuffer/Core/PieceTreeModel.*`, `PieceTreeBuilder.cs`, `ChunkBuffer.cs`, and `PieceTreeSearchCache.cs` to keep the indexers aligned with AA4-002.
- Next checkpoint: capture the follow-up delta in `agent-team/indexes/README.md` once change-buffer reuse, CRLF repairs, chunking, and cache/metadata fixes are merged.
