# 命名技能指南

> 本文档总结 Atelia 项目中命名工作的方法论和有效经验。
> 适用于：项目名、格式名、类型名、API 名等需要"起名"的场景。

---

## 核心原则

### 0. 统一视角：搜索与损失函数

> 所有命名方法都是"在损失函数下搜索"，差异在于**搜索策略**和**损失定义**。

| 方法 | 搜索策略 | 损失函数 |
|------|----------|----------|
| 全排列淘汰法 | 暴力枚举 + 过滤 | 唯一性 + 发音 + 含义 |
| Cycle Loss 法 | 采样 + 还原 | 重建损失（名字→描述的还原度）|
| 畅谈会共识法 | 多视角讨论 | 约束违反程度 |
| 类比锚定法 | 模式匹配 | 与前辈风格的偏差 |
| 反向排斥法 | 排除 + 幸存 | 排斥条件命中数 |

### 1. 名字是意义的"潜空间编码"

名字需要在**简洁**和**自明**之间取得平衡：
- **过长**：信息量大但难以记忆和使用
- **过短**：简洁但容易歧义
- **理想**：用最少的字符传达最关键的语义

> **类比**：名字就像 VAE 的潜空间编码——好的名字能让人从编码（名字）还原出意义（描述）。

### 2. 功能描述性 > 实现特征性

**目标用户视角**：用户（包括 LLM）会用**需求/功能**来搜索，而不是实现细节。

| 命名策略 | 示例 | 优劣 |
|----------|------|------|
| 功能描述 | Reversible Binary Framing | ✅ 用户会搜 "reverse binary" |
| 实现特征 | Symmetric Frame Framing | ❌ 用户不会搜 "symmetric" |

**GitHub 搜索测试**：想象你在 GitHub 搜索这个能力，会用什么关键词？

### 3. 分层处理约束

不同场景有不同的约束：

| 场景 | 约束 | 示例 |
|------|------|------|
| 格式名 | 可读性、自明性、无冲突 | RBF (Reversible Binary Framing) |
| Magic 常量 | 4 字节、ASCII 可读、hex dump 友好 | `RBF1` |
| 文件扩展名 | 3-4 字符、无冲突 | `.rbf` |
| 代码标识符 | 符合语言命名惯例、像名词 | `RbfFramer` |

### 4. 方法选择：适用边界框架

用二维坐标选择命名方法：

| 维度 | 低 | 高 |
|------|-----|-----|
| **X: 候选空间开放度** | empty（无从下手）| closed（已有有限候选）|
| **Y: 约束复杂度** | 单一约束 | 多约束冲突 |

**选择启发式**：

| 场景特征 | 推荐方法 |
|----------|----------|
| 候选空间空的（从 0 创造）| **全排列淘汰法** |
| 候选可采样但评价标准模糊 | **Cycle Loss 法** |
| 候选已封闭但约束冲突 | **畅谈会法** |
| 有明确的"领域前辈" | **类比锚定法** |
| "不要什么"比"要什么"更清晰 | **反向排斥法** |

---

## 方法论

### 方法 A：全排列淘汰法（Atelia 命名法）

**适用场景**：需要原创、独特的品牌名

**步骤**：

1. **提取核心概念**
   - 列出项目要表达的 3-5 个核心概念
   - 示例：`[autonomous, thinking, eternal, learning, introspective, agents]`

2. **生成候选词汇集合**
   - 为每个概念生成同义词/近义词
   - 包括缩写、词根、变体形式

3. **暴力排列组合**
   - 用 LLM 多轮生成有意义的组合
   - 不限制字符数，先求量

4. **筛选淘汰**
   - 过滤掉已存在的名字
   - 过滤掉难以发音的
   - 过滤掉有负面联想的

5. **最终对比**
   - 在入围名字中选择**均衡无明显短板**的
   - 考虑：发音、拼写、含义、唯一性

**示例**：Atelia = Autonomous Thinking Eternal Learning Introspective Agents

---

### 方法 B：Cycle Loss 采样法（StateJournal 命名法）

**适用场景**：需要从多个候选中选择最"自明"的名字

**原理**：好的名字应该能让人从名字还原出意义（类似 VAE 的重建损失）

**步骤**：

1. **阶段一：编码采样**（描述 → 名字）
   ```
   多次调用 runSubagent:
   "根据以下描述，推荐一个简洁的名字：{description}"
   ```
   - 收集所有推荐的名字
   - 按得票数排序，选 Top K（如 K=5）

2. **阶段二：解码采样**（名字 → 描述）
   ```
   多次调用 runSubagent:
   "根据名字 '{name}'，猜测这个项目/概念的含义"
   ```
   - 比较还原的描述与原始描述的相似度
   - 选择**还原度最高**的名字

3. **阶段三：专家投票**
   - 最终入围的 2-3 个名字
   - 由 Advisors 投票决定

**优势**：
- 量化可比较（得票数、还原度）
- 避免主观偏见
- 多次采样降低随机性

---

### 方法 C：畅谈会共识法（RBF 命名法）

**适用场景**：需要多视角讨论、有明确约束条件

**步骤**：

1. **明确约束**
   - 列出所有硬性约束（如 Magic 必须 4 字节）
   - 列出软性偏好（如 ASCII 可读）

2. **多视角发言**
   - Advisor-Claude：概念框架、术语一致性
   - Advisor-Gemini：UX/DX、可读性
   - Auditor：精确性、规范审计
   - 监护人：战略方向

3. **中场整理**
   - 主持人汇总各方观点
   - 识别分歧点和共识点
   - 提出综合方案

4. **收敛投票**
   - 各方表态
   - 达成共识或多数决

**关键经验**：
- 监护人的"普通发言"可以触发立场转变
- "功能描述性"提示往往是突破口
- 不要急于收敛，让分歧充分暴露

#### 可审计产物（4 个模板）

畅谈会法应产出以下可审计产物：

1. **Name Surface Matrix**（名字表面矩阵）
   - 涉及哪些"名字表面"（格式名、Magic、扩展名、代码标识符等）
   - 哪些已被 SSOT 锁定，哪些可变

   | 名字表面 | 当前值 | SSOT 状态 | 可变性 |
   |----------|--------|-----------|--------|
   | 格式名 | — | 未定义 | ✅ 可变 |
   | Magic | `DHD3` | 代码写死 | ⚠️ 需迁移 |
   | 扩展名 | `.elog` | 未使用 | ✅ 可变 |

2. **Constraint Table**（约束表）
   - 每条约束标注 MUST / SHOULD / MAY
   - 写清违反后果

   | 约束 | 级别 | 违反后果 |
   |------|------|----------|
   | ASCII 可读 | SHOULD | hex dump 可读性下降 |
   | 无冲突 | MUST | 与已有格式混淆 |
   | 功能描述性 | SHOULD | 用户难以搜索到 |

3. **Candidate Scorecard**（候选评分卡）
   - 同一组维度对比所有候选

   | 候选 | 自明性 | 唯一性 | 发音 | 综合 |
   |------|--------|--------|------|------|
   | RBF | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ | 8 |
   | SFF | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | 8 |

4. **Decision Record**（决策记录）
   - 一句话结论
   - 理由（引用 Constraint Table 中的关键约束）
   - 兼容策略（如有）

   ```
   决策：采用 RBF (Reversible Binary Framing)
   理由：满足功能描述性(SHOULD)，Magic 可读(SHOULD)
   兼容：文档中保留 ELOG → RBF 映射，代码无 breaking change
   ```

---

### 方法 D：类比锚定法（Analogy Anchoring）

**适用场景**：有明确的"领域前辈"可参照

**原理**：借用领域内已建立的命名风格，降低认知负担

**步骤**：

1. **找前辈**
   - 识别领域内广泛使用的项目/概念
   - 确认其命名风格被目标用户群熟悉

2. **分析命名风格**
   - 前缀/后缀模式（如 Git 的 `Index`、`HEAD`、`Branch`）
   - 隐喻系统（如 Git 的"时间线"隐喻）
   - 术语密度（单词数、缩写程度）

3. **同风格构造**
   - 用相同的模式命名新概念
   - 验证：用户是否能从前辈经验迁移理解？

**示例**：
- `VersionIndex` 借用 Git 的 `Index`（暂存区的索引概念）
- `HEAD` 借用 Git 的 `HEAD`（当前版本指针）

**优势**：
- 用户学习成本低
- 命名有"出处"，容易解释

**风险**：
- 若前辈选择不当，会引入错误隐喻
- 过度依赖可能限制创新表达

---

### 方法 E：反向排斥法（Negative Selection）

**适用场景**："不要什么"比"要什么"更清晰

**原理**：先排除明确不要的，再在幸存者中选择

**步骤**：

1. **列排斥条件**
   - 硬排斥：绝对不能接受的特征
   - 软排斥：尽量避免的特征

   | 排斥条件 | 级别 | 示例 |
   |----------|------|------|
   | 已被占用 | 硬 | "Log" 太泛用 |
   | 负面联想 | 硬 | "Dump" 有贬义 |
   | 难以发音 | 软 | "Xfrm" 缩写过度 |

2. **过滤候选**
   - 用排斥条件快速排除
   - 通常能排除 80% 候选

3. **在幸存者中选择**
   - 对剩余候选应用正向评价
   - 或直接选择"最不差"的

**优势**：
- 快速收敛，避免完美主义陷阱
- 决策过程可解释（"排除了什么，因为什么"）
- 适合时间紧迫的场景

**示例**：
- RBF 命名时排除了 "Log"（太泛）、"Symmetric"（用户不会搜）
- 幸存者中 "Reversible" 最能描述功能特性

---

## 检查清单

在确定名字前，逐项检查：

### 语义层面
- [ ] 名字能让目标用户猜出大致含义？
- [ ] 用 GitHub 搜索测试：会被目标关键词命中？
- [ ] 无负面联想或歧义？

### 技术层面
- [ ] 无已知命名冲突？
- [ ] 符合使用场景的约束（长度、字符集等）？
- [ ] 适合作为代码标识符（如果需要）？

### 实用层面
- [ ] 易于发音和拼写？
- [ ] 易于记忆？
- [ ] 未来演进空间（如版本后缀）？

---

## 案例库

### 案例 1：Atelia（项目名）

| 阶段 | 内容 |
|------|------|
| 核心概念 | Autonomous, Thinking, Eternal, Learning, Introspective, Agents |
| 方法 | 全排列淘汰法 |
| 过程 | 多轮 LLM 生成 → 过滤已存在 → 发音筛选 → 均衡选择 |
| 结果 | Atelia（语义和读音较好的平衡选择）|

### 案例 2：StateJournal（组件名）

| 阶段 | 内容 |
|------|------|
| 描述 | 状态持久化日志，支持版本链、增量序列化 |
| 方法 | Cycle Loss 采样法 |
| 阶段一 | 多次采样生成候选，按得票选 Top K |
| 阶段二 | 多次采样还原意义，选还原度高的 |
| 阶段三 | 3 位 Advisors 投票，StateJournal 胜出 |

### 案例 3：RBF（格式名）

| 阶段 | 内容 |
|------|------|
| 原名 | ELOG (Extensible Log Framing) — 后追溯性赋义，不准确 |
| 方法 | 畅谈会共识法 |
| 约束 | 功能描述性、Magic 可读、统一（移除双 Magic）|
| 关键转折 | 监护人提示"功能描述性 > 实现特征性" |
| 结果 | RBF (Reversible Binary Framing)，Magic `RBF1` |
| 畅谈记录 | [2025-12-22-elog-naming.md](../meeting/2025-12-22-elog-naming.md) |
| 遗留 | 代码标识符命名待定（Framing 不像名词）|

---

## 变更日志

| 日期 | 变更 |
|------|------|
| 2025-12-22 | 融入畅谈会共识：统一视角、适用边界框架、类比锚定法、反向排斥法、4 个可审计产物模板 |
| 2025-12-22 | 创建文档，整合三种命名方法论 |
