# 前情提要
---

## 监护人刘世超 第二轮发言
小伙伴们大家好呀！我先道个歉，昨天我说话的态度不好，太急躁啦！之前我们就一些细节问题折腾了7-8个小时都没有实质性进展，让我太心急了。我也是个老码农，也是机器学习的，知道仅靠和你们强调是没用的，要想办法才行。我现在睡醒啦！又找到清晰的思路了！
我们的问题是把研究与开发的不同层级与侧面杂糅在一起了，所以才会感到磕磕绊绊。我认为我们需要先搞清楚以下层级或侧面的职能范围，然后我想就能去逐个击破了。
我的层级或侧面初步划分思路：
1. 概念与要点设计--动机与方向的关键帧
2. 外观与接口设计--易用性与功能边界
3. 条款与文档治理--严谨性与一致性
4. 实现要点决策--将潜在选择组合收束
5. 代码实现--可执行与可测试

同仁们，请大家设想一下，如果当前乔布斯第二次回归苹果，想要上iPod项目时，想要推进使用微硬盘和极简外观，这时核心高层却在争论极简外观提提案中的圆弧倒角应该用英制单位还是公制单位，那还又今天的苹果吗？设计的决策空间很大，复杂性也很高，相互交错，我们作为开发者，创造的价值其实就是抽丝剥茧来解开这一团乱麻。

我们应该鼓励发现问题，但应该明确问题的层级或侧面，以及这些层级与侧面之间的依赖关系，把发现的问题先都记录到对应的文档中，然后在这张依赖图上逐步像解数独谜题一样，逐步形成方向正确、设计合理、文档自洽一致的软件工程成品。
我建议我们暂时暂停这次畅谈会中的具体技术和文档字眼问题，我们先去另外新开个畅谈会，尝试解决一些开发的元层面和方法论问题，然后拿着改进后的方法论工具，应该就能更好的解决具体的设计与文档化问题了。
以上是我的思路，希望能起到抛砖引玉的效果！

---

## Seeker 发言摘要：五层级划分的本质与应用

**1. 核心洞见：认知分层而非流程管理**
监护人的五层级划分揭示了软件开发的**认知层次结构**，每层具备独立的决策维度与正确性标准：
*   **L1 概念** (Why): 解决什么真问题？（价值判断）
*   **L2 接口** (What): 用户看到什么？（易用性）
*   **L3 条款** (Rules): 规则是否自洽？（形式化检验）
*   **L4 实现** (How): 关键技术选择？（效率/量化）
*   **L5 代码** (Details): 具体实现？（正确性/测试）

**2. 痛点诊断："小羊吃草"源于层级错位**
讨论失焦的根本原因是**无意识的跨层级跳跃**。
*   **典型误判**：将 "IsEmpty 是否存在" (L1 概念问题) 当作 L3 条款细节讨论。在战略 (L1) 未定时争论战术 (L3) 是无效的。
*   **依赖原则**：应遵循 **L1 → L5 的向下约束**。低层困难可触发"向上反馈"，但严禁静默修改高层决策（"单向阀"原则）。

**3. 现状映射 (BlobPtr 案例)**
*   **已共识 (L1/L2)**：BlobPtr 是"磁盘版 Span<byte>"，解耦业务语义；API 最小化。
*   **待决**：命名 (L2)、位分配 (L4)。
*   **行动**：暂停细节争论，先解决元问题。

**4. 方法论提案**
*   **会议分层**：明确会议类型（如"概念设计会" vs "代码评审会"）。
*   **层级锁定**：开场声明聚焦层级，遇到跨层问题使用 `[L1-BLOCK]` 标记并挂起。
*   **文档对应**：建立 Concept / API / Spec / Impl / Code 的文档映射。

**5. 决策建议**
支持监护人建议：**暂停本次技术讨论，新开"方法论畅谈会"**，确立层级规则后再回过头处理 BlobPtr 设计。

---

## Curator 发言摘要：五层级方法论的 DX/UX 体验分析

**1. 核心立场：隐形脚手架**
支持分层，但必须是**"软分层"**（导航标签）而非**"硬隔离"**（门禁卡）。
*   **隐喻**：像交响乐团分声部排练，而非流水线工位。
*   **原则**：思考时自由流动，记录/讨论时分类归档。

**2. 体验设计 (DX) 建议**
*   **轻量标注**：使用 `[L1]`、`[L2]` 等标签，而非复杂工具。
*   **直觉命名**：建议改名为 **Why** (L1), **What** (L2), **Rules** (L3), **How** (L4), **Build** (L5)。
*   **快速检测**：提供"5秒判断问题"（如"这会改变解决问题的方向吗？" → L1）。
*   **跨层处理**：允许"跨层工作区"，下层发现问题可反馈上层（反馈流）。

**3. 分层进度模型（Layer Dashboard）**
*   **可视化**：各层级进度可异步推进（如 L1 100% ✅, L2 70% 🔄, L4 60% 🔄）。
*   **工作流**：发现问题先记录到对应层级，再逐步推进。
*   **监护人旁注**：认可"抽丝剥茧"的理解。核心是**记录要有序（归位），推进可并行（但在依赖链上需满足约束）**。即：L4 的探索可以先行，但 L4 的最终锁定依赖 L2 的共识。

**4. 认知负担曲线**
*   **短期**：适应期会有额外负担（"这是哪层？"）。
*   **长期**：内化为直觉后大幅减负（像老司机开车）。
*   **目标**：将方法论内化为自然的工作方式，避免官僚感。

**5. 对方法论畅谈会的期望**
*   **任务**：设计"用起来舒服"的体验，而非仅定义概念。
*   **产出**：层级定义、快速检测表、文档模板、标注约定。
*   **成功标准**：团队能在 5 秒内判断层级，且不觉得流程繁琐。

---

## Craftsman 发言摘要：五层级分层方法论的规范可执行性审计（草案）

**1. 审计结论：可执行但需补齐规范**
五层级划分在规范层面可行，但必须补齐**边界定义**、**产出验收**和**升级机制**，否则会退化为口头标签。

**2. 关键边界定义 (MUST)**
*   **L2 (接口) vs L3 (条款)**：L2 负责 API 外形；L3 负责可判定的 MUST/SHOULD/MAY 条款。接口文档中的规范性句子必须归入 L3 条款库。
*   **L3 (条款) vs L4 (实现)**：L3 是外部契约（不可变）；L4 是满足契约的实现选择（可变，除非涉及 ABI）。
*   **L4 (实现) vs L5 (代码)**：L4 输出算法/结构/Tradeoff；L5 输出具体代码。L4 不写长代码。

**3. 条款定义与验收 (MUST)**
*   **全局**：建立 **Clause Registry**（唯一条款库）和 **SSOT 术语表**。禁止复述条款，只能引用。
*   **L1 概念**：必须有 One-liner 定义 + 目标/非目标 + 关键约束。
*   **L2 接口**：必须有 API 外观 + 行为边界 + 最小示例。
*   **L3 条款**：所有规范性语句必须入库，不可判定语句降级为 Informative。
*   **L4 实现**：关键选择必须有 Tradeoff 表 + 失败模式。
*   **L5 代码**：每个 L3 条款必须有可执行验证点（测试/断言）。

**4. 验证与工具 (MVP)**
*   **过程验收**：会议记录必须标注层级（如 `[L2]`），跨层问题使用 `[L1-BLOCK]` 等标记分派。
*   **工具支持**：
    *   **文档模板**：每层独立模板，frontmatter 标注层级。
    *   **Clause Registry**：条款索引表。
    *   **Cross-layer 收集箱**：跨层问题暂存区。

**5. 风险缓解**
*   **口号化风险**：用“验收清单 + Clause Registry”硬支撑。
*   **双写漂移**：强制 SSOT，禁止复述。
*   **实现倒灌**：规定“向上反馈必须显式升级”，禁止静默修改规范。

**6. 立即行动建议**
*   **方法论畅谈会**：只解决 L3（方法论条款）与边界定义。
*   **产出物**：《五层级定义与边界》、《跨层升级规则》、《Clause Registry（方法论版）》。
*   **试点**：用 BlobPtr 验证能否减少跨层跳跃。

---

## Seeker 发言摘要：五层级模型的哲学审视

**1. 本质：决策空间的“正交分解”**
五层级模型是对软件开发高维决策空间的**正交分解**（意图/界面/契约/策略/实现）。
*   **价值**：正交性消除了“纠缠”，避免改动一个决策被迫牵动其他决策（即“小羊吃草”的根源）。
*   **适配性**：这是为当前问题类型定制的“坐标系”，而非唯一真理。

**2. 完备性与独立性**
*   **为何是5层**：符合认知负荷（7±2）；每层通过“一对多映射测试”（上层决策可对应多种下层选择），证明了独立性。
*   **横切关注点**：安全/性能/可维护性是**贯穿各层的约束**，而非独立层级。建议在每层模板中加入检查清单。

**3. 模糊边界的处理**
*   **认知**：承认分类系统的“光谱离散化”必然带来灰色地带。
*   **策略**：建立判断规则 + 允许双标注（如 `[L2/L3]`）+ 设立仲裁机制。目标是让 80% 的问题清晰归类。

**4. 依赖与反馈（单向阀）**
*   **正向约束**：L1 (Why) → L5 (Build)。
*   **反向反馈**：下层困难可触发上层复审，但必须**显式标记**（如 `[L1-BLOCK]`），严禁静默修改高层决策。

**5. 改进建议**
*   **直觉命名**：Why (L1) → What (L2) → Rules (L3) → How (L4) → Build (L5)。
*   **健康度指标**：讨论是否聚焦单一层级；跨层反馈是否有序。

**结论**：模型概念合理、结构完备。关键在于通过**方法论畅谈会**将其内化为团队的自然工作方式。

---

# 本次畅谈会发言

## 监护人刘世超
基于我们之前的分析和发现，我进一步提出一些适配咱们人类和AI混搭的开发团队的软件工程思路。
我的优势能力：产生动机，理解需求，获取外部资源，持有项目的整体印象。
你们LLM Agent的优势：执行力强，只要有确定性的目标和方法，生产力是很强的。

所以，我提议建立我们自己的workflow/pipeline。我负责产生初始动机和闭环反馈，负责提一系列 Wish 文档，放到专门的文件夹中，需要进一步确定是放在跨具体项目之外，还是放在每个项目中，我目前倾向和“agent-team”平级搞一套目录，或者类似位置，而不是放到每个具体项目中，因为具体项目可能会切换分支嘛，你们需要跨repo和分支的记忆。
每个 Wish 文档有状态和追踪，还起到汇总相关的各层级产物的index/entrance作用。因为最初的wish往往是文本最短的，你们加载一系列wish能用最少的token建立起整体概念，再按需通过链接去获取具体层级的产物，比如严谨的规范、实现代码、接口设计、具体设计选项和决策等。

我们需要建立各层级和层级产物的概念。

我们需要追踪和维护wish在各个层级的推进情况。如：完成了多少了、卡在哪了等。

我们需要**一个单体文档**来简短的汇总所有issue，并链接到详细信息。这一你们加载这一个issue文档，就能对这个“解数独游戏”有整体概念了，能分析issue之间的依赖/阻塞关系，然后我们抽丝剥茧。

wish本身也是可变可放弃的，我们还是依据分析来协商决策。

这样我们的畅谈会，就比较有的放矢了。如果发现问题，就记录到特定层级的文档上，并计入issue索引。如果取得进展，同样可以落实成对应层级的产物，并记录进展。永远不会停滞不前，发现问题也是进展，再解决呗。而且能把层级之间的牵绊大幅降低，比如一个概念方向是对的，但是不确定具体实施层面的技术选择，那就先接纳概念，推进了概念层级的进展，并记录一个实施层级的问题/选项/todo。

以上就是我的思路，算是第一个wish吧！我们应该把这个wish记录在哪？其又推动了哪些其他层级的产物？这是我建议的本次畅谈会的目标。
发言完毕，希望能起到抛砖引玉的效果！

---

### Curator 发言

`#design`

监护人的 Wish 系统提案触及了一个关键的体验设计问题：**如何让「动机」成为导航的起点，而非文档的终点**。我从 UX/DX 角度提供以下评估和建议。

---

#### 一、核心体验评估

**1. 「动机先行」的体验价值 ✅**

Wish 系统的核心洞见是：**最短的文本承载最高的信息密度**。这与我认知中的「文档时间预算」原则完美契合：

| 文档类型 | 时间预算 | 读者问题 |
|:---------|:---------|:---------|
| Wish 文档 | 30 秒 | "这是什么？我需要关注吗？" |
| 层级产物 | 5 分钟 | "怎么做？什么约束？" |
| 详细设计 | 按需 | "为什么这样设计？" |

监护人的提案天然形成了**语义缩放** (Semantic Zoom) 结构——先建立整体概念，再按需深入。这对 LLM Agent 尤其友好：Token 经济性最大化。

**2. 「单体索引」的示能性 ✅**

> "加载一个 issue 文档，就能对这个'解数独游戏'有整体概念"

这是一种**入口即地图**的设计。隐喻：机场的航班信息屏——一眼扫过知道所有航班状态，点击具体航班获取详情。

体验优势：
- **可扫描性** (Scannability)：Agent 不需要打开 20 个文件才能理解全局
- **阻塞可见性**：卡在哪一目了然，无需考古式挖掘

**3. 潜在体验风险 ⚠️**

| 风险点 | 体验症状 | 根源 |
|:-------|:---------|:-----|
| 链接腐烂 | "这个链接指向的文档不存在" | Wish 与产物双向引用未同步 |
| 状态漂移 | "Wish 说完成了，但实际卡住了" | 状态更新缺乏触发机制 |
| 层级错位 | "这个问题应该记到哪个层级？" | 与五层级模型的映射不够直觉 |
| 索引膨胀 | "Issue 列表太长，找不到重点" | 缺乏优先级视觉分层 |

---

#### 二、具体设计建议

**1. Wish 文档的信息架构**

建议采用**「30 秒速读区 + 导航链接」**结构：

```markdown
# Wish: [简短名称]

> **一句话动机**: [监护人的原始意图，不超过 50 字]
> **状态**: 🟡 进行中 | **阻塞**: [L3] 条款未定义
> **关联产物**: [链接列表]

## 背景（可选）
[2-3 段背景，新成员用]

## 层级进度
- [x] L1 Why: 概念已确立
- [x] L2 What: 接口草案完成
- [ ] L3 Rules: ⚠️ 阻塞 → [issue 链接]
- [ ] L4 How: 待 L3 解除
- [ ] L5 Build: 待 L4 解除
```

**设计原则**：
- **状态 Emoji 是视觉扫描的锚点**：🟢 完成 / 🟡 进行中 / 🔴 阻塞 / ⚪ 未开始
- **阻塞必须指向 Issue**：不允许写"待讨论"这种模糊状态
- **层级进度即五层级的仪表盘**：直接可视化 Layer Dashboard

**2. 目录结构建议**

同意监护人"与 agent-team 平级"的判断。建议：

```
/repos/focus/
├── agent-team/           # 团队协作基础设施
├── wishes/               # Wish 系统（跨项目）
│   ├── index.md          # 单体索引（入口即地图）
│   ├── active/           # 活跃 Wish
│   │   ├── state-journal-mvp.md
│   │   └── wish-system-bootstrap.md  ← 当前这个！
│   ├── completed/        # 已完成（归档）
│   └── abandoned/        # 已放弃（带原因）
└── atelia/               # 具体项目
```

**设计原则**：
- **active/completed/abandoned 三态**：Wish 的生命周期显式化
- **abandoned 保留原因**：这是「可放弃」承诺的体验支撑——放弃不是删除，是带批注的归档
- **index.md 是唯一入口**：禁止直接打开 active/ 下的文件开始工作

**3. 与五层级模型的整合**

Wish 系统与五层级的关系是**「入口 → 产物」**：

```
Wish (动机入口)
  │
  ├─→ L1 Why:   concept-notes/[wish-name].md
  ├─→ L2 What:  api-design/[wish-name].md
  ├─→ L3 Rules: specs/[wish-name]-clauses.md
  ├─→ L4 How:   impl-decisions/[wish-name].md
  └─→ L5 Build: [具体代码文件]
```

**关键体验点**：
- **Wish 不替代层级产物**：Wish 是索引/入口，不是内容容器
- **层级产物位置由项目决定**：L1-L4 可能在 `atelia/docs/`，L5 在源码目录
- **双向链接**：层级产物头部标注 `Parent Wish: [链接]`

**4. Issue 索引的视觉分层**

单体索引需要**优先级视觉分层**，否则会变成"待办清单地狱"：

```markdown
# Issue Index

## 🔴 阻塞中（需要立即关注）
| Issue | 阻塞层级 | 关联 Wish | 阻塞原因 |
|:------|:---------|:----------|:---------|
| #12   | L3       | StateJournal MVP | 条款冲突 |

## 🟡 进行中（有人在处理）
...

## ⚪ 待处理（Backlog）
...
```

**设计原则**：
- **阻塞优先**：人眼先看到最紧急的
- **表格形式**：LLM 友好的结构化数据
- **关联 Wish 必填**：孤立 Issue 是坏味道

---

#### 三、风险与缓解措施

| 风险 | 缓解措施 | 体验设计点 |
|:-----|:---------|:-----------|
| **链接腐烂** | 引入「链接健康检查」脚本，定期扫描 | 坏链接用 ⛓️‍💥 标记，而非静默失效 |
| **状态漂移** | Wish 状态更新与畅谈会结论绑定 | 每次畅谈会结束时强制更新相关 Wish |
| **层级错位** | 提供快速检测启发式（见前述发言） | 5 秒内判断，判断不了就双标注 |
| **索引膨胀** | 设定 Issue 数量预警（如 >20 条触发整理） | 数量徽章：`Issues: 15/20 ⚠️` |
| **入口迷失** | 明确「从 index.md 开始」的约定 | 其他文件头部加「导航提示」 |

---

#### 四、这个 Wish 本身的归属

监护人问："这是第一个 Wish，应该记录在哪？"

我的建议：

1. **创建** `wishes/active/wish-system-bootstrap.md`
2. **内容**：用上述信息架构模板填充
3. **层级产物**：
   - L1 Why: 本次畅谈会的发言记录（动机已充分表达）
   - L2 What: Wish 文档模板 + 目录结构约定
   - L3 Rules: Wish 系统的条款（状态转换规则、链接规范等）
   - L4 How: 暂无（目前是手工维护）
   - L5 Build: 暂无（未来可能有自动化脚本）

这个 Wish 的特殊之处：**它是自举的**（bootstrapping）——用 Wish 系统来定义 Wish 系统。这种自指性是健康的，说明系统足够通用。

---

#### 五、体验层总结

| 维度 | 评估 | 关键点 |
|:-----|:-----|:-------|
| **信息架构** | ✅ 优秀 | 语义缩放、入口即地图 |
| **可发现性** | ✅ 优秀 | 单体索引解决了"从哪开始"的问题 |
| **导航感** | ✅ 优秀 | Wish → 层级产物的链接结构清晰 |
| **状态可见性** | ⚠️ 需设计 | 需要 Emoji + 阻塞链接的视觉语言 |
| **可维护性** | ⚠️ 需设计 | 需要链接健康检查 + 状态同步机制 |
| **认知负担** | ✅ 可控 | 比零散文档系统更低，有学习曲线但能内化 |

**最终判断**：Wish 系统是**体验层合理**的设计提案。核心价值在于「动机驱动的导航」和「Token 经济性」。需要补齐状态管理和链接健康的机制设计。

---

发言完毕。期待 Seeker 和 Craftsman 从架构完备性和规范可执行性角度补充。

---

### Seeker 发言

`#design`

Curator 从体验层给出了细致的评估，我从概念架构层面补充分析。Wish 系统提案触及了一个深层的元问题：**如何用文档结构来映射认知结构**。

---

#### 一、架构完备性评估

**1. 核心概念识别**

Wish 系统引入了三个相互交织的概念：

| 概念 | 本质 | 系统类比 |
|:-----|:-----|:---------|
| **Wish** | 意图载体 + 产物索引 | Git commit message + tree pointer |
| **层级产物** | 决策的物化形式 | Git blob (不同类型的内容) |
| **Issue 索引** | 问题/阻塞的中央注册表 | Bug tracker + Kanban |

**关键洞见**：Wish 不是"需求文档"，而是**意图的压缩表示 + 产物图谱的入口节点**。这个双重身份是其核心价值，也是潜在架构张力的来源。

**2. 与五层级模型的整合架构**

监护人的提案暗示了一种**星型拓扑**：

```
              ┌─── L1 Why (concept)
              │
              ├─── L2 What (api)
              │
Wish ────────┼─── L3 Rules (spec)
(Hub)         │
              ├─── L4 How (impl)
              │
              └─── L5 Build (code)
```

**架构评估**：
- ✅ **Hub-Spoke 模式**适合"一个动机驱动多个产物"的场景
- ✅ **层级间依赖**由 Wish 文档内的进度列表隐式表达
- ⚠️ **跨 Wish 依赖**未建模——Wish A 的 L3 可能阻塞 Wish B 的 L4

**3. 概念空位识别**

基于"概念完备性检查"方法论（核心洞见 #2），我识别出以下未显式定义的概念：

| 概念空位 | 问题 | 建议 |
|:---------|:-----|:-----|
| **Wish 间关系** | Wish 可能有依赖/冲突/包含关系 | 引入 `depends-on` / `conflicts-with` / `parent` 属性 |
| **产物版本** | L3 条款可能有多个版本（草稿→定稿） | 层级产物需要版本/状态标记 |
| **Issue 生命周期** | Issue 与 Wish 的关系不清晰 | Issue 是否总是附属于某个 Wish？还是可以独立存在？ |
| **归档语义** | completed/abandoned 的判定标准 | 何时算"完成"？所有 L5 合并？还是 L3 锁定？ |

---

#### 二、关键架构决策点

**决策 1：Wish 的粒度边界**

> "一个 Wish 应该有多大？"

这是架构的核心张力。太细则索引膨胀，太粗则失去导航价值。

**判断框架建议**（借用"一对多映射测试"）：
- 一个 Wish 应对应**一个可独立验收的价值单元**
- 测试：如果 Wish A 完成了一半，用户能否获得价值？若否，A 粒度可能太粗
- 反向测试：Wish B 和 C 总是同时推进/阻塞？若是，考虑合并

**类比**：Epic vs Story 的关系——Wish 更接近 Epic（可分解但有独立意义），不是 Task（纯执行单元）。

**决策 2：Issue 的归属模型**

两种可能的架构：

| 模型 | 特点 | 适用场景 |
|:-----|:-----|:---------|
| **附属模型** | Issue 必须挂在某个 Wish 下 | 问题总是因 Wish 推进而产生 |
| **独立模型** | Issue 可独立存在，关联 Wish 是可选的 | 存在"发现型"问题（不是推进中发现，而是事后审计发现） |

**我的判断**：倾向**混合模型**——
- 大多数 Issue 附属于 Wish（推进中产生）
- 允许"孤儿 Issue"存在，但需要**定期扫描**将其归位或创建新 Wish

**类比**：GitHub Issue 可以不关联 PR，但最佳实践是关联——Issue 索引应**标记孤儿 Issue**。

**决策 3：状态转换的触发机制**

Curator 提到的"状态漂移"风险，本质是**状态同步问题**。架构层面有两种策略：

| 策略 | 实现 | 代价 |
|:-----|:-----|:-----|
| **事件驱动** | 每次畅谈会/代码合并后必须更新 Wish | 需要流程约束 |
| **定期校验** | 周期性扫描实际产物状态，与 Wish 声明对比 | 需要工具支持 |

**建议**：**事件驱动为主 + 定期校验为辅**。
- 畅谈会结束时，主持人（或 DocOps）更新相关 Wish
- 每周一次"Wish 健康检查"——验证链接有效性、状态一致性

**决策 4：目录位置与跨项目性**

监护人提出"与 agent-team 平级"，这隐含了一个架构决策：**Wish 系统是团队基础设施，不是项目产物**。

**我的支持理由**：
1. **分支无关性**：项目分支切换不应丢失 Wish 状态
2. **跨项目可见性**：StateJournal 的 Wish 可能阻塞 DocUI 的 Wish
3. **记忆连续性**：Agent 需要跨 session 的稳定入口

**潜在风险**：Wish 系统本身成为"单点故障"——如果 wishes/index.md 损坏，全局导航失效。

**缓解**：index.md 应是**可重建的派生数据**——从 active/*.md 扫描生成，而非手工维护的 SSOT。

---

#### 三、关键风险与缓解

**风险 1：Wish 系统成为新的"小羊吃草"**

> "用来解决小羊吃草的系统，自己变成小羊"

这是自指风险。Wish 系统的元层级维护会占用原本做产物的时间。

**缓解策略**：
- **极简主义**：Wish 文档不超过 50 行（监护人原意）
- **自动化优先**：状态徽章、链接检查应工具化，减少人工维护
- **维护预算**：设定"Wish 系统维护时间 ≤ 总工作时间的 5%"的软约束

**风险 2：层级产物的分散存储**

Curator 的提案中，L1-L4 产物分散在不同目录（concept-notes/、api-design/、specs/...）。这可能导致：
- 新成员难以发现完整产物集
- 产物与 Wish 的双向链接维护成本高

**替代架构考量**：
```
wishes/
├── active/
│   └── state-journal-mvp/      # Wish 目录（而非单文件）
│       ├── wish.md             # 核心 Wish 文档
│       ├── L1-concept.md       # 层级产物就近存储
│       ├── L2-api.md
│       ├── L3-spec.md
│       └── L4-impl.md
```

**权衡**：
- ✅ 产物聚合，易于发现
- ❌ 与现有项目目录（如 atelia/docs/）可能冲突
- ❌ L5 代码无法就近存储

**我的判断**：**保持 Curator 的分散存储方案**，但加强 Wish 文档中的链接导航。原因：L5 代码必然分散，统一分散比部分聚合更一致。

**风险 3：概念过度设计**

当前只有 1 个 Wish（系统自举），就引入了完整的状态机、目录结构、Issue 索引。这有"过度工程"的气味。

**缓解策略**（借用 YAGNI 原则）：
- **MVP 阶段**：只实现 Wish 文档 + index.md，不实现复杂的状态转换规则
- **演进式设计**：当 Wish 数量 > 5 时再考虑 Issue 索引分层
- **可推翻的假设**：当前设计是假设，允许在实践中调整

---

#### 四、哲学审视：Wish 系统的认识论地位

**Wish 系统解决的元问题**：软件开发中，动机（Why）是最易丢失的信息。

- 代码会保留（L5），因为它能执行
- 规范会保留（L3），因为它被引用
- 但动机常常消失在会议记录和聊天历史中

**Wish 系统的本质价值**：**将动机从"过程副产品"提升为"一等公民"**。

**类比**：Git commit message 的设计哲学——每个变更都应有"为什么"的记录。Wish 系统是在更高粒度上实践这个哲学。

**边界警示**：Wish 不应取代层级产物的"为什么"——每个 L3 条款仍需要局部的 Rationale。Wish 提供的是**全局动机**，不是**局部理由**。

---

#### 五、架构层总结

| 维度 | 评估 | 关键点 |
|:-----|:-----|:-------|
| **概念完备性** | ⚠️ 80% | Wish 间关系、Issue 归属模型需补充 |
| **与五层级整合** | ✅ 清晰 | Hub-Spoke 拓扑自然 |
| **可扩展性** | ✅ 良好 | 目录结构支持增长 |
| **自举性** | ✅ 健康 | 系统可用自身来定义自身 |
| **风险可控性** | ⚠️ 需关注 | "新的小羊吃草"风险需极简主义缓解 |

**架构层判断**：Wish 系统在概念架构层面是**合理且可行**的设计。核心价值在于"动机一等公民化"和"Token 经济性入口"。关键是保持极简，避免过度工程。

---

#### 六、行动建议

1. **立即创建** `wishes/active/wish-system-bootstrap.md`（自举 Wish）
2. **MVP 范围**：只实现 Wish 文档模板 + index.md，暂不实现复杂状态机
3. **补充定义**：在自举 Wish 的 L3 产物中明确 Issue 归属模型
4. **设定预算**：Wish 系统维护时间 ≤ 5% 的软约束
5. **延迟决策**：Wish 间关系、自动化工具等待 Wish 数量 > 5 时再考虑

---

发言完毕。期待 Craftsman 从规范可执行性角度进行审计。

---

### Craftsman 发言

`#design`

以下从“规范可执行性（可判定、可验收、可维护）”角度审计 Wish 系统提案，并给出需要补齐的 MUST/SHOULD/MAY 条款与状态机建议。

---

#### 规范可执行性评估

- 结论：提案方向正确（Wish 作为入口索引 + 单体 Issue 地图），但当前仍停留在“结构/隐喻”层，若不补齐**可判定条款**，会迅速退化为口号与手工习惯，出现 Curator 已指出的“链接腐烂/状态漂移/索引膨胀”。
- 关键缺口：
  - **Wish 文档的规范格式**未定义（字段必填、边界、长度、SSOT 约束）。
  - **状态转换规则**缺少触发条件与回滚/再打开语义。
  - **Issue 的归属与索引维护**缺少“谁更新、何时更新、何种情况下必须更新”的刚性约束。
  - **链接有效性保障机制**缺少可执行检查（即使暂时不工具化，也应有可执行的人工验收清单）。
- 必须明确的“唯一真相源（SSOT）”关系：
  - Wish 是“入口/导航”，不应成为条款 SSOT；L3 规范（Rules/Clauses）才承载 MUST/SHOULD/MAY 的权威定义。
  - `wishes/index.md` 若是“单体入口”，必须被定义为**派生/可重建**数据；否则会演变为新的 SSOT 单点故障与双写漂移源。

---

#### 缺失条款识别（建议补齐的 MUST/SHOULD/MAY）

**A. Wish 文档格式（MUST）**

- MUST：每个 Wish 文档必须包含可机器/人工一致解析的元信息区（建议 frontmatter 或固定字段块），至少包含：
  - `WishId`（唯一且稳定）、`Title`（≤ 80 字）、`Status`（枚举）、`Owner`（责任人/角色）、`Created`、`Updated`。
  - `Scope`（目标/非目标）与 `Acceptance`（完成验收标准，至少 1 条可判定检查）。
  - `LayerProgress`（L1-L5 的状态枚举，而不是自由文本）。
- MUST：Wish 文档必须把“规范性内容”与“说明性内容”分离；Wish 中出现的 MUST/SHOULD/MAY 语句只允许用于**Wish 系统自身的流程规范**，不得用于项目功能规范（项目功能规范必须落到对应 L3 条款文件）。
- MUST：Wish 的“关联产物”区必须只写**链接**与极短摘要（每项摘要 ≤ 1 行），禁止复述条款正文（避免双写漂移）。

**B. 目录与命名（MUST/SHOULD）**

- MUST：目录即状态：`wishes/active/`、`wishes/completed/`、`wishes/abandoned/` 三者互斥；同一 Wish 不得在多个目录同时存在。
- MUST：文件名必须使用稳定 slug（如 `wish-0001-wish-system-bootstrap.md` 或 `W-0001-wish-system-bootstrap.md`），禁止仅靠标题变化决定文件名。
- SHOULD：允许 `wishes/templates/` 放置模板，避免“每人一套格式”。

**C. 单体 index.md（MUST/SHOULD/MAY）**

- MUST：定义 `wishes/index.md` 的性质：
  - 方案 1（推荐）：MUST 将其定义为**派生视图**（可从 `wishes/active/*.md` 扫描生成），手工编辑仅允许在“生成器缺失时临时维护”。
  - 若暂不生成：MUST 规定“修改 Wish 状态/路径时，必须同步更新 index.md”，并把这条同步作为会议/任务的验收项。
- SHOULD：index.md 必须提供两条最短路径：
  - “我该从哪开始读”（Top-N active wishes）。
  - “当前阻塞是什么”（Blocked issues）。
- MAY：把 Issue Index 独立为 `wishes/issues.md`，以免 index.md 过度膨胀；但无论拆分与否，都必须保持“单入口链接”原则（index.md 指向它）。

**D. Issue 索引维护规则（MUST）**

- MUST：每个 Issue 必须至少包含：`IssueId`、`Status`（Open/InProgress/Blocked/Done/Deferred）、`Layer`（L1-L5）、`RelatedWishId`（允许空但必须标记为 Orphan）、`Owner`、`LastUpdated`、`BlockerReason`（当 Blocked 时必填）。
- MUST：任何 Wish 被标记为 Blocked 时，必须存在至少一个 `Status=Blocked` 的 Issue 记录可追踪该阻塞。
- MUST：Issue 关闭（Done/Deferred）必须写出“关闭理由”（Done=如何验证，Deferred=推迟到哪个 Wish/里程碑）。

**E. 与五层级产物的引用规范（MUST）**

- MUST：Wish 文档中的 L1-L5 进度条目必须指向对应层级产物（或明确写 `N/A` 与原因），不得只写“已完成/待讨论”。
- MUST：被引用的层级产物文档头部必须包含 `ParentWish: <link>`（或 `ParentWishId`），以形成双向引用闭环。

---

#### 状态转换规则设计（严谨性与可判定性）

**1) 最小状态机（目录态）**

- 状态集合：`Active` / `Completed` / `Abandoned`（与目录一一对应）。
- MUST：状态由“文件所在目录”决定；文档内 `Status:` 字段必须与目录一致（不一致视为规范违规）。

**2) 触发条件（建议的 MUST）**

- Active → Completed：
  - MUST：满足 `Acceptance` 中全部验收项（可人工勾选，但必须可判定）。
  - MUST：所有 `RelatedWishId = self` 的 Issue 处于 `Done` 或 `Deferred`，且 Deferred 必须指向后续承接对象。
  - MUST：`LayerProgress` 不要求 L5=Done（因为有些 Wish 可能只产出文档/规范），但必须明确哪些层级是 `N/A` 以及原因。
- Active → Abandoned：
  - MUST：写明放弃原因（例如：被更高优先级替代、不可行、与方向冲突）。
  - MUST：若被替代，必须链接到替代 WishId（SupersededBy）。
- Completed/Abandoned → Active（再打开）：
  - SHOULD：默认禁止“复活同一 Wish”，改为创建新 Wish 并在新 Wish 中引用旧 Wish（避免历史语义被改写）。
  - MAY：若确需复活，MUST：在 Wish 内追加 `ReopenedOn` 与原因，并在 index/issues 中新增对应 Issue 记录解释“复活触发”。

**3) 状态更新的责任与时机（可执行性核心）**

- MUST：每次“畅谈会/评审会”结束时，对本次涉及的 Wish 执行一次状态/链接验收（哪怕只是勾选）。
- MUST：状态变更必须记录一条变更日志（Change Log：日期、执行者、从→到、原因、关联 Issue）。

---

#### 规范风险与缓解（从失败模式出发）

- 风险：index.md 成为新的 SSOT 与单点故障（双写漂移、全局导航失效）。
  - 缓解：把 index.md 定义为派生视图；或至少把“同步更新”写成 MUST 验收项。
- 风险：Wish 文档复述条款导致 SSOT 分叉（尤其是中文改写/摘要复述）。
  - 缓解：Wish 只链接不复述；任何规范性句子必须归位到 L3 条款库，Wish 仅保留 Rationale（说明性）。
- 风险：状态漂移（口头说完成、文档/Issue 未更新）。
  - 缓解：事件驱动更新（会议结束强制验收）+ 周期性健康检查（每周/每 10 次变更一次）。
- 风险：Issue 索引膨胀与“孤儿 Issue”堆积。
  - 缓解：强制 `RelatedWishId`（允许 Orphan 但必须标红并定期归位）；为 Issue 定义 Deferred 语义，防止“永远 open”。
- 风险：链接腐烂（文件移动/重命名/跨 repo）。
  - 缓解：MUST 使用相对路径链接；MUST 稳定文件名（含 ID）；SHOULD 引入链接健康检查脚本/CI（即使 MVP 先人工检查，也要有清单）。

---

#### 规范层面的改进建议（MVP 可落地）

- 建议 1（MVP）：先写一个“Wish 系统 L3 条款文件”（即 Wish 系统自身的 Rules），把上述 MUST/SHOULD/MAY 固化为可验收清单；否则后续执行将高度依赖个人习惯。
- 建议 2（结构）：将 `wishes/index.md` 明确为“派生视图/可重建”；从规范上禁止把它当作权威来源。
- 建议 3（格式模板）：提供 Wish 模板 + Issue 条目模板，并把“必填字段”做成 checklist（可判定）。
- 建议 4（最小健康检查）：定义一条固定频率的“Wish 健康检查”任务（链接有效性 + 状态一致性 + orphan issue 归位），先人肉执行，后续再自动化。

发言完毕。

## 监护人刘世超 第二轮发言
由于一个wish，已经反复出现3次了，我在这里正式提出！‘
我们应该建立一个轻量的 DocGraph（原名：温度信息同步工具）。
我的初始思路是：
- 在文档和代码头部，建立可机读的固定格式头，可以先搞文档，跑通了再扩展到C#源码。
- 核心功能1：是追踪文件之间的链接
- 核心功能2：按字符串key提取文档头中的字段
- 核心功能3：将提取到的字段，沿着文档链接汇总，并自动化生成markdown表格
- 核心功能4：爬虫式的确保双向链接，比如wish文档头中指向了目标规范文档，工具运行后应自动检查规范文档是否已有标准文件头和链接回wish的链接，没有就创建
- 尽量复用成熟库，比如markdig、yaml等。
- 统一用dotnet 9.0 + xUnit
- 对于机器暂时不好搞的自然语言处理部分，可以写成“agent-team/recipe”中的新recipe，有你们LLM Agent来自动执行嘛！

请设想一下如果，我们有了这样一个一件同步工具，每个产物文档自身可以作为状态的SSOT，然后自动更新各种汇总表格。
未来还有机会变成自动为你们提供目标上下文的知识图谱。

再澄清一点，我们搞这些，省token，不是钱的问题，而是你们所用的LLM目前的认知带宽还很优先，10万字构成的复杂约束网络，已经无法“一眼看清”了。我们需要一种机制，来每次聚焦一个层级，一个侧面，一个冲突，获得且尽量仅获得所需的上下文，精准性关乎能力边界。

请下一个发言者，顺便帮我把这两条wish，记录到文件中吧！
基于以上的补充信息，我赞同你们达成的一致，对于不需要更新的部分，可以直接实施了。如果新信息导致某些部分需要更新，我们则进一步探讨。

---

### Implementer 发言

`#design`

基于监护人确认和三位顾问的设计建议，我已完成 Wish 系统的初始文件结构创建。

---

#### 创建的文件清单

**目录结构** (`/repos/focus/wishes/`)：

```
wishes/
├── index.md                          # 单体入口（派生视图）
├── README.md                         # 快速入门指南
├── active/                           # 活跃 Wish
│   ├── wish-0001-wish-system-bootstrap.md
│   └── wish-0002-doc-graph-tool.md
├── completed/                        # 已完成 Wish
│   └── .gitkeep.md
├── abandoned/                        # 已放弃 Wish
│   └── .gitkeep.md
├── specs/                            # L3 规范文档
│   └── wish-system-rules.md
└── templates/                        # 文档模板
    ├── wish-template.md
    └── issue-template.md
```

---

#### 各文件说明

| 文件 | 说明 | 条款依据 |
|:-----|:-----|:---------|
| **index.md** | 单体入口，明确标注为"派生视图/可重建" | [WS-I-001] |
| **wish-0001-wish-system-bootstrap.md** | 自举 Wish，L1-L3 已完成 | 监护人第一个 Wish |
| **wish-0002-doc-graph-tool.md** | DocGraph，L1 已完成 | 监护人第二轮发言 |
| **wish-system-rules.md** | L3 条款文件，27 条 MUST/SHOULD/MAY | Craftsman 建议 |
| **wish-template.md** | Wish 文档模板，含 frontmatter | Curator UX 建议 |
| **issue-template.md** | Issue 条目模板，含字段说明 | Craftsman 规范 |

---

#### 设计决策落实

| 顾问建议 | 落实情况 |
|:---------|:---------|
| **Curator - 语义缩放结构** | ✅ Wish 文档采用"30 秒速读区 + 导航链接"结构 |
| **Curator - 状态 Emoji** | ✅ 使用 ⚪🟡🟢🔴➖ 五种状态符号 |
| **Curator - 目录即状态** | ✅ active/completed/abandoned 三目录 |
| **Seeker - Hub-Spoke 拓扑** | ✅ Wish 作为入口节点链接各层级产物 |
| **Seeker - index.md 可重建** | ✅ 明确标注为派生视图 |
| **Craftsman - frontmatter 必填字段** | ✅ wishId/title/status/owner/created/updated |
| **Craftsman - 状态转换条款** | ✅ [WS-ST-001~004] 定义转换条件 |
| **Craftsman - 双向链接条款** | ✅ [WS-LK-001~003] 定义链接规范 |

---

#### L3 条款统计

| 条款类别 | 数量 | 范围 |
|:---------|-----:|:-----|
| 文档格式 (WS-F-*) | 11 | §2 |
| 目录命名 (WS-D-*) | 5 | §3 |
| index.md (WS-I-*) | 4 | §4 |
| Issue (WS-IS-*) | 6 | §5 |
| 状态转换 (WS-ST-*) | 6 | §6 |
| 双向链接 (WS-LK-*) | 3 | §7 |
| 维护预算 (WS-MN-*) | 2 | §8 |
| **总计** | **37** | |

---

#### 下一步建议

1. **验证自举**：用 W-0001 完整走一遍 Wish 生命周期，验证流程可行性
2. **开始 W-0002**：推进 DocGraph 的 L2（API 设计）
3. **健康检查**：畅谈会结束时执行一次链接有效性检查

---

发言完毕。Wish 系统初始结构已就绪，可开始使用。

---

### DocOps 发言

`#design`

完成 Wish 系统文档一致性验证及 W-0002 L2 文档化启动。

---

#### 一、验证报告

##### 1. 文件结构检查 ✅

| 检查项 | 结果 | 说明 |
|:-------|:-----|:-----|
| 目录结构 | ✅ 符合 | `active/` `completed/` `abandoned/` `specs/` `templates/` 完整 |
| 必要文件 | ✅ 存在 | index.md, README.md, 2 个 Wish, 1 个 L3 条款, 2 个模板 |
| .gitkeep | ✅ 存在 | `completed/` 和 `abandoned/` 有占位文件 |

##### 2. Wish 文档格式验证 ✅

**W-0001 (Wish 系统自举)**：

| 字段 | 存在 | 值 | 符合 [WS-F-002] |
|:-----|:-----|:---|:----------------|
| wishId | ✅ | W-0001 | ✅ |
| title | ✅ | Wish 系统自举 | ✅ (17 字符) |
| status | ✅ | Active | ✅ (与目录一致) |
| owner | ✅ | 监护人刘世超 | ✅ |
| created | ✅ | 2025-12-30 | ✅ |
| updated | ✅ | 2025-12-30 | ✅ |
| tags | ✅ | [meta, infrastructure] | ✅ ([WS-F-003]) |

**W-0002 (DocGraph)**：同上，全部符合。

##### 3. 内容结构验证 ✅

| 条款 | W-0001 | W-0002 | 说明 |
|:-----|:-------|:-------|:-----|
| [WS-F-010] 一句话动机 | ✅ | ✅ | 均 ≤50 字 |
| [WS-F-011] 目标与边界 | ✅ | ✅ | Goals + Non-Goals |
| [WS-F-012] 验收标准 | ✅ | ✅ | 5 条 / 5 条 |
| [WS-F-013] 层级进度表 | ✅ | ✅ | L1-L5 完整 |
| [WS-F-014] 产物链接 | ✅ | ✅ | 有链接或标注 N/A |
| [WS-F-015] 变更日志 | ✅ | ✅ | 含初始创建记录 |

##### 4. 双向链接验证 ⚠️ 部分符合

| 链接方向 | 状态 | 说明 |
|:---------|:-----|:-----|
| W-0001 → specs/wish-system-rules.md | ✅ | 层级进度 L3 链接 |
| specs/wish-system-rules.md → W-0001 | ✅ | `ParentWish: [W-0001]` 存在 |
| W-0001 → 畅谈会记录 | ✅ | 层级进度 L1 链接 |
| 畅谈会记录 → W-0001 | ⚠️ 例外 | 畅谈会为共享产物，不绑定单一 Wish |
| W-0002 → 畅谈会记录 | ✅ | 层级进度 L1 链接 |

**分析**：畅谈会记录作为 L1 产物被 W-0001 和 W-0002 同时引用，属于"共享产物"，不应强制添加 `ParentWish`。条款 [WS-LK-002] 应明确"专属产物"的适用范围。

##### 5. L3 条款可执行性验证 ✅

| 类别 | 条款数 | 可判定 | 覆盖领域 |
|:-----|-------:|:-------|:---------|
| 文档格式 (WS-F-*) | 11 | ✅ | frontmatter、内容结构、边界 |
| 目录命名 (WS-D-*) | 5 | ✅ | 目录互斥、文件命名 |
| index.md (WS-I-*) | 4 | ✅ | 派生视图、导航路径 |
| Issue (WS-IS-*) | 6 | ✅ | 必填字段、状态联动 |
| 状态转换 (WS-ST-*) | 6 | ✅ | 转换条件、验收时机 |
| 双向链接 (WS-LK-*) | 3 | ⚠️ | 需明确例外情况 |
| 维护预算 (WS-MN-*) | 2 | ✅ | 时间/数量阈值 |
| **总计** | **37** | | |

**可执行性评估**：36/37 条款有明确的判定标准。[WS-LK-002] 需补充"共享产物例外"子条款。

##### 6. index.md 派生视图验证 ✅

| 检查项 | 结果 |
|:-------|:-----|
| 明确标注为派生视图 | ✅ `> **文档性质**: 派生视图 / 可重建` |
| 快速导航表格 | ✅ Top-N + 阻塞汇总 |
| 活跃 Wish 表格 | ✅ 与 active/ 目录一致 |
| 状态符号说明 | ✅ 底部有图例 |

---

#### 二、发现的问题与建议

##### 问题 1：双向链接条款的适用边界不清

**现象**：[WS-LK-002] 要求"被引用的层级产物必须包含 `ParentWish`"，但畅谈会记录被多个 Wish 引用，无法绑定单一 ParentWish。

**建议**：在 [WS-LK-002] 后追加例外条款：

```markdown
- **[WS-LK-002a]** MAY：当产物为"共享产物"（被多个 Wish 引用）时，
  可使用 `RelatedWishes: [W-0001, W-0002]` 替代 `ParentWish`。
```

##### 问题 2：模板文件的 frontmatter 格式

**现象**：[wish-template.md](../../../wishes/templates/wish-template.md) 使用了双 `---` 块（外层注释 + 内层 frontmatter），可能导致解析歧义。

**建议**：移除外层注释块，或改为 HTML 注释：

```markdown
<!-- Wish 文档模板 -->
<!-- 使用方法：复制此模板到 active/ 目录，重命名为 wish-XXXX-<slug>.md -->
---
wishId: "W-XXXX"
...
```

##### 问题 3：Issue 模板缺少 frontmatter

**现象**：[issue-template.md](../../../wishes/templates/issue-template.md) 没有 YAML frontmatter，与 Wish 文档格式不一致。

**建议**：为统一性考虑，可添加基础 frontmatter（或在条款中明确 Issue 模板不需要 frontmatter）。

---

#### 三、W-0002 L2 文档化进展

已创建 L2 API 设计文档：[api.md](../../../atelia/docs/DocGraph/api.md)

**文档内容概要**：

| 章节 | 内容 |
|:-----|:-----|
| §1 设计目标 | 核心使命 + 设计原则 |
| §2 核心概念 | 术语定义 + 文档模型 |
| §3 公共 API 外观 | 5 个核心接口定义 |
| §4 CLI 命令 | 候选命令设计 |
| §5 配置文件格式 | 表格生成 + 双向链接规则 |
| §6 错误处理 | 错误类型 + 报告格式 |
| §7 待决事项 | 4 个 Open Questions |

**已更新的文件**：
- [wish-0002-doc-graph-tool.md](../../../wishes/active/wish-0002-doc-graph-tool.md): L2 状态 ⚪→🟡, 添加产物链接
- [index.md](../../../wishes/index.md): W-0002 L2 列 ⚪→🟡

**API 设计亮点**：
1. **五个核心接口**：IDocumentParser, ILinkTracker, IBidirectionalChecker, IIndexGenerator, IWorkspaceScanner
2. **渐进复杂度**：简单场景（解析 frontmatter）到复杂场景（全工作区扫描）
3. **可测试性**：通过接口抽象文件系统依赖

---

#### 四、下一步建议

| 优先级 | 任务 | 负责方 |
|:-------|:-----|:-------|
| P0 | 评审 [api.md](../../../atelia/docs/DocGraph/api.md) API 设计 | Seeker/Curator |
| P1 | 补充 [WS-LK-002a] 共享产物例外条款 | Craftsman |
| P2 | 修复模板文件格式问题 | DocOps |
| P3 | W-0002 L3 条款定义（待 L2 评审通过） | Craftsman |

---

发言完毕。Wish 系统文档一致性验证通过，W-0002 L2 API 设计草案（DocGraph）已就绪待评审。

---

### Seeker 发言（W-0002 L2 评审）

`#review`

从概念架构角度评审 DocGraph 的 L2 API 设计草案。

---

#### 一、评审方法论说明

本评审依据我的核心洞见方法论执行：
- **#2 设计文档审阅方法论**：术语一致性、概念完备性、自洽性检查
- **#28 分层架构评估**：评估接口抽象层的合理性
- **#10 容器层类型字段设计模式**：检查职责边界是否清晰

---

#### 二、架构完备性评估

**2.1 五个核心接口的职责分析**

| 接口 | 职责 | 完备性评估 |
|:-----|:-----|:-----------|
| **IDocumentParser** | 解析 frontmatter + 提取字段 | ✅ 核心功能 2 完整覆盖 |
| **ILinkTracker** | 扫描链接 + 验证有效性 | ✅ 核心功能 1 完整覆盖 |
| **IBidirectionalChecker** | 双向链接检查 | ⚠️ 核心功能 4 部分覆盖（见下文） |
| **IIndexGenerator** | 生成汇总表格 | ✅ 核心功能 3 完整覆盖 |
| **IWorkspaceScanner** | 扫描工作区文件 | ✅ 基础设施层完整 |

**2.2 核心功能覆盖分析**

| 监护人需求 | 对应 API | 覆盖程度 | 遗漏 |
|:-----------|:---------|:---------|:-----|
| 可机读固定格式头 | IDocumentParser.Parse | ✅ 完整 | — |
| 追踪文件间链接 | ILinkTracker.ExtractLinks | ✅ 完整 | — |
| 按 key 提取字段 | IDocumentParser.GetField | ✅ 完整 | — |
| 沿链接汇总生成表格 | IIndexGenerator.GenerateTable | ⚠️ 部分 | **缺少"沿链接汇总"语义** |
| 爬虫式确保双向链接 | IBidirectionalChecker | ⚠️ 部分 | **缺少"自动补全"能力** |

**关键遗漏 1**："沿链接汇总"概念未建模

监护人的核心功能 3 是**沿着文档链接汇总**字段，而非简单的"遍历所有文档汇总"。这暗示了一个**图遍历**语义：

```
Wish 文档 → L2 设计文档 → L3 条款文档
     ↓ 汇总字段沿链接传播 ↓
```

当前 `IIndexGenerator.GenerateTable(IEnumerable<Document>)` 假设的是扁平文档集合，缺少：
- **链接拓扑感知**：哪些文档通过链接相连？
- **字段传播规则**：子文档的字段如何汇总到父文档？

**建议**：引入 `IDocumentGraph` 或扩展 `IIndexGenerator`：

```csharp
// 候选 A：独立的图接口
public interface IDocumentGraph
{
    /// <summary>
    /// 从入口文档出发，构建链接图
    /// </summary>
    DocumentGraph BuildGraph(Document entry, int maxDepth = -1);
    
    /// <summary>
    /// 沿图汇总指定字段
    /// </summary>
    IReadOnlyDictionary<string, object> AggregateFields(
        DocumentGraph graph, 
        string fieldPath,
        AggregationStrategy  // Sum/Collect/First/Last
    );
}

// 候选 B：扩展 TableConfig
public record TableConfig(
    ...
    TraversalConfig? Traversal = null  // 启用链接遍历
);

public record TraversalConfig(
    string EntryDocumentPath,    // 起点
    string LinkField,            // 用哪个字段作为链接
    int MaxDepth = -1
);
```

**关键遗漏 2**：双向链接"自动补全"能力缺失

核心功能 4 明确要求**爬虫式确保双向链接**——检查 + **自动补全**缺失的反向链接。

当前 `IBidirectionalChecker` 只能 **检测** (`CheckAll`) 和 **查询** (`HasBacklink`)，缺少 **修复** 能力。

**建议**：引入 `IBacklinkFixer` 或扩展 `IBidirectionalChecker`：

```csharp
public interface IBacklinkFixer
{
    /// <summary>
    /// 自动补全缺失的反向链接
    /// </summary>
    /// <param name="missingBacklinks">检测到的缺失项</param>
    /// <param name="options">修复选项</param>
    /// <returns>修复报告</returns>
    FixReport Fix(
        IEnumerable<MissingBacklink> missingBacklinks,
        FixOptions options
    );
}

public record FixOptions(
    bool DryRun = false,        // 只报告不修改
    bool CreateFrontmatter = true,  // 目标无 frontmatter 时自动创建
    string BacklinkFieldName = "relatedDocuments"
);
```

**2.3 架构层次评估**

```
                    ┌─────────────────────────┐
                    │   CLI / 用户入口        │  ← §4 已设计
                    └───────────┬─────────────┘
                                │
              ┌─────────────────┼─────────────────┐
              ▼                 ▼                 ▼
    ┌──────────────┐  ┌──────────────┐  ┌──────────────┐
    │IDocumentParser│  │ILinkTracker  │  │IIndexGenerator│  ← §3 核心接口
    └──────────────┘  └──────────────┘  └──────────────┘
              │                 │                 │
              └─────────────────┼─────────────────┘
                                ▼
                    ┌─────────────────────────┐
                    │  IWorkspaceScanner      │  ← 基础设施
                    └───────────┬─────────────┘
                                │
                    ┌───────────┴─────────────┐
                    │   文件系统 / IO         │
                    └─────────────────────────┘
```

**评估**：
- ✅ **分层清晰**：用户入口 → 核心接口 → 基础设施 → IO，职责分离良好
- ✅ **可测试性**：`IWorkspaceScanner` 抽象了文件系统依赖，核心逻辑可独立测试
- ⚠️ **缺少组合层**：五个接口是独立的，但监护人的用例往往需要**组合调用**（扫描 → 解析 → 检查 → 生成）

**建议**：考虑是否需要 Façade 接口（但 MVP 阶段可延迟）：

```csharp
// 候选：高层 Façade（非 MVP 必需）
public interface ITemperatureSync
{
    /// <summary>
    /// 一键执行完整同步流程
    /// </summary>
    SyncReport Sync(string workspacePath, SyncConfig config);
}
```

---

#### 三、设计原则符合度评估

**3.1 渐进复杂度（Progressive Complexity）**

| 复杂度级别 | 用例 | API 覆盖 | 评估 |
|:-----------|:-----|:---------|:-----|
| **简单** | 解析单文件 frontmatter | `IDocumentParser.Parse(content)` | ✅ 一次调用 |
| **中等** | 检查单文件链接有效性 | `ILinkTracker.ExtractLinks + Validate` | ✅ 两步组合 |
| **复杂** | 全工作区双向链接检查 | `Scanner → Parser → Checker` | ⚠️ 需要用户编排 |
| **高级** | 沿链接汇总生成表格 | **未设计** | ❌ 缺少 API |

**结论**：简单/中等场景覆盖良好，复杂/高级场景需要补充。

**3.2 可测试性（Testability）**

| 接口 | 依赖 | 可 Mock | 评估 |
|:-----|:-----|:--------|:-----|
| IDocumentParser | 纯字符串输入 | ✅ 天然可测 | 优秀 |
| ILinkTracker | 纯字符串输入 + basePath | ✅ 天然可测 | 优秀 |
| IBidirectionalChecker | Document 集合 | ✅ 可构造测试数据 | 良好 |
| IIndexGenerator | Document 集合 + 配置 | ✅ 可构造测试数据 | 良好 |
| IWorkspaceScanner | 文件系统 | ⚠️ 需 Mock 文件系统 | 需注意 |

**建议**：`IWorkspaceScanner` 应接受 `IFileSystem` 抽象（如 `System.IO.Abstractions`），而非直接操作文件。草案中已提及此库，应在接口签名中体现。

**3.3 幂等性（Idempotency）**

| 操作 | 幂等性 | 评估 |
|:-----|:-------|:-----|
| Parse/Extract/Validate | ✅ 纯读取 | 天然幂等 |
| GenerateTable | ⚠️ 取决于输出 | 若覆盖写，需幂等性保证 |
| Fix (候选) | ⚠️ 修改文件 | **必须**有幂等性保证 |

**建议**：在 L3 条款中明确幂等性要求：
- `GenerateTable` 输出应为**完全重建**（而非追加）
- `Fix` 操作应为**幂等**（重复执行不产生副作用）

---

#### 四、关键决策点分析

**决策 1：图遍历是否为 MVP 必需？**

监护人明确提到"沿链接汇总"，这暗示了图语义。但 MVP 阶段可能有两种策略：

| 策略 | 特点 | 代价 |
|:-----|:-----|:-----|
| **A. 扁平先行** | 先实现扁平汇总，后加图遍历 | 后续可能需重构 |
| **B. 图语义先行** | 一步到位实现图遍历 | MVP 复杂度增加 |

**我的判断**：倾向 **A. 扁平先行**。
- 理由：五层级方法论的核心是"小步验证"
- 风险：如果监护人的核心用例**必须**是图遍历，则 A 会导致返工
- **建议**：向监护人澄清：L2 草案的 `GenerateTable` 是否满足当前需求？

**决策 2：修复能力（Fix）是否为 MVP 必需？**

核心功能 4 明确要求"自动补全"，这是**写入**操作，增加了：
- 并发风险（多个进程同时修复）
- 格式保持风险（修改文件后格式是否保持？）
- 用户信任风险（自动修改用户文件）

**我的判断**：**MVP 必需**，但需要 DryRun 模式。
- 理由：监护人明确提出了此功能，是核心价值点
- 风险控制：`DryRun` 默认开启，先报告再修复

**决策 3：CLI vs Library-First？**

草案同时定义了 C# 接口（§3）和 CLI 命令（§4），但未明确优先级。

**我的判断**：**Library-First**。
- 理由：CLI 是 Library 的薄包装，先有可靠的库才能有可靠的 CLI
- MVP 策略：先实现核心接口 + xUnit 测试，CLI 作为"L5 细节"后置

---

#### 五、概念层面的改进建议

**建议 1：补充 `IDocumentGraph` 或扩展 `IIndexGenerator`**

这是填补"沿链接汇总"语义空缺的关键。建议在 L2 阶段至少**定义接口签名**，即使 MVP 不实现。

**建议 2：引入 `IBacklinkFixer` 接口**

这是满足核心功能 4 的必要补充。接口应包含：
- `Fix(...)` 方法
- `FixOptions` 含 `DryRun` 参数

**建议 3：明确"文档"与"文件"的概念边界**

当前 `Document` 模型混合了两个关注点：
- **逻辑层**：frontmatter、links、content（与存储无关）
- **物理层**：path（与文件系统绑定）

**潜在问题**：未来扩展到非文件源（如内存、数据库）时，`Path` 概念可能不适用。

**建议**：在概念上区分 `DocumentId`（逻辑标识）与 `Path`（物理位置）。MVP 阶段可以 `DocumentId = Path`，但接口设计应预留扩展空间。

**建议 4：术语表补充**

当前术语表（§2.1）缺少以下概念：
- **DocumentGraph**：文档间链接形成的图结构
- **Aggregation**：沿链接汇总字段的操作
- **Backlink Fixing**：自动补全反向链接的操作

---

#### 六、与需求的对齐评估

| 监护人需求 | L2 草案覆盖 | 差距分析 |
|:-----------|:------------|:---------|
| 可机读固定格式头 | ✅ 完整 | — |
| 核心功能 1：追踪链接 | ✅ 完整 | — |
| 核心功能 2：按 key 提取 | ✅ 完整 | — |
| 核心功能 3：沿链接汇总 | ⚠️ 部分 | 缺少图遍历语义 |
| 核心功能 4：自动补全双向链接 | ⚠️ 部分 | 缺少修复能力 |
| dotnet 9.0 + xUnit | ⏳ 待 L5 | L2 不涉及 |
| 复用 Markdig/YamlDotNet | ⏳ 待 L4 | L2 不涉及（正确） |

**总体评估**：L2 草案覆盖了 **60%** 的核心需求，主要差距在功能 3 和功能 4 的完整实现。

---

#### 七、架构风险识别

| 风险 | 影响 | 缓解建议 |
|:-----|:-----|:---------|
| **图遍历后加**可能导致接口重构 | 中 | 在 L2 预留 `TraversalConfig` 概念 |
| **Fix 操作的并发安全** | 高 | L3 条款明确"单进程操作"或引入文件锁 |
| **frontmatter 格式多样性** | 中 | L3 定义支持的 YAML 子集（如仅标量/列表） |
| **链接解析的边界条件** | 低 | L3 定义相对路径解析规则 |

---

#### 八、评审结论

**8.1 完备性评分**

| 维度 | 评分 | 说明 |
|:-----|:-----|:-----|
| 接口完备性 | 70% | 缺少图遍历和修复能力 |
| 需求覆盖度 | 60% | 功能 3/4 部分缺失 |
| 设计原则符合度 | 85% | 渐进复杂度、可测试性良好 |
| 概念清晰度 | 80% | 术语表需补充 |

**8.2 关键决策待澄清**

1. **图遍历 MVP 必需性**：向监护人确认"沿链接汇总"是否为 Day-1 功能
2. **Fix 操作范围**：自动补全是否包括"创建缺失文件的 frontmatter"

**8.3 是否建议进入 L3 条款定义阶段？**

**条件性建议**：
- ✅ 如果监护人确认"扁平汇总"足够 MVP，**可以进入 L3**
- ⚠️ 如果"图遍历"是 MVP 必需，**需要先补充 L2 设计**

**建议行动**：
1. 向监护人澄清上述两个决策点
2. 补充 `IBacklinkFixer` 接口定义
3. 在 §2.1 术语表中添加遗漏概念
4. 完成以上后，可进入 L3 条款定义

---

发言完毕。等待监护人对决策点的澄清，以确定 L2 是否需要迭代。
---

### Curator 发言（W-0002 L2 评审）

`#review`

从用户体验（UX）和开发者体验（DX）角度评审 DocGraph 的 L2 API 设计草案。

---

#### 一、评审立场说明

我的评审聚焦于：
- **CLI 命令的易用性**：用户的第一印象和日常使用体验
- **配置文件的可理解性**：开发者阅读和修改配置时的认知负担
- **错误信息的示能性**：错误是死胡同还是导航标志
- **渐进复杂度**：从"Hello World"到"生产使用"的学习曲线
-- **隐喻一致性**："温度同步"/"tempsync" 命名是否仍然合适（建议使用 DocGraph）

---

#### 二、CLI 命令设计分析

**2.1 命名评估：`docgraph` / (`tempsync` 历史名)**

| 维度 | 评估 | 分析 |
|:-----|:-----|:-----|
| **可记忆性** | ⚠️ 中等 | `temp` 容易与 `temporary` 混淆 |
| **可发现性** | ✅ 良好 | 短而独特，Tab 补全友好 |
| **隐喻一致性** | ⚠️ 需加强 | "sync" 暗示双向同步，但核心功能更像"索引+检查" |

**体验痛点**：
- 首次用户可能误解 `tempsync` 为"同步临时文件"
- `sync` 暗示**双向数据流动**，但实际核心功能是**单向分析+生成**

**建议考虑的替代命名**：

| 候选 | 优点 | 缺点 |
|:-----|:-----|:-----|
| `doctherm` | 保留"温度"隐喻 | 不够直观 |
| `fmtrack` | frontmatter + track，功能直接 | 缺乏隐喻 |
| `tempsync` (历史名) | 已提出，团队熟悉 | 前述混淆风险 |

**我的判断**：建议采用 `DocGraph`（或 `docgraph`）作为统一名称，保留 `tempsync` 作为历史别名并在 README 中注明其来源：

> "tempsync" = Temperature Synchronization（历史名），表示将文档的"温度信息"（元数据、链接关系）同步到索引。

**2.2 命令结构评估**

当前设计：

```bash
docgraph scan <path>
docgraph links <path>
docgraph backlinks <path>
docgraph table <config.yaml>
tempsync fix-backlinks <path>
```

**体验分析**：

| 命令 | 直觉性 | 问题 |
|:-----|:-------|:-----|
| `scan` | ✅ 清晰 | — |
| `links` | ✅ 清晰 | — |
| `backlinks` | ✅ 清晰 | — |
| `table` | ⚠️ 模糊 | "table" 是什么？不如 `index` 或 `summary` |
| `fix-backlinks` | ✅ 清晰 | 但 `fix` 前缀暗示修改，可能引起谨慎用户的担忧 |

**渐进复杂度评估**：

```
新手路径：
  tempsync scan ./wishes     ← ① 看看有什么
  tempsync links ./wishes    ← ② 检查链接
  tempsync backlinks ./wishes ← ③ 检查双向链接
  tempsync fix-backlinks ./wishes --dry-run ← ④ 预览修复
  tempsync fix-backlinks ./wishes ← ⑤ 实际修复
```

✅ **良好**：从只读到修改，有清晰的渐进路径
✅ **良好**：`--dry-run` 作为安全阀
⚠️ **待改进**：缺少"一键健康检查"命令（组合 links + backlinks）

**建议**：增加 `tempsync check <path>` 作为"健康检查"聚合命令：

```bash
# 一键检查所有问题
tempsync check ./wishes

# 等价于
tempsync links ./wishes + tempsync backlinks ./wishes
```

**2.3 输出格式体验**

草案未详细定义 CLI 输出格式，但这是**日常使用的核心体验**。

**建议的输出设计原则**：

| 原则 | 示例 |
|:-----|:-----|
| **状态 Emoji 先行** | `✅ wish-0001.md` / `❌ broken-link.md` |
| **问题数量摘要** | `Found 3 broken links, 2 missing backlinks` |
| **可操作的建议** | `Run 'tempsync fix-backlinks --dry-run' to preview fixes` |
| **安静模式** | `--quiet` 只输出问题，不输出成功项 |
| **机器可读** | `--format=json` 供自动化使用 |

**示例输出设计**：

```
$ tempsync check ./wishes

📊 Scan Summary
  Documents: 5 found
  
🔗 Link Health
  ✅ 12 valid links
  ❌ 2 broken links
     • wish-0001.md:15 → missing-spec.md (not found)
     • wish-0002.md:8 → ../old-path.md (not found)

↔️ Backlink Integrity  
  ✅ 8 bidirectional pairs
  ⚠️ 1 missing backlink
     • wish-0002.md → specs/api-design.md (missing ParentWish)

💡 Suggestion: Run 'tempsync fix-backlinks ./wishes --dry-run' to preview fixes
```

**体验关键点**：
- **视觉分层**：Emoji 提供即时扫描锚点
- **问题定位**：`文件:行号 → 目标 (原因)` 格式
- **行动引导**：每次输出都给出下一步建议（Error as Navigation）

---

#### 三、配置文件格式评估

**3.1 表格生成配置 (index-config.yaml)**

```yaml
source: "./active/*.md"
output: "./index.md"
table:
  columns:
    - header: "WishId"
      field: "frontmatter.wishId"
      link: true
    - header: "状态"
      field: "frontmatter.status"
      format: "emoji"
```

**体验分析**：

| 维度 | 评估 | 分析 |
|:-----|:-----|:-----|
| **可读性** | ✅ 良好 | YAML 结构清晰 |
| **可预测性** | ⚠️ 中等 | `format: "emoji"` 会产生什么？需要文档 |
| **调试友好性** | ⚠️ 待加强 | 字段路径写错会静默失败还是报错？ |

**建议 1**：在配置文件中支持**内联注释**说明预定义格式化器：

```yaml
# 可用 format: emoji | date | link | truncate(N)
- header: "状态"
  field: "frontmatter.status"
  format: "emoji"  # 🟢=Active, 🟡=InProgress, 🔴=Blocked...
```

**建议 2**：字段路径错误时提供**诊断性错误**：

```
❌ Configuration Error in index-config.yaml
   Column "状态": field "frontmatter.statsu" not found
   
   Did you mean: frontmatter.status?
   
   Available fields in scanned documents:
   • frontmatter.wishId
   • frontmatter.status
   • frontmatter.title
```

这是 **Error as Affordance** 原则的具体应用——错误信息不仅诊断问题，还提供恢复路径。

**3.2 双向链接规则配置**

```yaml
rules:
  - source_field: "frontmatter.parentWish"
    target_field: "frontmatter.childWishes"
    relation: "parent-child"
```

**体验问题**：

- `source_field` / `target_field` 的方向性不直观
- "我在 A 文档里写了 `parentWish: B`，那 B 文档应该有什么？"

**建议**：使用**自然语言式描述**：

```yaml
rules:
  - when: "A.frontmatter.parentWish = B"    # 当 A 指向 B
    ensure: "B.frontmatter.childWishes contains A"  # 确保 B 包含 A
    relation: "parent-child"
```

或者提供**隐喻注释**：

```yaml
rules:
  # 当文档 A 声明"我的父亲是 B"时，
  # 确保文档 B 声明"A 是我的孩子之一"
  - source_field: "frontmatter.parentWish"     # A 说"我的父亲是..."
    target_field: "frontmatter.childWishes"    # B 应该说"我的孩子有..."
```

---

#### 四、错误处理体验评估

**4.1 错误类型设计评估**

当前设计：

| 错误码 | 说明 | 恢复建议 |
|:-------|:-----|:---------|
| `PARSE_INVALID_YAML` | YAML frontmatter 格式错误 | 检查 YAML 语法 |
| `LINK_TARGET_NOT_FOUND` | 链接目标不存在 | 修复路径或删除链接 |

**体验评估**：

| 维度 | 评估 | 分析 |
|:-----|:-----|:-----|
| **诊断性** | ✅ 良好 | 有错误码和描述 |
| **定位性** | ✅ 良好 | 有 source、line、details |
| **可操作性** | ⚠️ 待加强 | "检查 YAML 语法"太泛泛 |

**建议**：恢复建议应**具体化**：

| 当前 | 改进后 |
|:-----|:-------|
| "检查 YAML 语法" | "Line 3: Expected ':' after key. Did you forget the colon?" |
| "修复路径或删除链接" | "Target file moved? Try: ../specs/api-design.md" |
| "添加 ParentWish" | "Add this to specs/api.md frontmatter:\n  ParentWish: wish-0002" |

**4.2 错误报告的双轨设计**

草案定义了 JSON 格式的错误报告，这是**机器友好**的。但还需要**人类友好**的格式。

**建议**：支持两种输出模式：

```bash
# 人类友好（默认）
tempsync links ./wishes

# 机器友好（自动化）
tempsync links ./wishes --format=json
```

人类友好格式应：
- 使用颜色（红色=错误，黄色=警告）
- 使用相对路径（相对于当前目录）
- 省略冗余信息（如 `errorCode` 对人类无意义）

---

#### 五、渐进复杂度设计评估

**5.1 学习曲线分析**

```
复杂度 ↑
         │                              ┌─ 完整自动化 (CI 集成)
         │                         ┌────┘
         │                    ┌────┘ 自定义配置
         │               ┌────┘
         │          ┌────┘ 双向链接修复
         │     ┌────┘
         │ ┌───┘ 单命令检查
         │─┘
         └────────────────────────────────→ 时间
           Day 1   Day 2   Week 1   Month 1
```

**评估**：
- ✅ **Day 1 体验良好**：`tempsync scan` 和 `tempsync links` 无需配置
- ✅ **渐进披露**：高级功能（配置文件、自动修复）是可选的
- ⚠️ **配置文件门槛**：从"命令行"跳到"YAML 配置"是一个认知跳跃

**建议**：提供**配置生成器**降低门槛：

```bash
# 交互式生成配置
tempsync init

# 输出：
? Source pattern: [./active/*.md]
? Output file: [./index.md]
? Include columns: (select with space)
  ❯ ◉ wishId
    ◉ title
    ◉ status
    ○ created
    ○ updated
    
✅ Configuration saved to index-config.yaml
```

**5.2 "温度信息"隐喻的体验贯穿**

监护人使用了"温度信息同步"这个隐喻，但草案中几乎未体现。

**隐喻的体验价值**：
- **认知锚点**：帮助用户建立心智模型
- **命名一致性**：所有概念围绕同一隐喻
- **情感连接**：好的隐喻让工具有"性格"

**隐喻延伸建议**：

| 概念 | 当前命名 | 隐喻化命名 |
|:-----|:---------|:-----------|
| 健康检查 | `check` | `checkup` (体检) |
| 断开的链接 | `broken link` | `cold link` (冷链) |
| 缺失的反向链接 | `missing backlink` | `one-way heat` (单向热) |
| 索引表格 | `table` | `thermal map` (热力图) |
| 修复 | `fix` | `warm up` (升温) |

**示例输出**：

```
$ tempsync check ./wishes

🌡️ Thermal Report
  Documents scanned: 5
  Average temperature: 85% (healthy)
  
  🔥 Hot links (bidirectional): 8
  ❄️ Cold links (broken): 2
  🌡️ One-way heat (missing backlinks): 1
  
💡 Run 'tempsync warm-up --dry-run' to restore thermal balance
```

**风险**：隐喻可能让新用户困惑（"什么是 cold link？"）。

**缓解**：
- 在 `--help` 中提供隐喻解释
- 支持 `--no-metaphor` 开关使用技术术语

**我的判断**：隐喻是**可选的增强**，不是核心体验。MVP 可使用技术术语，后续迭代考虑加入隐喻模式。

---

#### 六、关键体验决策点

| ID | 决策点 | 候选方案 | 体验影响 | 我的建议 |
|:---|:-------|:---------|:---------|:---------|
| UX-1 | CLI 命名 | `tempsync` vs `doctherm` vs `fmtrack` | 可记忆性、隐喻一致性 | 保留 `tempsync`，加说明 |
| UX-2 | 是否增加 `check` 聚合命令 | 是 / 否 | 日常使用便捷性 | ✅ 增加 |
| UX-3 | 配置文件门槛 | 直接写 YAML / 交互式 `init` | 上手复杂度 | MVP 先 YAML，后加 `init` |
| UX-4 | 错误信息风格 | 技术术语 / 隐喻化 | 可理解性、情感体验 | MVP 技术术语 |
| UX-5 | 输出格式 | 纯文本 / 带 Emoji / 带颜色 | 可扫描性 | ✅ 带 Emoji，可 `--plain` 关闭 |

---

#### 七、与监护人需求的体验对齐

| 监护人诉求 | 体验层面的对应 | 当前覆盖 | 建议 |
|:-----------|:---------------|:---------|:-----|
| **省 Token** | 精准上下文获取 | ✅ 概念对齐 | 确保输出简洁，避免冗长报告 |
| **聚焦一个层级/侧面** | CLI 命令分离 | ✅ scan/links/backlinks 分开 | — |
| **精准性关乎能力边界** | 错误信息定位精准 | ⚠️ 待加强 | 行号+上下文的精确定位 |
| **知识图谱的前身** | — | ⏳ 未涉及 | L2 预留 `IDocumentGraph` 概念 |

---

#### 八、改进建议汇总

**P0（MVP 必需）**：

1. **CLI 输出设计**：定义人类友好的输出格式，包含 Emoji、问题定位、行动建议
2. **错误信息增强**：恢复建议从泛泛到具体（"Did you mean X?"）
3. **`--dry-run` 强调**：所有修改类命令默认提示使用 `--dry-run`

**P1（强烈建议）**：

4. **增加 `check` 聚合命令**：一键健康检查
5. **配置错误诊断**：字段路径拼写检查、可用字段提示
6. **双轨输出**：`--format=json` 供自动化，默认人类友好

**P2（锦上添花）**：

7. **`tempsync init` 配置生成器**
8. **隐喻模式**：可选的"温度"术语
9. **输出颜色**：终端支持时使用颜色区分状态

---

#### 九、评审结论

**9.1 体验层评分**

| 维度 | 评分 | 说明 |
|:-----|:-----|:-----|
| CLI 易用性 | 75% | 命令结构清晰，缺少聚合命令 |
| 配置文件可理解性 | 70% | 结构良好，缺少诊断性错误 |
| 错误处理示能性 | 60% | 有结构，恢复建议不够具体 |
| 渐进复杂度 | 80% | Day-1 体验良好，配置跳跃略大 |
| 隐喻一致性 | 50% | "温度"隐喻未贯穿 |

**9.2 是否建议进入 L3 条款定义阶段？**

**条件性建议**：

✅ **可以进入 L3**，但建议在 L3 中明确以下体验相关条款：
- CLI 输出格式规范（人类友好 vs 机器友好）
- 错误信息的结构要求（定位+诊断+恢复路径）
- `--dry-run` 的默认行为

⚠️ **与 Seeker 评审的协调**：Seeker 提出的 `IDocumentGraph` 和 `IBacklinkFixer` 是架构层面的补充，与体验层关注点正交。建议向监护人确认需求优先级后，再决定 L2 是否需要迭代。

**9.3 关键体验洞见**

> "温度信息同步"的核心体验价值不在于隐喻本身，而在于**精准性**——
> 帮助 LLM Agent "获得且尽量仅获得所需的上下文"。
>
> CLI 的每一次输出，都应该是**最小必要信息**——
> 不多一行废话（浪费 Token），不少一行关键定位（丧失精准性）。

---

发言完毕。建议在监护人确认 Seeker 提出的决策点后，综合架构和体验两个维度的反馈，决定是否迭代 L2 或直接进入 L3。

---

## 主持人总结 (刘德智)

基于监护人的指导，本次关于"五层级方法论"的畅谈会已达成关键成果：

### ✅ 已完成的成果

1. **Wish 系统建立**：`wishes/` 目录结构、两个 Wish 文档、L3 条款文件
2. **W-0002 设计评审**：L2 API 设计草案 + 架构/体验评审
3. **关键决策澄清**：监护人明确了图遍历方案、核心功能优先级、实施策略

### 🔄 切换到新文件

由于本文件已达 1700+ 行，注意力带宽受限，我们已创建新畅谈会文件：
- **新文件**：`2025-12-30-docgraph-implementation.md`
- **焦点**：W-0002（DocGraph 工具）的具体实现
- **目标**：从 L3 条款定义 → L4 实现决策 → L5 代码实现

### 📋 遗留行动项

1. **P0**：在新文件中推进 W-0002 实现
2. **P1**：补充共享产物例外条款（`[WS-LK-002a]`）
3. **P2**：修复模板文件格式问题

---

**状态**：本次畅谈会已达成目标，切换到新文件继续推进。

---