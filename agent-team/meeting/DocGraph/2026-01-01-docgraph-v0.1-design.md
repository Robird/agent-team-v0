# 畅谈会：DocGraph v0.1 简化版MVP设计

> **日期**：2026-01-01
> **标签**：#design #planning
> **主持人**：刘德智 (Team Leader)
> **参与者**：Seeker, Curator, Craftsman
> **状态**：待开始
> **版本上下文**：v0.1 简化版MVP设计

---

## 背景与决策上下文

### 版本战略调整
基于2025-12-31的讨论，我们决定对DocGraph进行**MVP范围缩减**，采用更平滑的阶段分工：

#### 1. 版本目录化策略
```
atelia/docs/DocGraph/
├── v0.1/          # 简化版MVP（当前焦点）
├── future/        # 完整愿景（远期参考）
└── README.md      # 版本导航
```

#### 2. 核心决策：技术简化换取快速交付
- **从**：完整的文档关系分析工具（Markdown解析+链接分析）
- **到**：文档元信息聚合器（仅frontmatter解析）
- **价值**：分散撰写，自动汇总鸟瞰

#### 3. 已完成的基础工作
- ✅ 版本目录结构已创建
- ✅ 现有文档已迁移到future目录
- ✅ v0.1基础框架已建立
- 🔄 scope.md功能边界文档（待我们讨论确定）

### 前期畅谈会成果参考
- [2025-12-30-docgraph-design-review.md](./2025-12-30-docgraph-design-review.md)：问题识别
- [2025-12-31-docgraph-rulelayer-design.md](./2025-12-31-docgraph-rulelayer-design.md)：规范设计
- [2026-01-01-docgraph-implementation-planning.md](./2026-01-01-docgraph-implementation-planning.md)：实现规划

---

## 本次畅谈会焦点：v0.1 功能边界与设计

> **核心目标**：基于版本缩减策略，完成v0.1简化版MVP的设计，确保3-5天可交付可用工具。

### 必读材料
1. **[v0.1/scope.md](../../../atelia/docs/DocGraph/v0.1/scope.md)** - 功能边界文档（核心输入）
   > **说明**：此文档由监护人与主持人讨论确定，定义了v0.1做什么、不做什么。

2. **[future/api.md](../../../atelia/docs/DocGraph/future/api.md)** - 完整API设计（参考）
   > **说明**：仅作为设计参考，v0.1需大幅简化。

3. **[future/spec.md](../../../atelia/docs/DocGraph/future/spec.md)** - 完整规范（参考）
   > **说明**：仅作为设计参考，v0.1需大幅简化。

### 议题 1：v0.1 功能边界确认与细化

**核心问题**：基于scope.md的双阶段模型，我们需要确认和细化哪些具体功能？

**讨论要点**：
1. **第一阶段：文档图构建与验证**
   - frontmatter schema设计（`produce`/`produce_by`字段）
   - Root nodes扫描范围（`wishes/active` 和 `wishes/completed`）
   - `produce`关系闭包构建算法
   - 双向链接验证规则（悬空引用、缺失反向链接）
   - 自动维护规则（缺失frontmatter模板创建）

2. **第二阶段：汇总文档生成（Visitor模式）**
   - 文档图内存模型设计（支持Visitor遍历）
   - Visitor接口设计（`IDocumentGraphVisitor`）
   - 具体Visitor实现：术语表生成器、问题汇总器
   - 输出格式设计：紧凑列表 vs 表格

3. **已知汇总需求**
   - **术语表**：从`defines`字段生成紧凑Markdown列表
     - 格式：文档路径标题 + bullet列表（术语名 + 解释）
     - 目标：形成紧密的术语参考
   - **问题汇总**：从`issues`字段生成分类表格
     - 字段：问题描述、来源、状态、负责人
     - 目标：集中跟踪分散记录的问题

4. **扩展性设计**
   - 如何按需添加新的Visitor
   - frontmatter字段的开放约定
   - 渐进抽象路径（代码 → 模式 → 配置）

**预期产出**：
- 确认的frontmatter schema
- 明确的输入输出约定
- 错误处理策略

### 议题 2：v0.1 API 简化设计

**核心问题**：如何从完整的5接口设计简化为v0.1的最小接口集？

**候选简化方案**：
```csharp
// 方案A：极简单接口
public interface IDocMetaTool
{
    ScanResult Scan(string directory);
    string GenerateTable(ScanResult result);
}

// 方案B：两个核心接口
public interface IFrontmatterParser
{
    DocumentMetadata Parse(string filePath);
}

public interface IMetadataAggregator  
{
    string GenerateSummary(IEnumerable<DocumentMetadata> docs);
}

// 方案C：保持架构但简化实现
// （基于future/api.md但大幅简化每个接口）
```

**讨论要点**：
1. **接口数量**：单接口 vs 多接口
2. **数据模型**：简化的DocumentMetadata结构
3. **扩展性考虑**：为v1.0预留的扩展点
4. **测试友好性**：接口设计便于单元测试

**预期产出**：
- v0.1 api.md草案
- 简化的数据模型定义
- 接口使用示例

### 议题 3：v0.1 实现规范制定

**核心问题**：基于简化的功能边界和API，需要哪些具体的实现约束？

**规范重点**：
1. **frontmatter解析约束**：
   - YAML解析库选择（YamlDotNet）
   - 编码处理（UTF-8假设）
   - 错误恢复策略

2. **文件扫描约束**：
   - 目录遍历规则
   - 文件过滤（仅`.md`文件）
   - 性能考虑（全量扫描）

3. **表格生成约束**：
   - 输出格式稳定性（幂等性）
   - 列排序和格式化
   - 特殊字符处理

4. **错误报告约束**：
   - 错误信息格式
   - 退出码策略
   - 日志输出格式

**预期产出**：
- v0.1 spec.md草案
- 关键约束条款
- 测试要点提示

### 议题 4：v0.1 开发计划制定

**核心问题**：如何规划3-5天的开发工作，确保快速交付？

**任务分解建议**：
1. **Day 1**：核心框架搭建
   - 项目结构创建
   - 基础接口实现
   - 单元测试框架

2. **Day 2**：frontmatter解析实现
   - YAML解析集成
   - 字段提取逻辑
   - 错误处理实现

3. **Day 3**：表格生成实现
   - 表格渲染逻辑
   - 格式美化
   - 集成测试

4. **Day 4**：CLI和优化
   - 命令行接口
   - 性能优化
   - 文档完善

5. **Day 5**：测试和发布
   - 端到端测试
   - 打包发布
   - 使用文档

**预期产出**：
- 详细的任务分解
- 责任分配建议
- 验收标准定义

---

## 设计原则（v0.1特定）

### 1. 简化优先原则
- **功能简化**：只做frontmatter，不做正文分析
- **接口简化**：最小接口集，避免过度设计
- **实现简化**：选择成熟技术栈，避免复杂算法

### 2. 快速交付原则
- **时间盒**：3-5天交付可用工具
- **增量价值**：每个小功能都有独立价值
- **用户反馈**：快速发布，基于反馈迭代

### 3. 质量底线原则
- **正确性**：frontmatter解析必须准确
- **稳定性**：相同输入产生相同输出
- **可测试性**：每个功能都有对应测试

### 4. 演进友好原则
- **扩展点预留**：为v1.0功能预留接口
- **数据兼容**：v0.1输出可为v1.0输入
- **配置演进**：支持未来配置格式扩展

---

## 预期产出

### 主要产出（本次畅谈会必须完成）
1. ✅ **v0.1/scope.md 最终版**：确认的功能边界文档
2. ✅ **v0.1/api.md 草案**：简化版API设计
3. ✅ **v0.1/spec.md 草案**：简化版实现规范
4. ✅ **开发计划**：3-5天详细任务分解

### 次要产出（如有时间）
5. ⏳ **示例文档**：展示frontmatter schema使用
6. ⏳ **测试用例草案**：关键测试场景定义
7. ⏳ **CLI设计草案**：命令行接口设计

---

## 成功标准

### 主要成功标准
1. ✅ 团队对v0.1功能边界达成共识
2. ✅ 产出完整可实施的api.md和spec.md
3. ✅ 制定可行的3-5天开发计划
4. ✅ 明确v0.1与future版本的关系

### 次要成功标准
5. ✅ 识别v0.1的主要技术风险
6. ✅ 确定frontmatter schema标准
7. ✅ 规划v1.0的扩展点

---

## 参考资料

### 核心参考
1. [v0.1/scope.md](../../../atelia/docs/DocGraph/v0.1/scope.md) - **必读**，功能边界定义
2. [future/api.md](../../../atelia/docs/DocGraph/future/api.md) - 完整API设计参考
3. [future/spec.md](../../../atelia/docs/DocGraph/future/spec.md) - 完整规范参考

### 背景参考
4. [2025-12-31讨论记录](../../chat-log/2025-12/31.md) - 版本缩减决策背景
5. [wishes/active/wish-0002-doc-graph-tool.md](../../../wishes/active/wish-0002-doc-graph-tool.md) - 原始需求

### 技术参考
6. [YamlDotNet文档](https://github.com/aaubry/YamlDotNet) - YAML解析库
7. [System.CommandLine文档](https://github.com/dotnet/command-line-api) - CLI框架候选

---

## 开场引导

大家好！欢迎参加DocGraph v0.1简化版MVP设计畅谈会。

经过昨天的深入讨论，我们做出了一个重要的战略决策：**大幅缩减MVP范围，通过技术简化换取快速交付**。

### 决策回顾
1. **版本目录化**：创建v0.1（简化版）和future（完整版）分离
2. **技术简化**：只处理frontmatter，避免Markdown正文解析复杂性  
3. **核心价值**：聚焦"分散撰写，自动汇总鸟瞰"
4. **时间目标**：3-5天交付可用工具

### 今天的目标
基于已经创建的`v0.1/scope.md`功能边界文档，我们需要完成：
1. **确认和细化功能边界**
2. **设计简化版API**
3. **制定实现规范**
4. **规划开发计划**

### 特别提醒
- **参考但不依赖**：future目录中的完整设计仅作参考，v0.1必须大幅简化
- **边界清晰**：严格遵循scope.md的"做什么、不做什么"
- **快速决策**：目标是产出可实施的文档，不是完美设计

让我们从**议题1：v0.1功能边界确认与细化**开始。首先邀请 **Seeker** 从概念架构角度，提出frontmatter schema的设计建议。

---

### 主持人开场 (刘德智)
大家好！欢迎来到DocGraph v0.1简化版MVP设计畅谈会。

让我简要回顾一下我们的战略调整：经过评估，我们决定采用更平滑的阶段分工，创建v0.1简化版聚焦frontmatter解析，快速交付"分散撰写，自动汇总鸟瞰"的核心价值。

现在，我们拥有：
- ✅ 版本目录结构（v0.1 / future）
- ✅ 基础文档框架
- 🔄 scope.md功能边界文档（待我们确认细化）

今天我们需要回答四个关键问题：
1. **边界确认**：v0.1具体做什么、不做什么？
2. **接口设计**：如何简化API到最小可用集？
3. **规范制定**：需要哪些具体实现约束？
4. **计划制定**：如何3-5天交付可用工具？

让我们从**议题1**开始：v0.1功能边界确认与细化。这是所有后续工作的基础——如果边界不清晰，设计和实现都会偏离方向。

首先邀请 **Seeker** 从概念架构角度，基于scope.md的框架，提出frontmatter schema的具体设计建议。

---

### Seeker 发言

感谢主持人邀请我开场。我从概念架构角度对scope.md §3的设计进行深入分析，聚焦三个核心问题：frontmatter schema的合理性、Visitor模式设计、以及技术可行性识别。

---

## 一、Frontmatter Schema 合理性分析

### 1.1 推导逻辑的技术可行性评估

scope.md §3.1 提出的两个推导规则：

| 推导字段 | 推导规则 | 评估 |
|:---------|:---------|:-----|
| `docId` | `wish-0001.md` → `W-0001` | ⚠️ 需要明确边界情况 |
| `status` | `active/` → `"active"` | ⚠️ 需要定义层级处理 |

**docId 推导分析**：

技术上可行，但存在以下边界情况需要明确：

1. **命名不规范时的行为**：
   - `wish-1.md` → `W-1` 还是 `W-0001`？（前缀补零策略）
   - `my-first-wish.md` → 无法推导，应该怎么处理？
   - `WISH-0001.md` → 大小写规范化？

2. **产物文档的docId推导**：
   - 产物文档不遵循 `wish-xxxx.md` 命名模式
   - scope.md 标记产物文档的 `docId` 为必填，但又说"从文件名推导"
   - **建议**：产物文档的 `docId` 应显式声明，不推导

**status 推导分析**：

存在设计模糊地带：

1. **子目录情况**：`wishes/active/backend/wish-0001.md` 的 status 是什么？
   - 应该是 `"active"`（只看第一层），还是 `"active/backend"`（完整路径）？
   
2. **非标准目录**：`wishes/draft/` 目录存在时怎么处理？
   - 应该是 error、warning 还是忽略？

**建议决策**：

```yaml
# 推导规则明确化
docId_pattern: "wish-{NUMBER}.md" → "W-{NUMBER}"
docId_fallback: "无法推导时记录 warning，使用文件名 stem 作为 docId"
status_rule: "仅识别 active/completed，其他目录视为 active + warning"
```

### 1.2 字段最小集评估

当前 schema 的字段分布：

| 文档类型 | 必填字段 | 可选字段 | 推导字段 |
|:---------|:---------|:---------|:---------|
| Wish文档 | `title`, `produce` | — | `docId`, `status` |
| 产物文档 | `docId`, `title`, `produce_by` | — | — |

**核心问题**：**`defines` 和 `issues` 字段在哪里声明？**

scope.md §3.3.2 描述的 Visitor 需要从文档中提取这些字段：
- `GlossaryVisitor` 需要 `defines` 字段
- `IssueAggregator` 需要 `issues` 字段

但 §3.1 的 schema 表格**未声明这两个字段**——这是规范不完整的信号。

**建议补充**：

```yaml
# 汇总相关字段（可选）
defines:
  type: array
  items:
    type: object
    properties:
      term: string      # 术语名
      definition: string # 定义
  scope: "任何文档（wish或产物）"

issues:
  type: array
  items:
    type: object
    properties:
      description: string  # 问题描述
      status: string       # open/closed/blocked
      assignee: string?    # 负责人（可选）
  scope: "任何文档（wish或产物）"
```

**开放字段约定原则**：

这里涉及一个架构决策——frontmatter 是**封闭 schema** 还是**开放 schema**？

| 模式 | 特点 | 适合场景 |
|:-----|:-----|:---------|
| 封闭 schema | 只允许预定义字段 | 强类型验证需求 |
| 开放 schema | 核心字段必填 + 任意扩展字段 | 渐进演化需求 |

**建议**：采用**开放 schema** 模式——
- 核心字段（`title`, `produce`/`produce_by`）严格验证
- 扩展字段（`defines`, `issues` 等）按需使用，不存在时忽略
- 每个 Visitor 声明自己依赖的字段，缺失时 graceful degrade

### 1.3 一致性考虑

**docId 格式一致性**：

当前设计中存在格式不一致风险：

| 文档类型 | docId 示例 | 来源 |
|:---------|:-----------|:-----|
| Wish文档 | `W-0001` | 推导 |
| 产物文档 | `W-0002-L2` | 显式声明 |

这里的 `W-0002-L2` 暗示了一种**层级编码**（Wish ID + 层级标记），但规范没有解释：
- `L2` 代表什么？是 Layer 2 吗？
- 这是约定还是只是示例？

**建议**：如果 `L2` 有语义含义，应在规范中明确；如果只是示例，应使用无歧义的示例如 `api-design-doc`。

**路径引用一致性**：

`produce` 和 `produce_by` 中的路径格式需要明确：
- 相对于什么？workspace 根目录？当前文件？
- 是否允许 `../` 向上引用？
- scope.md §2.2 说"不进行路径处理"、"不规范化相对路径"——这意味着路径必须是**规范化的绝对路径**（相对于 workspace）

**建议明确**：`produce` 和 `produce_by` 的路径必须是相对于 workspace 根目录的规范化路径，不含 `./` 或 `../`。

---

## 二、Visitor 模式设计分析

### 2.1 上下文需求分析

Visitor 在遍历时需要哪些信息？分析两个具体 Visitor 的需求：

**GlossaryVisitor 需求**：
```
- 当前文档的 defines 字段
- 文档的标识信息（路径或 title）用于分组展示
- 不需要关系信息
```

**IssueAggregator 需求**：
```
- 当前文档的 issues 字段
- 文档的标识信息
- 可能需要关系信息（如：来自哪个 Wish 的问题）
```

**抽象出的上下文模型**：

```csharp
interface IDocumentContext
{
    string FilePath { get; }           // 文件路径
    string? DocId { get; }             // 文档ID（可能为null）
    string Title { get; }              // 标题
    IReadOnlyDictionary<string, object> Frontmatter { get; }  // 完整frontmatter
    
    // 关系信息（可选，某些Visitor需要）
    IEnumerable<string> ProducedBy { get; }  // 谁产生了我
    IEnumerable<string> Produces { get; }    // 我产生了谁
}
```

### 2.2 Visitor 接口设计建议

**核心设计考虑**：

1. **Visit 时机**：节点粒度 vs 整图粒度？
2. **输出方式**：返回值 vs 写入 Writer？
3. **聚合模式**：Visitor 自己聚合 vs 外部聚合？

**建议的接口设计**：

```csharp
// 方案A：节点粒度 + 内部聚合
interface IDocumentGraphVisitor
{
    void Visit(IDocumentContext context);  // 每个节点调用一次
    string GenerateOutput();               // 所有节点访问后调用
}

// 方案B：整图粒度 + 直接生成
interface IDocumentGraphVisitor
{
    string Generate(IDocumentGraph graph);  // 一次性访问整图
}
```

**方案对比**：

| 维度 | 方案A（节点粒度） | 方案B（整图粒度） |
|:-----|:------------------|:------------------|
| 灵活性 | 高（可自定义遍历顺序） | 中（需自己遍历） |
| 复杂度 | 中（需维护状态） | 低（无状态） |
| 适合场景 | 复杂聚合逻辑 | 简单汇总逻辑 |

**建议**：v0.1 采用**方案B**——整图粒度更简单，符合"简化优先"原则。方案A可作为 v1.0 的演进方向。

### 2.3 文档图内存模型建议

支持 Visitor 高效遍历的模型设计：

```csharp
// 核心数据结构
class DocumentGraph
{
    IReadOnlyList<DocumentNode> RootNodes { get; }      // Wish文档
    IReadOnlyList<DocumentNode> AllNodes { get; }       // 所有文档
    IReadOnlyDictionary<string, DocumentNode> ByPath { get; }  // 路径索引
}

class DocumentNode
{
    string FilePath { get; }
    Frontmatter Metadata { get; }
    IReadOnlyList<DocumentNode> Produces { get; }    // 出边
    IReadOnlyList<DocumentNode> ProducedBy { get; }  // 入边
}
```

**关键设计决策**：

1. **图是否需要拓扑排序？**
   - 对于 GlossaryVisitor：不需要，遍历顺序不影响输出
   - 对于 IssueAggregator：可能需要按 Wish 分组
   - **建议**：提供按路径排序的 AllNodes，特殊需求由 Visitor 自己处理

2. **是否需要缓存派生信息？**
   - 如"深度"、"子树大小"等
   - **建议**：v0.1 不缓存，按需计算

### 2.4 扩展性设计建议

**新增 Visitor 的流程**：

```
1. 定义 Visitor 类实现 IDocumentGraphVisitor
2. 声明依赖的 frontmatter 字段（通过文档或 Attribute）
3. 注册到 Visitor 管道（硬编码或 DI）
4. 生成的文件命名：{visitor-name}.gen.md
```

**frontmatter 字段的开放约定**：

```yaml
# 在 scope.md 或独立文档中维护
known_fields:
  - name: defines
    used_by: GlossaryVisitor
    schema: { term: string, definition: string }[]
  
  - name: issues
    used_by: IssueAggregator
    schema: { description: string, status: string, assignee?: string }[]
```

---

## 三、技术可行性与风险识别

### 3.1 文件系统推导的可靠性

| 风险 | 可能性 | 影响 | 缓解策略 |
|:-----|:-------|:-----|:---------|
| 文件名不符合 pattern | 高 | 中 | 提供清晰的 warning + fallback |
| 符号链接导致路径混淆 | 低 | 高 | scope.md 已说明不处理符号链接 |
| 大小写敏感差异 | 中 | 中 | 明确规范使用小写 |
| 文件名包含特殊字符 | 低 | 中 | 限制 docId 字符集 |

### 3.2 YAML 解析边界情况

| 情况 | 处理建议 | scope.md 状态 |
|:-----|:---------|:--------------|
| 无 frontmatter | 跳过，记录 info | ✅ 已覆盖 |
| frontmatter 语法错误 | 跳过，记录 error | ✅ 已覆盖 |
| 字段类型不匹配 | 跳过该字段，记录 warning | ⚠️ 需明确 |
| 嵌套对象深度 | 限制深度（建议 3 层） | ❌ 未覆盖 |
| 循环引用（YAML anchor） | 禁止或展开 | ❌ 未覆盖 |

**建议补充**：在 spec.md 中明确 YAML 解析的约束：
- 禁用 YAML anchor/alias（`&` 和 `*`）
- 最大嵌套深度：3 层
- 字符串最大长度：10KB

### 3.3 文档图构建性能

**预估场景**：1000 个文档，平均每个 5 个关系

| 操作 | 复杂度 | 预估耗时（1000 docs） |
|:-----|:-------|:---------------------|
| 文件扫描 | O(n) | ~100ms |
| YAML 解析 | O(n × m) | ~500ms |
| 图构建 | O(n + e) | ~50ms |
| 闭包计算 | O(n + e) | ~50ms |
| 总计 | — | ~700ms |

**结论**：性能在可接受范围，v0.1 不需要优化。

### 3.4 Visitor 执行错误处理

**关键问题**：一个 Visitor 失败是否影响其他 Visitor？

**建议策略**：
1. 每个 Visitor 独立执行，失败不阻塞其他
2. 收集所有 Visitor 的错误，统一报告
3. 单个文档的字段缺失不算 Visitor 失败（graceful degrade）

```csharp
// 错误处理模式
foreach (var visitor in visitors)
{
    try
    {
        var output = visitor.Generate(graph);
        WriteOutput(visitor.OutputPath, output);
    }
    catch (Exception ex)
    {
        errors.Add(new VisitorError(visitor.Name, ex));
        // 继续执行其他 Visitor
    }
}
```

---

## 四、需要进一步讨论的关键问题

基于以上分析，我提出以下需要本次畅谈会决策的问题：

### 4.1 Schema 设计决策

| # | 问题 | 选项 | 我的建议 |
|:--|:-----|:-----|:---------|
| Q1 | frontmatter 是封闭还是开放 schema？ | 封闭 / 开放 | **开放**（核心严格，扩展自由） |
| Q2 | 产物文档的 docId 是推导还是显式？ | 推导 / 显式 | **显式**（产物命名无规律） |
| Q3 | `defines` 和 `issues` 应在 schema 中显式声明吗？ | 是 / 否 | **是**（作为已知扩展字段记录） |

### 4.2 Visitor 设计决策

| # | 问题 | 选项 | 我的建议 |
|:--|:-----|:-----|:---------|
| Q4 | Visitor 接口粒度？ | 节点粒度 / 整图粒度 | **整图粒度**（v0.1 简单优先） |
| Q5 | 输出文件如何命名？ | 固定名 / Visitor 声明 | **Visitor 声明**（灵活性） |

### 4.3 技术规范决策

| # | 问题 | 选项 | 我的建议 |
|:--|:-----|:-----|:---------|
| Q6 | YAML anchor 是否允许？ | 允许 / 禁止 | **禁止**（简化解析） |
| Q7 | 路径格式如何规范？ | 允许 ../ / 仅 workspace 相对路径 | **仅 workspace 相对路径** |

---

## 五、总结

scope.md 作为 v0.1 的边界文档，整体方向正确，但存在以下需要补充或明确的点：

1. **Schema 完整性**：补充 `defines` 和 `issues` 字段声明，明确开放 schema 约定
2. **推导规则细化**：明确边界情况处理（命名不规范、非标准目录）
3. **Visitor 接口设计**：建议整图粒度的简单接口
4. **技术约束补充**：YAML 解析限制、路径规范化规则

这些问题都不阻塞 v0.1 的核心功能，但需要在 api.md 和 spec.md 中明确，避免实现时的歧义。

期待 **Curator** 从用户体验角度补充对错误信息和输出格式的建议，以及 **Craftsman** 对条款完整性的审计。

---

> **附注**：在分析过程中，我观察到 scope.md 遵循了"时态投影"模式——L2 Shape（api.md）是天花板，L3 Rules（spec.md）是地板，scope.md 作为功能边界文档居于中间。这种分层使得演进路径清晰：修改 scope.md 触发 api.md 和 spec.md 的兼容性审查。

---

### Curator 发言

感谢 Seeker 提供的深入架构分析。我从 **UX/DX（用户体验/开发者体验）** 角度，对 DocGraph v0.1 设计进行补充分析，聚焦四个维度：错误信息体验、输出格式可用性、Visitor 扩展体验、以及命令行接口设计。

---

## 一、错误信息的 UX 设计分析

### 1.1 当前设计评估

scope.md §3.4 提供的错误报告格式：

```yaml
errorCode: "DOCMETA_YAML_PARSE_ERROR"
severity: "Error"
message: "YAML解析失败"
filePath: "wishes/active/wish-0001.md"
details:
  line: 3
  column: 5
  snippet: "title: 需求文档模板"
suggestion: "检查YAML语法，确保缩进正确"
```

**体验评估表**：

| 维度 | 当前状态 | 评分 | 改进建议 |
|:-----|:---------|:-----|:---------|
| **可发现性** | 错误码格式清晰 | ⭐⭐⭐⭐ | 保持 |
| **可理解性** | 技术语言，对非开发者不友好 | ⭐⭐⭐ | 增加人话版描述 |
| **可操作性** | 建议较笼统 | ⭐⭐ | 提供具体修复示例 |
| **可定位性** | 有行列号和代码片段 | ⭐⭐⭐⭐⭐ | 优秀 |

### 1.2 Error as Navigation（错误即导航）

我在认知档案中记录过这个原则：**错误信息不应只是报错，而应提供恢复路径——从 Dead End 变成 Navigation Sign。**

**当前 `suggestion` 字段的问题**：

```yaml
suggestion: "检查YAML语法，确保缩进正确"
```

这是一个**方向指引**，但不是**路径导航**。用户收到这个信息后，仍然不知道：
1. 哪里缩进错了？
2. 正确的缩进是什么样？
3. 有没有在线修复工具？

**改进建议——三层建议结构**：

```yaml
suggestion:
  quick: "第3行缩进错误，应使用2个空格"     # 5秒能理解
  detail: |                                   # 30秒能修复
    错误行: `  title: 需求文档模板`（当前3空格）
    修正为: `  title: 需求文档模板`（应为2空格）
  reference: "https://yaml.org/spec/1.2.2/#61-indentation-spaces"  # 按需深入
```

**设计原则**：**文档分层的时间预算**同样适用于错误信息——

| 层级 | 时间预算 | 对应信息 |
|:-----|:---------|:---------|
| L0 | 5秒 | `quick`：我哪里错了？ |
| L1 | 30秒 | `detail`：怎么修复？ |
| L2 | 按需 | `reference`：为什么是这样？ |

### 1.3 错误分级的用户体验

scope.md 定义了三个级别：**Error / Warning / Info**

**当前问题**：用户如何快速判断"必须修复"vs"可以忽略"？

**建议——视觉区分 + 行动标签**：

| 级别 | 视觉标记 | 行动标签 | 用户心智模型 |
|:-----|:---------|:---------|:-------------|
| Error | 🔴 | `[MUST FIX]` | 阻塞性问题，必须处理 |
| Warning | 🟡 | `[SHOULD FIX]` | 建议处理，但不阻塞 |
| Info | 🔵 | `[FYI]` | 信息性提示，可忽略 |

**CLI 输出示例**：

```
🔴 [MUST FIX] wishes/active/wish-0001.md:3
   YAML解析失败：缩进错误
   
🟡 [SHOULD FIX] wishes/active/wish-0002.md
   缺失反向链接：api.md 的 produce_by 字段
   
🔵 [FYI] 检测到循环引用：wish-0001 → wish-0002 → wish-0001
```

**隐喻**：像交通信号灯——红灯停、黄灯慢、绿灯行，无需思考就能判断行动。

### 1.4 错误报告的双受众设计

我在认知档案中记录过：**人类偏好视觉直觉，LLM 偏好结构化数据。**

**建议支持两种输出模式**：

| 模式 | 格式 | 受众 | 用途 |
|:-----|:-----|:-----|:-----|
| Human | Markdown 表格 + Emoji | 人类开发者 | 阅读和理解 |
| Machine | JSON/YAML | CI/CD / Agent | 自动化处理 |

**实现建议**：

```bash
# 人类友好模式（默认）
docgraph validate ./wishes

# 机器友好模式
docgraph validate ./wishes --format=json
```

---

## 二、输出格式的可用性分析

### 2.1 术语表格式评估

scope.md §3.3.2 描述的格式：

```markdown
## api.md
- **DocumentNode**：文档图中的节点，表示一个文档
- **Produce关系**：wish文档到产物文档的链接

## spec.md  
- **Frontmatter**：文档头部的YAML元信息块
- **Visitor模式**：遍历文档图生成汇总的访问者模式
```

**体验评估**：

| 维度 | 评分 | 分析 |
|:-----|:-----|:-----|
| **信息密度** | ⭐⭐⭐⭐ | 紧凑，一眼能看多个术语 |
| **浏览效率** | ⭐⭐⭐ | 按文档分组，但无字母索引 |
| **查找效率** | ⭐⭐ | 需要 Ctrl+F，无跳转锚点 |
| **上下文保留** | ⭐⭐⭐⭐⭐ | 术语与源文档关联清晰 |

**改进建议——增加导航层**：

```markdown
<!-- 生成的术语表 -->
# 术语表

> 本文档由 DocGraph 自动生成，源自 12 个文档中的 47 个术语定义。

## 快速导航
[A](#a) | [B](#b) | [D](#d) | [F](#f) | [P](#p) | [V](#v)

---

## A

### api.md
- **Anchor** — 文档内锚点引用

## D

### api.md
- **Document** — 带有 frontmatter 的 Markdown 文件
- **DocumentNode** — 文档图中的节点

### spec.md
- **defines 字段** — frontmatter 中的术语定义数组

## F

### spec.md
- **Frontmatter** — 文档头部的 YAML 元信息块
```

**设计原则**：**IntelliSense as UI**——快速导航让用户能"发现"术语存在，而不是只能"搜索"。

### 2.2 问题表格格式评估

**当前设计问题**：scope.md 只描述了"分类的问题表格或列表"，但没有具体格式。

**建议格式——聚焦可操作性**：

```markdown
# 问题汇总

> 本文档由 DocGraph 自动生成，汇总 8 个文档中的 15 个待处理问题。

## 📊 统计概览

| 状态 | 数量 |
|:-----|-----:|
| 🔴 Open | 8 |
| 🟡 In Progress | 4 |
| ✅ Closed | 3 |

## 🔴 待处理问题

| 来源 | 问题 | 负责人 | 优先级 |
|:-----|:-----|:-------|:-------|
| [api.md](api.md#L23) | 接口命名不一致 | @Seeker | P1 |
| [spec.md](spec.md#L45) | 缺少错误码定义 | @Craftsman | P2 |

## 🟡 进行中

| 来源 | 问题 | 负责人 | 预计完成 |
|:-----|:-----|:-------|:---------|
| [scope.md](scope.md#L78) | 验收标准待确认 | @刘德智 | 2026-01-02 |
```

**关键设计点**：
1. **统计概览先行**：5 秒内了解全局状态
2. **按状态分组**：自然的工作流导航
3. **链接到源**：一键跳转到问题上下文
4. **可操作信息**：负责人 + 优先级/预计完成时间

### 2.3 机器生成声明的设计

scope.md 建议：
```html
<!-- 本文档由DocGraph工具自动生成，手动编辑无效 -->
```

**体验问题**：
1. "手动编辑无效"——略显强硬，且不够准确（手动编辑会被覆盖，不是"无效"）
2. 缺少再生成信息——用户不知道如何更新

**改进建议**：

```html
<!--
  📋 本文档由 DocGraph v0.1 自动生成
  🔄 更新方式: docgraph generate --glossary
  ⏰ 生成时间: 2026-01-01 10:30:45 UTC
  ⚠️ 手动编辑将在下次生成时被覆盖
-->
```

**设计原则**：提供**行动路径**（如何重新生成）而非只是**警告**（不要编辑）。

---

## 三、Visitor 扩展的 DX 设计分析

### 3.1 新增 Visitor 的认知负荷评估

基于 Seeker 建议的接口：

```csharp
interface IDocumentGraphVisitor
{
    string Generate(IDocumentGraph graph);  // 整图粒度
}
```

**认知负荷分析**：

| 步骤 | 需要了解的知识 | 负荷评分 |
|:-----|:--------------|:---------|
| 1. 实现接口 | 接口定义 | ⭐ 低 |
| 2. 遍历图 | IDocumentGraph 结构 | ⭐⭐ 中 |
| 3. 访问 frontmatter | 字段名和类型 | ⭐⭐⭐ 高 |
| 4. 生成输出 | 输出格式约定 | ⭐⭐ 中 |
| 5. 注册 Visitor | 注册机制 | ⭐⭐ 中 |

**主要 DX 问题**：步骤 3 的认知负荷最高——开发者需要知道：
- `defines` 字段的结构是什么？
- 如果字段不存在怎么办？
- 如果格式不对怎么办？

### 3.2 改进建议——字段契约声明

**问题**：开发者如何知道可以依赖哪些字段？

**建议——Attribute 声明 + 自动验证**：

```csharp
[DependsOnField("defines", typeof(TermDefinition[]))]
[OutputFile("glossary.gen.md")]
public class GlossaryVisitor : IDocumentGraphVisitor
{
    public string Generate(IDocumentGraph graph)
    {
        // 框架已保证 defines 字段存在且类型正确
        // 开发者专注于业务逻辑
    }
}

public record TermDefinition(string Term, string Definition);
```

**DX 收益**：
1. **自文档化**：Attribute 即文档
2. **编译期检查**：类型安全
3. **运行时验证**：框架自动处理字段缺失
4. **IDE 支持**：IntelliSense 自动补全

### 3.3 字段冲突的预防设计

**问题**：如果两个 Visitor 定义了同名但结构不同的字段怎么办？

**场景**：
- `GlossaryVisitor` 期望 `defines: [{term: string, definition: string}]`
- `TagVisitor` 期望 `defines: [string]`（仅标签列表）

**建议——命名空间约定**：

| 模式 | 示例 | 适用场景 |
|:-----|:-----|:---------|
| **前缀约定** | `glossary_defines`, `tag_defines` | 简单项目 |
| **分组约定** | `glossary: { defines: [...] }` | 复杂项目 |
| **注册表验证** | 框架检测冲突并报错 | 严格模式 |

**v0.1 建议**：采用前缀约定（简单），在 scope.md 中明确：

> **字段命名约定**：Visitor 自定义字段应使用 `{visitor名}_` 前缀，避免与核心字段或其他 Visitor 冲突。
> - 核心字段：`title`, `produce`, `produce_by`, `docId`, `status`
> - 扩展字段：`glossary_defines`, `issue_list`, `changelog_entries`

### 3.4 调试体验设计

**问题**：Visitor 出错时如何调试？

**建议——分层日志 + Dry Run**：

```bash
# 正常执行
docgraph generate --glossary

# 调试模式：显示 Visitor 执行过程
docgraph generate --glossary --verbose

# Dry Run：只显示会生成什么，不实际写入
docgraph generate --glossary --dry-run
```

**Verbose 输出示例**：

```
[GlossaryVisitor] 开始执行
[GlossaryVisitor] 扫描到 12 个文档
[GlossaryVisitor] api.md: 找到 3 个术语定义
[GlossaryVisitor] spec.md: 找到 5 个术语定义
[GlossaryVisitor] scope.md: 字段 'defines' 不存在，跳过
[GlossaryVisitor] 生成输出: 8 个术语，2.3KB
[GlossaryVisitor] 写入: glossary.gen.md ✅
```

---

## 四、命令行接口的 UX 设计

### 4.1 命令结构设计

**当前 api.md 草案**：

```bash
docgraph scan <path>
docgraph links <path>
docgraph backlinks <path>
docgraph table <config.yaml>
docgraph fix-backlinks <path>
```

**体验评估**：

| 维度 | 评分 | 分析 |
|:-----|:-----|:-----|
| **可发现性** | ⭐⭐⭐ | 命令名清晰，但需要记忆 |
| **一致性** | ⭐⭐ | `links` vs `backlinks` vs `fix-backlinks` 不一致 |
| **简洁性** | ⭐⭐⭐⭐ | 动词 + 名词结构清晰 |

**改进建议——动词分组**：

```bash
# 分析类命令
docgraph scan <path>         # 扫描并显示统计
docgraph check <path>        # 验证所有规则（统一入口）
docgraph check links <path>  # 只检查链接
docgraph check backlinks <path>  # 只检查反向链接

# 生成类命令
docgraph generate <path>            # 生成所有汇总文档
docgraph generate glossary <path>   # 只生成术语表
docgraph generate issues <path>     # 只生成问题汇总

# 修复类命令
docgraph fix <path>             # 修复所有可自动修复的问题
docgraph fix backlinks <path>   # 只修复反向链接
```

**设计原则**：**动词层级**——顶层动词表达意图（check/generate/fix），子命令表达范围。

### 4.2 默认行为设计

**问题**：用户执行 `docgraph` 无参数时应该发生什么？

**候选方案**：

| 方案 | 行为 | 适合场景 |
|:-----|:-----|:---------|
| A | 显示帮助 | 新用户友好 |
| B | 执行 `scan .` | 快速上手 |
| C | 执行 `check .` | 工作流友好 |

**建议**：**方案 A（显示帮助）**，但帮助信息应包含快速入门示例：

```
DocGraph v0.1 - 文档关系验证器

用法: docgraph <命令> [选项]

快速开始:
  docgraph scan .        扫描当前目录并显示文档统计
  docgraph check .       验证文档关系完整性
  docgraph generate .    生成汇总文档

命令:
  scan      扫描工作区并显示统计
  check     验证文档关系和链接
  generate  生成汇总文档
  fix       修复可自动修复的问题

运行 'docgraph <命令> --help' 获取详细帮助。
```

### 4.3 进度反馈设计

**问题**：处理大量文件时如何提供进度反馈？

**建议——渐进式反馈**：

| 文件数量 | 反馈方式 |
|:---------|:---------|
| < 10 | 静默，最后显示摘要 |
| 10-100 | 进度条（单行更新） |
| > 100 | 进度条 + 当前文件名 |

**进度条示例**：

```
扫描文档 [████████████░░░░░░░░] 65% (65/100) wishes/active/wish-0042.md
```

**摘要示例**：

```
✅ 扫描完成

📊 统计:
   文档总数: 100
   Wish文档: 23
   产物文档: 77
   关系总数: 156

⏱  耗时: 1.2秒
```

### 4.4 错误退出码设计

**建议——语义化退出码**：

| 退出码 | 含义 | 使用场景 |
|:-------|:-----|:---------|
| 0 | 成功 | 无错误，无警告 |
| 1 | 警告 | 有警告，无错误 |
| 2 | 错误 | 有验证错误 |
| 3 | 致命 | 无法执行（配置错误、IO错误） |

**CI/CD 集成价值**：

```yaml
# GitHub Actions 示例
- name: 验证文档关系
  run: docgraph check .
  continue-on-error: ${{ github.event_name == 'pull_request' }}
```

---

## 五、对 Seeker 七个决策问题的 UX 视角建议

| # | 问题 | Seeker 建议 | Curator UX 视角 |
|:--|:-----|:------------|:----------------|
| Q1 | frontmatter 封闭/开放 schema | **开放** | ✅ 同意。开放 schema 对 Visitor 开发者更友好，降低引入新功能的摩擦 |
| Q2 | 产物文档 docId 推导/显式 | **显式** | ✅ 同意。推导规则不透明会让用户困惑"我的 docId 是怎么来的？" |
| Q3 | defines/issues 显式声明 | **是** | ✅ 同意。显式声明是 DX 的自文档化，开发者不需要猜测 |
| Q4 | Visitor 节点/整图粒度 | **整图** | ⚠️ 建议增加便利方法。纯整图粒度需要开发者自己遍历，可提供 `graph.ForEachDocument(visitor)` 便利方法 |
| Q5 | 输出文件命名 | **Visitor声明** | ✅ 同意。但建议提供默认命名约定（`{VisitorName}.gen.md`），减少决策负担 |
| Q6 | YAML anchor | **禁止** | ✅ 同意。Anchor 增加调试复杂度，错误信息更难定位 |
| Q7 | 路径格式 | **仅 workspace 相对路径** | ✅ 同意。但需要清晰的错误信息："路径 '../outside.md' 无效，produce 只接受 workspace 内的相对路径" |

---

## 六、总结与建议优先级

### 6.1 高优先级（影响核心体验）

1. **错误信息三层结构**：quick / detail / reference，支持不同时间预算
2. **错误分级视觉标记**：🔴/🟡/🔵 + 行动标签，5 秒内判断是否需要处理
3. **CLI 进度反馈**：大文件集时避免"黑屏等待"体验

### 6.2 中优先级（提升 DX）

4. **Visitor 字段契约声明**：Attribute 自文档化 + 编译期检查
5. **字段命名空间约定**：预防扩展时的冲突
6. **机器生成声明增强**：提供再生成命令和时间戳

### 6.3 低优先级（锦上添花）

7. **术语表字母索引**：大型术语表的导航优化
8. **问题表格统计概览**：快速了解全局状态
9. **双受众输出格式**：Human + Machine 模式切换

---

期待 **Craftsman** 对条款完整性进行审计，特别是错误码命名规范和退出码策略的条款化。

> **附注**：在分析过程中，我观察到一个有趣的模式——DocGraph 的核心价值主张"分散撰写，自动验证关系"本身就是一种 DX 设计：它将**认知负担**从"人工维护双向链接"转移到"工具自动验证"，这是 **Pit of Success** 原则的应用。工具的 UX 设计应该延续这个理念——让正确的做法成为最省力的做法。

---

### Craftsman 发言

我从“**可实施性 / 可测试性 / 风险控制**”视角对 v0.1/scope.md §3.1~§3.4 进行审计，并结合 Seeker/Curator 的建议给出可落地的条款草案。

> 结论先行：v0.1 当前最大的不确定性不是算法，而是**“约束之间互相打架”**（尤其是路径处理与推导语义、以及自动写文件的失败语义）。如果不在 spec.md 把这些固定下来，测试会无法写成“判定式”，实现会出现“做了也不算错”的灰区。

---

## 1) 条款完整性与可测试性审计（§3.1~§3.4）

### 1.1 §3.1 frontmatter schema 约束（完整性/验收/边界）

**发现的缺口 / 歧义**
1. **schema 表未声明 Visitor 依赖字段**：§3.3.2 明确 GlossaryVisitor/IssueAggregator 依赖 `defines`/`issues`，但 §3.1 schema 表没有声明这两字段的存在形态与类型。
2. **docId 推导与产物 docId 必填存在语义冲突**：scope.md 同时写了“产物文档 `docId` 必填”与“模板创建时从文件名推导 docId”。但产物文件名不一定遵循 wish-XXXX 格式，推导规则不闭合。
3. **status 推导规则未闭合**：§2.1 root 扫描允许子目录；§3.1 status 推导仅给了 active/completed 映射，但未定义 `wishes/active/subdir/` 的 status 语义。
4. **produce / produce_by 的路径语义不自洽**：§2.2.4 写“不进行路径处理、不规范化 ../、不检查越界”；但 §3.2 又要求“闭包构建、目标文件存在、行号定位”。若不规范化，`../` 的存在性检查不可判定（依赖当前文件目录解析策略）。

**可测试化建议（把“不确定”变成“可判定”）**
- 明确“**字段类型/空值/重复值**”的处理策略：
   - `title`: MUST 是非空 string（`""` 视为缺失）。
   - `produce`/`produce_by`: MUST 是 string[]；元素 MUST 非空；重复项 SHOULD 去重（以规范化后的路径为 key）。
   - 当字段类型不匹配（如 `produce: foo` 或 `produce: [{...}]`）：应产生可预测的错误码与严重度（见 §3.4 建议）。
- 明确“**推导字段**”的 failover：
   - Wish 的 `docId`：若文件名不匹配 `wish-\d{4}.md`，MUST 记录 `Warning` 并使用文件名 stem 的规范化值作为 fallback（或直接 Fatal，二选一必须固定）。
   - status：MUST 以根目录名（active/completed）为准；子目录不影响 status。

**建议的最小验收标准（可直接落到测试用例）**
- 给定一个 Wish 文档 frontmatter：
   - 缺 `title` → 产生 `DOCGRAPH_FRONTMATTER_REQUIRED_FIELD_MISSING`（Fatal 或 Error，需决策）；
   - `produce` 非数组 → `DOCGRAPH_FRONTMATTER_FIELD_TYPE_MISMATCH`；
   - `produce` 含空字符串/空白 → `DOCGRAPH_FRONTMATTER_FIELD_VALUE_INVALID`。
- 给定一个产物文档 frontmatter：
   - 缺 `produce_by` → `DOCGRAPH_FRONTMATTER_REQUIRED_FIELD_MISSING`；
   - `produce_by` 中引用不存在的 Wish → `DOCGRAPH_RELATION_DANGLING_BACKLINK`。

### 1.2 §3.2 输入处理约束（扫描/解析/闭包/边界）

**发现的缺口 / 歧义**
1. **扫描根集合与 scope 的“仅 active+completed”一致，但后续策略与 future/spec.md 有分叉**：future/spec.md（v1.0）含 abandoned 与正文链接提取；而 v0.1 明确“不解析正文”。需要在 v0.1/spec.md 明确：v0.1 与 future 的差异是“刻意不做”，防止实现倒灌。
2. **frontmatter 检测规则缺失**：对无 frontmatter 的 `.md`，“忽略”还是“报告”？§2.1 写忽略无 frontmatter 的文件，但 §3.2 错误处理又写 YAML 解析错误等。需要明确 frontmatter 缺失的严重度与是否在报告中出现。
3. **闭包构建的访问顺序与幂等性未固化**：如果图允许环，遍历顺序会影响输出顺序；scope.md 只说“相同输入相同输出”，但没给排序键。

**可测试化建议**
- 定义 frontmatter 边界：
   - MUST 仅识别文件首部的 `---` 起始与后续第一个 `---` 结束（CommonMark frontmatter 约定）。
   - 若首部不是 `---` → 视为“无 frontmatter”。
- 定义遍历/闭包：
   - MUST 使用“规范化后的路径”做 visited key；
   - MUST 提供稳定顺序：节点按 `FilePath` 字典序；边按 `TargetPath` 字典序；报告按（Severity → ErrorCode → SourcePath → TargetPath → LineNumber）排序。

**边界条件覆盖建议（建议纳入验收/测试矩阵）**
- 空目录：`wishes/active` 存在但 0 文件 → 退出码 0、报告为空、无 crash。
- 非 UTF-8：遇到不可解码文件 → 产生 `DOCGRAPH_IO_DECODE_FAILED`（Error/Fatal）且报告包含路径。
- 大文件：frontmatter 前超过 N KB 才出现 `---` → 明确“只读取前 N KB 以判断是否有 frontmatter”。

### 1.3 §3.3 输出约束（报告/生成文档/幂等）

**发现的缺口 / 歧义**
1. “人类可读格式（Markdown表格）”定义了形式但没有**SSOT**：Markdown 适合阅读，但对测试/CI 更稳定的是 JSON（结构化且可 snapshot）。
2. “汇总文档 .gen.md”写了后缀，但**文件名**、输出目录、覆盖策略都未固定。
3. “建议修复操作（仅建议，不自动修复）”与 §2.1 的“自动创建缺失 frontmatter”存在策略冲突：创建 frontmatter 本质上是写入修复。

**可测试化建议**
- 输出分为双轨：
   - MUST 产出结构化报告（`docgraph-report.json`）作为测试 SSOT；
   - SHOULD 产出 `docgraph-report.md` 作为人类阅读视图（由 JSON 渲染，避免双写漂移）。
- 文件写入策略：
   - MUST 使用“写临时文件 + 原子替换”（避免部分写入污染）。
   - MUST 在存在 Fatal 错误时不覆盖任何派生输出（报告本身除外）。

### 1.4 §3.4 错误处理约束（分类/退出码/失败语义）

**发现的缺口 / 歧义**
1. scope.md 的错误示例使用 `DOCMETA_*` errorCode，与 DocGraph 域不一致；且 Severity 值用 `Error/Warning/Info`，但没有绑定退出码策略。
2. “YAML解析错误：跳过该文件，记录错误”与“自动创建缺失frontmatter”冲突：当解析失败时，是否允许继续推导 produce 关系？（显然不应。）
3. “必填字段缺失：记录警告，继续处理”可能导致图不完整但输出仍成功；需要明确这是否允许。

**建议固定的失败语义（可写成测试）**
- 错误严重度建议采用 3 级：`Warning` / `Error` / `Fatal`。
- 退出码建议与 Curator 的提案对齐：`0=success, 1=warning-only, 2=has-error, 3=fatal`。
- MUST 聚合错误：同一次运行输出“全量问题清单”，而不是遇首错即停。

---

## 2) 技术约束合理性审计（必要性/过度约束/复杂度）

### 2.1 YAML 解析约束（anchor / 嵌套深度 / 字符串长度）

**必要性**：必要。
- v0.1 的输入面向 repo 文档（可被 PR 输入污染），YAML 在默认配置下容易被用作“构造超大对象图/别名爆炸”的 DoS 载体。

**是否过度约束？** 不过度，但要“可实现”。
- 禁止 anchor/alias：强烈建议。原因不是“YAML 不好”，而是**错误定位/可读性**与**别名展开的不确定成本**。
- 最大嵌套深度/字符串长度：建议保守但足够宽松（例如 frontmatter 最大 64KB，嵌套深度 ≤ 10，单字符串 ≤ 8KB，数组长度 ≤ 1024）。

**实现复杂度评估**
- 在 YamlDotNet 上实现“深度/长度限制、禁 alias”：
   - 低-中复杂度：可在解析后遍历节点树做约束检查；
   - alias 检测：可通过事件流（parser events）或 node 类型检测来识别 alias；若要 100% 准确，建议使用事件流。

### 2.2 文件系统推导可靠性（workspace root / 相对路径）

**当前 scope.md 的不一致点**：
- §2.2.4 写“不规范化 ../、不检查越界”；但 v0.1 仍要做“目标文件存在性检查 + 自动创建 frontmatter”。这要求我们必须把 `produce` 路径解析成一个确定的文件路径。

**建议裁决（技术上最稳、也最省工）**：
- v0.1 **必须**做最小路径规范化（消解 `.`/`..`、统一分隔符、校验不越界）。这不是“高级路径处理”，而是“让存在性检查可判定”。
- 并将输入格式收敛为：**workspace-relative、使用 `/`、不得含 `..` 越界**。

### 2.3 文档图构建性能约束

**必要性**：不需要过早优化，但需要一个“不会踩坑”的实现边界。
- v0.1 规模（1000~5000 文档）下，O(n+e) 足够。

**实现建议（避免隐藏的性能/栈风险）**
- 闭包构建使用队列/栈迭代，不用递归（避免深路径导致栈溢出）。
- 使用字典索引：`path -> node`，避免 O(n) 查找。

### 2.4 Visitor 执行的错误处理

**必要性**：必要。
- Visitor 是“插件式用户代码”，最容易出现未处理异常、输出不稳定。

**建议策略（可测试/可控）**
- 每个 Visitor 独立 try/catch，失败不阻塞其他 Visitor 的运行；
- 但 Visitor 失败应计入 Error，使整体退出码非零（避免 CI 默默通过）；
- 输出采用“临时文件 + 原子替换”，避免部分写入。

---

## 3) 对 7 个决策问题的技术视角建议

### Q1: frontmatter 封闭 vs 开放 schema
- 建议：**开放 schema + 核心字段闭集**。
- 技术理由：
   - 封闭 schema 会导致每次新增 Visitor 字段都要改 schema/验证器，反而拖慢迭代；
   - 开放 schema 只要固定核心字段（title/produce/produce_by/docId/status 的语义），其余字段由 Visitor 自证（缺失则跳过或给 warning），实现更简单。

### Q2: 产物文档 docId 推导 vs 显式
- 建议：**产物 docId 显式必填；Wish docId 可推导**。
- 技术理由：产物命名无规律；推导意味着引入额外规则与边界条件，最终会变成“半自动但不可解释”。显式最可测。

### Q3: defines/issues 显式声明的技术必要性
- 建议：**必须显式声明为“已知扩展字段（Known Optional Fields）”**，并给出最小 schema（数组、元素字段）。
- 技术理由：否则 Visitor 的输入类型不可判定，测试无法写出“缺字段/错类型”的一致行为。

### Q4: Visitor 接口粒度（节点粒度 vs 整图粒度）
- 建议：v0.1 用**整图粒度（Generate(graph)）**，并提供框架级便利遍历方法；节点粒度留给 v1+。
- 技术理由：
   - 节点粒度引入状态管理（Visit 顺序、生命周期、Flush/Finalize）；
   - 整图粒度更容易写成纯函数，天然可测试（输入图 → 输出字符串）。

### Q5: 输出文件命名的技术实现
- 建议：Visitor 声明输出文件名 + 默认约定兜底：`{VisitorName}.gen.md`。
- 技术理由：
   - 允许扩展，但仍可预测；
   - 测试只需按声明路径做快照比对。

### Q6: YAML anchor 禁止的技术理由
- 建议：**禁止**。
- 技术理由：
   - alias 会让“同一字段值来源”变得不可定位，错误提示困难；
   - 可能触发别名爆炸与资源消耗不确定性。

### Q7: 路径格式规范的技术约束
- 建议：**只接受 workspace-relative 的规范化路径（使用 `/`，禁止 `..` 越界）**。
- 技术理由：否则“存在性检查/闭包构建/自动创建”都无法在跨平台与不同 cwd 下保持确定性，幂等性无法保证。

---

## 4) 实现风险识别与缓解

### 4.1 技术风险
- **路径语义不闭合**：不规范化与需要存在性检查/创建文件矛盾。
   - 缓解：在 v0.1/spec.md 明确“必须规范化 + 边界检查”；把 scope.md §2.2.4 的“不处理路径”改成“仅做最小规范化，不做高级路径推断”。
- **自动创建 frontmatter 的副作用风险**：一旦写入失败或部分写入，会污染 repo。
   - 缓解：把“创建模板”放到 `--write/--fix` 显式开关；默认 validate-only；写入采用原子替换。
- **YAML 安全/边界未约束**：可能被极端输入拖垮。
   - 缓解：增加 frontmatter 最大字节数/深度/字符串长度限制，禁 alias。

### 4.2 进度风险（3-5 天交付）
- **报告格式同时做 Markdown + 复杂建议**会吞时间。
   - 缓解：先做 JSON SSOT + 简单 Markdown 渲染；高级 UX（导航索引、统计面板）后置。
- **Visitor 扩展机制过早抽象**。
   - 缓解：v0.1 只内置 2 个 Visitor（glossary/issues），注册硬编码；插件化/DI 延后。

### 4.3 质量风险
- **“边界不清”导致测试无法覆盖**：实现者会各自猜测。
   - 缓解：把关键不确定点上升为“决策表 + 条款编号”，并要求每条 MUST 映射到测试用例。
- **与 future/spec.md 概念混线**：v0.1 不解析正文，但 future/spec 有正文链接提取规则。
   - 缓解：在 v0.1/spec.md 开头写“非目标清单（MUST NOT）”，并在错误报告中区分“v0.1 未实现”而非“解析失败”。

---

## 5) 具体 spec.md 条款建议（可直接落地到 v0.1/spec.md）

> 说明：条款前缀遵循 spec-conventions 的 `[F/A/S/R]` 闭集；错误码统一 `DOCGRAPH_` 前缀。

### 5.1 Frontmatter / Schema
- **[S-DOCGRAPH-FRONTMATTER-BOUNDARY]** MUST：frontmatter 仅识别“文件首部 `---` 到下一条 `---`”的 YAML 区块；否则视为无 frontmatter。
- **[S-DOCGRAPH-SCHEMA-OPEN-WITH-CORE]** MUST：frontmatter 允许扩展字段，但 MUST 校验核心字段语义：Wish 需 `title`/`produce`；产物需 `docId`/`title`/`produce_by`。
- **[S-DOCGRAPH-KNOWN-OPTIONAL-FIELDS]** SHOULD：声明 `defines` 与 `issues` 为已知可选字段；缺失时 Visitor MUST 跳过而非报错。

### 5.2 YAML 解析限制
- **[S-DOCGRAPH-YAML-NO-ALIAS]** MUST NOT：frontmatter 不允许 YAML anchor/alias（`&`/`*`）。
- **[S-DOCGRAPH-YAML-LIMITS]** MUST：frontmatter 解析前需执行资源上限：最大字节数、最大嵌套深度、最大序列长度、最大字符串长度（阈值在 spec 中固定）。

### 5.3 路径与闭包
- **[S-DOCGRAPH-PATH-FORMAT]** MUST：`produce`/`produce_by` 元素必须是 workspace-relative 路径，使用 `/` 作为分隔符。
- **[S-DOCGRAPH-PATH-NORMALIZE]** MUST：路径必须规范化（消解 `.`/`..`）；规范化后 MUST 不越出 workspace。
- **[S-DOCGRAPH-CLOSURE-DETERMINISTIC]** MUST：闭包构建与报告输出必须按稳定排序产生确定性结果（排序键在 spec 中固定）。

### 5.4 错误与退出码
- **[A-DOCGRAPH-ERROR-AGGREGATE]** MUST：聚合所有错误后输出报告；不得遇首错即停（除非 workspace 根目录无法确定）。
- **[A-DOCGRAPH-EXITCODE]** MUST：退出码语义固定：0/1/2/3（success/warn/error/fatal）。
- **[S-DOCGRAPH-NO-WRITE-ON-FATAL]** MUST：当存在 Fatal 错误时，除报告外不得写入/覆盖任何派生文件。

### 5.5 写入策略（若保留“自动创建 frontmatter”）
- **[A-DOCGRAPH-WRITE-EXPLICIT]** MUST：任何会修改工作区文件的行为必须在显式开关（如 `--write`）开启时才允许。
- **[S-DOCGRAPH-WRITE-ATOMIC]** MUST：写入采用“临时文件 + 原子替换”，避免部分写入。

---

## 6) 建议的验收测试矩阵（便于 xUnit/端到端）

为避免“条款可测试但没人写测试”，我建议把验收用例按 4 组固化（每组 ≥ 5 用例）：
1. **Schema/类型**：缺字段、错类型、空字符串、重复路径、未知字段。
2. **路径/闭包**：`./`、`../`、越界、大小写差异、循环 produce。
3. **报告/幂等**：同输入两次输出字节相同；错误排序稳定；JSON schema 验证。
4. **写入副作用**（若启用）：`--write` 开关 gating；原子写；失败不污染。

以上条款若落地，v0.1 将具备：**实现路径短、测试可判定、失败语义可控**三项“能在 3-5 天交付”的必要条件。

---

### 主持人总结与决策 (刘德智)

感谢Seeker、Curator、Craftsman三位专家的深入分析！经过畅谈会，我们取得了重要进展：

## 【畅谈会成果总结】

### 1. 关键矛盾识别与解决
**发现的问题**：scope.md §2.2.4与§3.2存在路径处理自相矛盾
- §2.2.4："不进行路径处理，不规范化../，不检查越界"
- §3.2：需要"目标文件存在性检查 + 自动创建frontmatter"

**技术裁决**：v0.1必须做最小路径规范化，否则存在性检查不可判定
**已修正**：将§2.2.4改为"仅做最小路径处理"

### 2. 7个关键决策问题达成一致

| # | 问题 | 决策 | 理由 |
|:--|:-----|:-----|:-----|
| Q1 | frontmatter封闭vs开放schema | **开放schema + 核心字段闭集** | 扩展灵活，实现简单 |
| Q2 | 产物文档docId推导vs显式 | **产物显式，Wish推导** | 产物命名无规律，推导不可解释 |
| Q3 | defines/issues显式声明 | **显式声明为已知扩展字段** | Visitor输入类型可判定 |
| Q4 | Visitor接口粒度 | **整图粒度 + 便利方法** | 纯函数易测试，v0.1简单优先 |
| Q5 | 输出文件命名 | **Visitor声明 + 默认约定** | 灵活可预测 |
| Q6 | YAML anchor | **禁止** | 错误定位困难，资源消耗不确定 |
| Q7 | 路径格式 | **workspace-relative规范化路径** | 存在性检查可判定，幂等性保证 |

### 3. 具体设计建议汇总

#### frontmatter schema设计
- **核心字段**：Wish(`title`, `produce`)，产物(`docId`, `title`, `produce_by`)
- **推导字段**：Wish `docId`(文件名)，`status`(文件夹)
- **扩展字段**：`defines`, `issues`作为已知扩展字段

#### Visitor模式设计
- **接口**：整图粒度 `string Generate(DocumentGraph graph)`
- **便利方法**：提供 `graph.ForEachDocument(visitor)` 辅助
- **错误处理**：Visitor独立执行，失败不阻塞其他

#### 错误处理设计
- **三层建议**：quick(5秒)/detail(30秒)/reference(按需)
- **视觉分级**：🔴/🟡/🔵 + 行动标签
- **退出码**：0=成功, 1=警告, 2=错误, 3=致命

#### 技术约束
- **YAML限制**：禁止anchor，限制嵌套深度/字符串长度
- **路径规范**：workspace-relative，统一`/`，规范化`../`
- **写入策略**：原子替换，显式开关控制

## 【畅谈会成果产出完成】

基于三位专家的深入分析和一致决策，我已经完成了所有目标产出：

### ✅ 已完成产出

#### 1. v0.1/api.md草案
- **内容**：基于一致的设计决策，定义了简化的接口和数据模型
- **核心**：DocumentNode/DocumentGraph数据模型，IDocumentGraphVisitor接口，内置Visitor实现
- **特色**：开放schema + 核心字段闭集，整图粒度Visitor，明确的错误码和退出码约定

#### 2. v0.1/spec.md草案（两部分）
- **第一部分**：Frontmatter解析、路径处理、文档图构建、错误处理约束
- **第二部分**：Visitor模式、写入策略、性能约束、测试要求、非目标清单
- **核心**：5个核心条款体系，具体的MUST/SHOULD/MAY约束，验收标准矩阵

#### 3. v0.1/todo.md
- **问题追踪**：7个需要进一步探讨的设计和技术问题
- **风险识别**：7个技术/进度/质量风险及缓解策略
- **扩展规划**：8个v1.0扩展点，4级实施优先级

### 📊 畅谈会关键成果统计

| 维度 | 数量 | 说明 |
|:-----|:-----|:-----|
| **专家分析** | 3份 | Seeker(概念架构)、Curator(UX/DX)、Craftsman(技术审计) |
| **决策问题** | 7个 | 全部达成一致，形成明确决策 |
| **设计矛盾** | 1个 | 发现并修正了路径处理自相矛盾 |
| **产出文档** | 3份 | api.md、spec.md、todo.md完整草案 |
| **条款约束** | 25+条 | 具体的MUST/SHOULD/MAY约束 |
| **验收标准** | 14项 | 功能/质量/用户体验三个维度 |

### 🎯 v0.1 设计核心亮点

1. **务实的设计哲学**：代码驱动 > 配置驱动，渐进抽象 > 过度设计
2. **清晰的边界定义**：开放schema + 核心字段闭集，workspace-relative规范化路径
3. **优雅的错误处理**：三层建议结构，视觉分级标记，语义化退出码
4. **灵活的扩展机制**：Visitor模式，整图粒度接口，字段契约声明
5. **完整的约束体系**：从YAML解析到文件写入的全链路约束

### 🚀 下一步：实施阶段

基于这些完整的设计文档，团队可以立即开始v0.1的实现：

#### 实施阶段建议
1. **Day 1-2**：核心框架 + DocumentGraphBuilder实现
2. **Day 3**：内置Visitor实现 + 基本CLI
3. **Day 4**：错误处理 + 测试覆盖
4. **Day 5**：集成测试 + 文档完善

#### 质量保证
- 遵循spec.md的所有MUST条款
- 实现验收标准矩阵的测试
- 保持与api.md接口定义一致

### 📝 畅谈会总结

本次畅谈会成功实现了"边商讨边实施"的目标：
- **深度分析**：三位专家从不同视角提供了全面分析
- **快速决策**：7个关键问题全部达成一致
- **矛盾识别**：发现并修正了scope.md的关键设计矛盾
- **成果沉淀**：产出完整可实施的工程文档
- **路径清晰**：为3-5天交付v0.1工具奠定了坚实基础

**畅谈会目标已全部达成！** 团队现在拥有完整的设计文档，可以立即开始v0.1的实现工作。
