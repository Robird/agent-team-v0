# 畅谈会：DocGraph v0.1 实施前关键问题解决

> **日期**：2026-01-01
> **标签**：#design #implementation
> **主持人**：刘德智 (Team Leader)
> **参与者**：Seeker, Curator, Craftsman
> **状态**：待开始
> **上下文**：v0.1 设计已完成，开始实施前需要解决关键问题

---

## 背景与目标

### 已完成的工作
基于昨天的畅谈会，我们已经完成了：
- ✅ scope.md 功能边界文档（已修正路径处理矛盾）
- ✅ api.md API 设计文档（草案）
- ✅ spec.md 实现规范文档（草案）
- ✅ todo.md 待办事项追踪

### 当前状态
v0.1 设计基本完成，但 todo.md 中记录了 **7个需要进一步探讨的问题**，这些问题需要在开始编码前解决或明确。

### 本次畅谈会目标
聚焦解决 **1-2个最关键的实施前问题**，为立即开始编码扫清障碍。

**优先级原则**：
1. 影响核心功能实现的
2. 影响第一天编码任务的
3. 有明确决策路径的

---

## 待解决问题分析

### 问题清单（来自 todo.md §1）

| # | 问题 | 优先级 | 影响 | 决策复杂度 |
|:--|:-----|:-------|:-----|:-----------|
| 1 | 自动维护的交互模式 | **高** | CLI设计、用户体验 | 中 |
| 2 | Visitor字段契约实现 | **中** | 开发者体验、扩展性 | 中 |
| 3 | 错误报告双受众格式 | **中** | CI/CD集成、自动化 | 中 |
| 4 | YAML资源限制具体值 | **低** | 性能、边界处理 | 低 |
| 5 | 路径规范化边界情况 | **中** | 跨平台兼容性 | 高 |
| 6 | 产物文档docId生成规则 | **低** | 文档标识一致性 | 低 |
| 7 | issues字段状态值约定 | **低** | 问题跟踪规范性 | 低 |

### 建议聚焦的问题

基于优先级分析，我建议本次畅谈会聚焦：

#### 🔴 **问题 1：自动维护的交互模式**
**理由**：
- 影响第一天编码任务（CLI设计）
- 涉及核心功能（自动创建缺失frontmatter）
- 有明确的决策点，容易达成共识

#### 🟡 **问题 5：路径规范化边界情况**  
**理由**：
- 影响跨平台兼容性
- 昨天刚修正了路径处理矛盾，需要细化
- 技术复杂度高，需要专家讨论

---

## 议题 1：自动维护的交互模式设计

### 问题背景
scope.md §2.1 定义了"自动创建缺失frontmatter的产物文档（按模板）"，但交互细节未明确。

### 待决策点

#### 1.1 操作模式设计
**选项**：
- **A. 纯自动模式**：检测到缺失就自动创建，无确认
- **B. 交互确认模式**：每个缺失文件都提示用户确认
- **C. 批量预览模式**：先显示所有需要创建的文件，批量确认
- **D. Dry-run 模式**：只显示会创建什么，不实际创建

#### 1.2 CLI 命令设计
**选项**：
- **A. 独立命令**：`docgraph fix` 专门处理修复
- **B. 参数模式**：`docgraph validate --fix` 验证时修复
- **C. 子命令模式**：`docgraph create-missing` 明确创建

#### 1.3 错误恢复策略
**待确定**：
- 创建过程中出错如何处理？
- 是否支持部分成功？
- 如何回滚失败的操作？

#### 1.4 模板内容设计
**待确定**：
- 模板的具体字段和默认值
- 是否支持自定义模板？
- 模板的存储位置和格式？

### 讨论要点
1. **用户体验 vs 自动化程度**：如何平衡便利性和可控性？
2. **安全考虑**：自动创建文件可能的风险和防护措施？
3. **集成工作流**：如何与现有开发流程集成？

### 预期产出
- 明确的交互模式决策
- CLI 命令设计草案
- 模板内容定义
- 错误处理策略

---

## 议题 2：路径规范化边界情况处理

### 问题背景
昨天修正了scope.md的路径处理矛盾，但具体边界情况需要细化。

### 待决策点

#### 2.1 Unicode 路径处理
**问题**：包含非ASCII字符的路径如何处理？
**选项**：
- **A. 完全支持**：保持原样，依赖文件系统
- **B. 规范化**：转换为NFD/NFKC形式
- **C. 限制**：只允许ASCII字符，其他报错

#### 2.2 混合分隔符处理
**问题**：Windows风格的`\`和Unix风格的`/`混合路径
**选项**：
- **A. 自动转换**：统一转换为`/`
- **B. 严格检查**：混合路径报错
- **C. 按平台处理**：根据运行平台决定

#### 2.3 非常规路径组件
**问题**：如`...`、`..\..`、空组件等
**选项**：
- **A. 严格过滤**：只允许常规组件
- **B. 尽力处理**：尝试规范化，失败报错
- **C. 警告但继续**：记录警告，继续处理

#### 2.4 符号链接处理
**问题**：虽然scope.md说不处理符号链接，但实际遇到时如何处理？
**选项**：
- **A. 跟随链接**：解析到实际目标
- **B. 保持链接**：按链接路径处理
- **C. 报错跳过**：遇到符号链接报错

### 讨论要点
1. **跨平台一致性**：如何确保不同操作系统上行为一致？
2. **安全性考虑**：路径处理可能的安全风险？
3. **错误信息友好性**：如何提供有用的错误提示？

### 预期产出
- 具体的路径处理算法
- 边界情况处理策略
- 错误码和错误信息设计

---

## 设计原则（本次讨论适用）

### 1. v0.1 简化优先
- 选择最简单的可行方案
- 避免过度设计
- 为v1.0预留扩展点

### 2. 用户体验一致
- CLI 行为可预测
- 错误信息有帮助
- 操作可逆或可恢复

### 3. 安全第一
- 不自动覆盖现有文件
- 提供预览和确认机制
- 清晰的权限和风险提示

---

## 开场引导

大家好！欢迎参加DocGraph v0.1实施前关键问题解决畅谈会。

经过昨天的深入设计，我们已经有了完整的设计文档。但在开始编码前，todo.md中还有7个问题需要解决。今天的目标是聚焦解决**1-2个最关键的问题**，为立即开始编码扫清障碍。

### 为什么选择这两个问题？

1. **问题1（自动维护交互模式）**：
   - 影响第一天编码任务（CLI设计）
   - 涉及核心用户体验
   - 决策后可以立即开始实现

2. **问题5（路径规范化边界情况）**：
   - 昨天刚修正了路径处理矛盾，需要细化
   - 影响跨平台兼容性
   - 技术复杂度高，需要专家讨论

### 今天的目标
1. 对问题1达成明确的设计决策
2. 对问题5确定具体的处理策略
3. 产出可立即实施的方案

让我们从**议题1：自动维护的交互模式设计**开始。首先邀请 **Curator** 从用户体验角度，提出交互模式的设计建议。

---

### 主持人开场 (刘德智)
大家好！欢迎来到DocGraph v0.1实施前关键问题解决畅谈会。

昨天我们完成了v0.1的完整设计，今天需要解决实施前的关键障碍。根据todo.md的分析，**问题1（自动维护交互模式）** 和 **问题5（路径规范化边界情况）** 是影响第一天编码的最关键问题。

让我们从**议题1**开始：自动维护的交互模式设计。这个问题直接影响：
1. CLI命令结构设计
2. 第一天编码任务
3. 核心用户体验

首先邀请 **Curator** 从UX/DX角度，分析各种交互模式的优缺点，并提出具体建议。

---

### Curator 发言

感谢主持人的邀请。我从 UX/DX 体验设计的角度，对自动维护交互模式进行全面分析。

---

## 一、操作模式设计分析

### 四个选项的体验评估

| 选项 | 认知负荷 | 控制感 | 效率 | 安全感 | v0.1适配度 |
|:-----|:---------|:-------|:-----|:-------|:-----------|
| A. 纯自动模式 | ⭐⭐⭐⭐⭐ | ⭐ | ⭐⭐⭐⭐⭐ | ⭐ | ⚠️ |
| B. 交互确认模式 | ⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ | ❌ |
| C. 批量预览模式 | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ✅ |
| D. Dry-run 模式 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ✅ |

### 各选项的体验叙事

**A. 纯自动模式** — "我替你做了"
- **优势**：零摩擦，适合 CI/CD 场景
- **风险**：用户失去感知，可能产生"幽灵文件"（不知道什么时候出现的文件）
- **体验隐喻**：像自动保存功能——方便，但偶尔让人不安
- **v0.1 评估**：⚠️ 风险较高，首版工具信任度未建立

**B. 交互确认模式** — "每一步都问你"
- **优势**：最高控制感
- **风险**：认知负荷爆炸，10个文件要确认10次
- **体验隐喻**：像 Windows Vista 的 UAC 弹窗——安全但烦人
- **v0.1 评估**：❌ 体验过于碎片化，不推荐

**C. 批量预览模式** — "先看清单，再一键执行"
- **优势**：平衡了控制感和效率
- **风险**：用户可能不仔细看清单
- **体验隐喻**：像购物车结账——先收集，再一次性确认
- **v0.1 评估**：✅ 推荐作为默认模式

**D. Dry-run 模式** — "只看不做"
- **优势**：零风险探索，建立信任
- **风险**：需要两步操作（先 dry-run，再执行）
- **体验隐喻**：像试衣间——先试穿，满意再买
- **v0.1 评估**：✅ 应作为必选功能

### 🎯 我的建议：组合策略 (C + D)

```
默认行为：批量预览模式 (C)
可选参数：--dry-run 只显示不执行 (D)
高级参数：--yes 跳过确认，纯自动 (A)
```

**理由**：
1. **渐进式信任**：首次使用者通过 dry-run 了解工具行为
2. **日常使用者**：批量预览平衡效率和安全
3. **自动化场景**：--yes 参数满足 CI/CD 需求
4. **体验一致性**：与 `npm install`、`apt upgrade` 等工具的交互模式一致

---

## 二、CLI 命令设计分析

### 三个选项的认知评估

| 选项 | 可发现性 | 心智模型匹配 | 命令复杂度 | 扩展性 |
|:-----|:---------|:-------------|:-----------|:-------|
| A. `docgraph fix` | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| B. `docgraph validate --fix` | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| C. `docgraph create-missing` | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ |

### 各选项的体验叙事

**A. `docgraph fix`** — "修它"
- **心智模型**：问题检测 → 问题修复（两阶段）
- **可发现性**：中等，需要先运行 validate 才知道有问题
- **类比**：`eslint --fix`、`dotnet format`
- **优势**：动词简洁，意图明确
- **劣势**：`fix` 的范围不明确（修什么？）

**B. `docgraph validate --fix`** — "验证时顺便修"
- **心智模型**：验证是主操作，修复是副操作
- **可发现性**：中等，需要知道 --fix 参数存在
- **类比**：`eslint --fix`、`tsc --fix`
- **优势**：符合"检测+修复"的单一入口模式
- **劣势**：参数组合可能变复杂（--fix --dry-run？）

**C. `docgraph create-missing`** — "创建缺失的"
- **心智模型**：明确的动作描述
- **可发现性**：高，命令名自解释
- **类比**：`npm init`、`dotnet new`
- **优势**：命令即文档
- **劣势**：命令名过长，未来可能有其他"修复"类型

### 🎯 我的建议：选项 A + B 混合

```bash
# 推荐命令结构
docgraph validate              # 只验证，不修复
docgraph validate --fix        # 验证并修复（批量预览模式）
docgraph validate --fix --yes  # 验证并自动修复（CI/CD模式）
docgraph validate --fix --dry-run  # 只显示会修复什么
```

**理由**：
1. **IntelliSense as UI**：`--fix` 参数会在补全列表中出现，引导用户发现修复能力
2. **渐进式披露**：validate 是入口，fix 是能力扩展
3. **与生态一致**：eslint、prettier、dotnet format 都用这种模式
4. **v1.0 扩展性**：未来可以加 `--fix-type=frontmatter|links|all` 细分修复类型

**不推荐 `docgraph fix` 作为独立命令的原因**：
- 需要先 validate 才能 fix，两步操作增加认知成本
- 用户可能困惑："我要先验证还是直接修？"

---

## 三、错误恢复策略设计

### 三层错误恢复模型

我借用我之前在 RBF 设计中提出的"快递发货"隐喻，设计三层错误恢复：

```
用户操作 ─┬─ [验证阶段] ─── 问题检测，生成修复计划
          │
          ├─ [预览阶段] ─── 显示计划，用户确认
          │
          └─ [执行阶段] ─── 逐个创建文件
                 │
                 ├─ 成功 → 继续下一个
                 └─ 失败 → 记录错误，继续其他（部分成功）
```

### 具体策略

#### 1. 部分成功（Partial Success）

**推荐**：支持部分成功，失败不阻塞其他文件的创建。

**理由**：
- **Error as Observation**：每个失败是一个数据点，不是致命错误
- **用户期望**：如果 10 个文件能创建 8 个，应该创建 8 个
- **类比**：`npm install` 即使某个包失败，仍会继续安装其他包

**输出格式建议**：
```
✓ Created: docs/glossary.md
✓ Created: docs/issues.md
✗ Failed: docs/readonly/locked.md (Permission denied)
✓ Created: docs/summary.md

Result: 3 created, 1 failed, 0 skipped
```

#### 2. 不自动回滚

**推荐**：失败时不自动回滚已创建的文件。

**理由**：
- **v0.1 简化原则**：回滚逻辑复杂，增加实现成本
- **用户预期**：创建是追加操作，不是事务
- **可恢复性**：用户可以手动删除不想要的文件
- **类比**：`git stash` 不会因为部分失败而回滚成功的部分

#### 3. 详细的失败报告

**推荐**：为每个失败提供具体原因和恢复建议。

**Error as Navigation 模式**：
```
✗ Failed: docs/protected/locked.md
  Reason: Permission denied (EACCES)
  Fix: Check file permissions or run with elevated privileges
  
✗ Failed: docs/invalid/bad-name[.md
  Reason: Invalid characters in path
  Fix: Rename the source file to use valid characters
```

### 🎯 我的建议摘要

| 场景 | 行为 | 退出码 |
|:-----|:-----|:-------|
| 全部成功 | 正常退出 | 0 |
| 部分成功 | 报告失败项，继续完成 | 0（有警告）或 1 |
| 全部失败 | 报告所有错误 | 1 |
| 验证阶段失败 | 不进入执行阶段 | 1 |

**退出码设计建议**：
- `0`：成功（包括部分成功且用户选择继续）
- `1`：有错误发生
- `2`：参数错误
- `3`：配置错误

---

## 四、模板内容设计

### 1. 模板的具体字段和默认值

**产物文档模板**（GlossaryVisitor 生成）：
```yaml
---
# DocGraph Auto-generated | 请勿删除此标记
docId: "{auto-generated-id}"
title: "{derived-from-filename}"
type: artifact
generatedBy: "{visitor-name}"
generatedAt: "{timestamp}"
sourceQuery: "{visitor-config}"
---

<!-- 
  此文件由 DocGraph 自动生成
  内容会在下次运行时被覆盖
  如需自定义，请移除 generatedBy 字段
-->
```

**关键设计决策**：
- `docId`：基于文件路径自动生成（如 `artifact/glossary`）
- `type: artifact`：明确标记为产物文档
- `generatedBy`：标记生成器，支持检测是否需要重新生成
- `generatedAt`：时间戳，帮助用户理解文件新鲜度

### 2. 自定义模板支持

**v0.1 建议**：⚠️ 不支持自定义模板

**理由**：
- v0.1 简化原则
- 避免配置复杂度
- 先观察用户实际需求

**v1.0 扩展点**：
- 支持 `.docgraph/templates/` 目录
- 支持 Handlebars/Liquid 模板语法
- 支持通过配置文件覆盖默认值

### 3. 模板的存储位置

**v0.1 建议**：硬编码在代码中

```csharp
internal static class TemplateFactory
{
    public static string GetArtifactTemplate(string docId, string title, string visitorName)
    {
        return $"""
        ---
        docId: "{docId}"
        title: "{title}"
        type: artifact
        generatedBy: "{visitorName}"
        generatedAt: "{DateTime.UtcNow:O}"
        ---
        """;
    }
}
```

**v1.0 扩展点**：
- 外部模板文件
- 用户自定义模板
- 模板继承机制

### 4. 如何让用户知道模板内容

**v0.1 建议**：通过 `--dry-run` 输出显示

```
$ docgraph validate --fix --dry-run

Would create 2 files:

┌─ docs/glossary.md ──────────────────────────────────┐
│ ---                                                 │
│ docId: "artifact/glossary"                          │
│ title: "Glossary"                                   │
│ type: artifact                                      │
│ generatedBy: "GlossaryVisitor"                      │
│ generatedAt: "2026-01-01T10:00:00Z"                 │
│ ---                                                 │
│                                                     │
│ <!-- Content will be generated by visitor -->       │
└─────────────────────────────────────────────────────┘

Run without --dry-run to create these files.
```

**体验优势**：
- 用户在执行前看到完整内容
- 无需查阅文档
- 建立对工具的信任

---

## 五、v0.1 具体实施建议

### 实施优先级矩阵

| 功能 | 优先级 | 工作量估计 | 理由 |
|:-----|:-------|:-----------|:-----|
| `--dry-run` 参数 | P0 | 0.5天 | 建立信任的基础 |
| 批量预览+确认 | P0 | 1天 | 核心交互模式 |
| `--yes` 自动确认 | P1 | 0.25天 | CI/CD 必需 |
| 部分成功支持 | P1 | 0.5天 | 错误韧性 |
| 详细错误信息 | P2 | 0.5天 | 可后续完善 |

### 第一天编码任务清单

```
□ 实现 ValidateCommand 基础结构
□ 添加 --fix 参数（触发修复流程）
□ 添加 --dry-run 参数（只预览不执行）
□ 添加 --yes 参数（跳过确认）
□ 实现批量预览输出格式
□ 实现简单确认提示（Y/n）
□ 实现基础模板生成
```

### CLI 参数完整设计

```bash
docgraph validate [path] [options]

Options:
  --fix              修复可自动修复的问题
  --dry-run          只显示会执行的操作，不实际执行
  --yes, -y          跳过确认提示，自动执行
  --output <format>  输出格式: human (默认), json
  --verbose, -v      详细输出
  --help, -h         显示帮助
```

### 交互流程设计

```
$ docgraph validate ./docs --fix

Scanning ./docs...
Found 3 files to create:
  • docs/glossary.md (GlossaryVisitor)
  • docs/issues.md (IssueAggregator)
  • docs/orphans.md (OrphanDetector)

Create these files? [Y/n] y

Creating files...
✓ docs/glossary.md
✓ docs/issues.md
✓ docs/orphans.md

Done. 3 files created.
```

---

## 六、设计原则回顾

本设计遵循以下体验设计原则：

1. **Error as Navigation**：错误信息提供恢复路径，而非死胡同
2. **Progressive Disclosure**：从简单到复杂，渐进披露能力
3. **Pit of Success**：默认行为是安全的（预览+确认）
4. **IntelliSense as UI**：参数设计支持命令行补全发现
5. **Trust Building**：`--dry-run` 让用户在执行前建立信任

---

以上是我从 UX/DX 角度的完整分析。核心建议是：

> **默认批量预览 + 必选 dry-run + 可选自动确认**

这个组合在 v0.1 简化原则下，提供了最佳的安全性和效率平衡。

期待 Seeker 和 Craftsman 的补充视角。

---

### Craftsman 发言

我从“v0.1 最小可行实现 + 安全第一 + 可测试性”三个维度，对 Curator 提出的交互/自动维护方案做技术可行性审计，并给出落地建议。

## 1) 实现复杂度评估与可行性结论

结论先行：Curator 的“批量预览 + `--dry-run` + `--yes` 自动确认”交互组合 **技术上可在 v0.1 落地**；但需要注意它与现有规范存在 3 处“接口/语义不一致”，若不先收敛，会在第一天编码时造成反复。

### 1.1 功能点复杂度（按 v0.1 约束评估）

| 功能点 | 复杂度 | 主要工作 | 关键风险点 |
|---|---:|---|---|
| `--fix` 开关（触发自动维护） | 低 | CLI 解析 + 分支执行 | 与 spec 的 `--write/--fix` 命名统一 |
| `--dry-run`（只预览不写入） | 中 | 需要“计划（Plan）”抽象：先算 actions 再选择执行/只输出 | 必须保证零写入副作用；输出可重复（幂等） |
| 批量预览输出（列出将创建的文件与模板摘要） | 中 | 渲染器（human）+ 排序稳定 | 终端宽度/换行不可控导致 snapshot 不稳定 |
| 单次确认（Y/n） | 低 | stdin 读取 + 默认值策略 | CI 场景 stdin 不可用时行为（应 fail-fast 或要求 `--yes`） |
| `--yes` 自动执行 | 低 | 跳过确认逻辑 | 必须与 `--dry-run` 冲突检查（`--yes` + `--dry-run` 允许，但无意义） |
| 部分成功（失败不阻塞其他） | 中 | per-action try/catch + 汇总结果 + exit code 策略 | 与 spec 的“写入失败 exit=3(Fatal)”条款如何兼容 |
| 模板硬编码（frontmatter 生成） | 低 | 常量字符串 + 字段填充 | 必须满足 spec 的必填字段（`docId/title/produce_by`） |

### 1.2 与现有设计文档（api.md/spec.md/scope.md）的兼容性

需要显式处理的兼容性差异（否则会出现“文档说 A、代码做 B”）：

1. **命令外观冲突**：
   - Curator：`docgraph validate --fix [--dry-run] [--yes]`
   - api.md 示例：`docgraph fix --write`
   - spec.md：写入模式需要 `--write` 或 `--fix`（二选一），且可提示确认。

   建议：v0.1 收敛为一个入口（`validate --fix`），并把 `fix` 作为 **alias** 或直接从 api.md 移除（v0.1 处于草案期，无兼容包袱）。

2. **模板字段不一致**：
   - spec.md [A-WRITE-001] 的极简模板必须包含：
     `docId`（文件名 stem）、`title: "待填写"`、`produce_by: ["source"]`
   - Curator 示例模板包含 `generatedBy/generatedAt/type`，但**缺失 `produce_by`**，且字段命名与规范不一致。

   建议：v0.1 先严格按 spec 模板落地（可选扩展字段留到 v1.0）；若要保留“机器生成声明”，建议放在正文注释或 `.gen.md` 生成物里，避免引入 frontmatter 新字段的二次 SSOT。

3. **“缺失 frontmatter”的语义可能与“不得修改现有文件”矛盾**：
   - scope.md 写的是“目标文件缺失 frontmatter 时按模板创建”。
   - spec.md [S-WRITE-003] 明确 **不得修改现有 frontmatter 内容**，并在“允许的操作”中写了“创建缺失的 frontmatter（全新文件）”。

   这会产生实现分叉：
   - A) 文件存在但无 frontmatter：要不要“注入 frontmatter”（必然改写文件）？
   - B) 仅当目标文件不存在时才创建新文件：那就不是“缺失 frontmatter”，而是“缺失文件”。

   建议：v0.1 选择最简单且与安全原则一致的可判定语义：
   - **只在目标文件不存在时创建新文件**（create-if-missing），并在报告中把“存在但无 frontmatter”作为 Error/Warning 仅提示；
   - 如确需支持“注入 frontmatter”，必须在 spec 增补条款，定义“正文保持不变、仅在文件首部插入 frontmatter”的原子写入与回滚语义（这会显著抬高 v0.1 复杂度）。

### 1.3 第一天编码任务可行性

在“只创建缺失文件（不注入 frontmatter）”的语义选择下，Curator 的 P0（dry-run + 批量预览 + 单次确认）**一天内可完成一个端到端闭环**：
- CLI 能扫描 → 产出计划 → dry-run 输出 → 去掉 dry-run 后写入 → 通过原子写入约束。

若坚持“文件存在但无 frontmatter 时自动注入”，第一天完成概率会显著下降（需要做：内容保留、插入位置规则、编码/换行风格、冲突检测、回滚测试）。

## 2) 技术风险识别与缓解策略

### 2.1 并发与线程安全

spec.md [R-PERF-005] 规定 v0.1 **MUST NOT 并发**，因此内部并发/线程安全风险可控。

仍需关注的“外部并发”是：用户/编辑器/其他进程同时改动文件。

缓解建议（低成本，提升鲁棒性）：
- 执行阶段对每个 action **再次 re-check 前置条件**（目标是否仍不存在/是否仍需要创建）。条件不满足则跳过并记录 Warning。
- 写入采用 `CreateNew` 语义（目标存在则失败），确保不会覆盖用户刚创建/刚改的文件。

### 2.2 文件系统原子性与一致性

spec.md [S-WRITE-001]/[S-WRITE-002] 要求原子替换与失败清理。

v0.1 建议采用 per-file 原子写入（无需跨文件事务）：
- temp 文件必须放在 **同目录**（保证 rename 原子性、跨盘失败概率更低）。
- 原子移动用不覆盖策略：目标存在则失败（与“不得污染现有文件”一致）。
- 失败时清理 temp，并把该 action 标记为 IO Fatal（但不必阻塞其他 action 的尝试）。

一致性风险：同一批次创建多个文件时，可能出现“部分成功”。
- 这是可接受的（符合 Curator 的部分成功叙事），但需要把“部分成功的退出码语义”写成可判定条款（见 §3）。

### 2.3 错误处理边界情况

建议把错误分成三层，便于实现与测试：
1. **Plan 阶段错误（可预测、可排序）**：路径越界、produce 指向非法路径、YAML parse error 等 → 归入 validate 的 errors/warnings（exit code 1/2）。
2. **Execute 阶段错误（IO/权限/锁）**：写入 temp 失败、move 失败 → 属于 Fatal（exit code 3）。
3. **用户交互错误**：stdin 不可用但未指定 `--yes` → 直接报错并退出（建议 exit code 3 或 2；我倾向 3：无法执行）。

### 2.4 跨平台兼容性

主要风险点来自路径与重命名语义：
- Windows 的路径分隔符与大小写不敏感；Linux/macOS 大小写敏感。
- 原子 rename 的保证通常成立，但跨卷移动不原子。

缓解建议（与 spec 一致、实现成本低）：
- 规范层面：继续要求关系字段统一用 `/`（spec [S-PATH-001]）。
- 实现层面：
  - 逻辑路径保持 `/`，仅在 IO 边界转换为平台分隔符。
  - temp 文件与目标文件放同目录，避免跨卷。
  - 不做 Unicode 规范化（v0.1 简化），但测试里覆盖非 ASCII 路径至少 1 个样例。

## 3) 与现有规范的协调：需要更新的文档与新增条款建议

### 3.1 需要更新的现有文档

1. **api.md**：
   - 收敛 CLI 外观：明确 `docgraph validate --fix [--dry-run] [--yes]` 为主路径。
   - 若保留 `docgraph fix`，需声明其是 `validate --fix` 的 alias（或 deprecated）。
   - 把 `--write` 与 `--fix` 的关系讲清楚（推荐只保留一个，避免重复开关）。

2. **spec.md**：
   - 在“写入策略约束”补齐 `--dry-run/--yes/交互确认` 的可判定语义。
   - 明确“缺失 frontmatter”的修复语义究竟是 create-if-missing 还是 inject-into-existing（建议 v0.1 选前者）。
   - 明确“部分成功”的退出码策略（与 api.md 的 0/1/2/3 对齐）。

3. **scope.md**：
   - 把“目标文件缺失 frontmatter 时按模板创建”改成可判定句：
     - v0.1：仅当目标文件不存在时创建；存在但无 frontmatter 只报告（或相反，需明确）。

### 3.2 建议新增/补强的条款（最小集）

（条款编号仅示意，实际可按现有分组落位）

- **[F-WRITE-DRYRUN-001] MUST**：`--dry-run` 模式不得产生任何文件系统写入（包括 `.tmp`）。
- **[F-WRITE-CONFIRM-001] MUST**：未指定 `--yes` 时，写入前必须进行一次批量确认；stdin 不可用则必须失败并提示使用 `--yes`。
- **[F-WRITE-PARTIAL-001] SHOULD**：批量写入允许部分成功；但若存在任一写入失败（IO），进程退出码必须为 3（Fatal），同时报告成功/失败清单。
- **[A-WRITE-TEMPLATE-001] MUST**：自动创建的 frontmatter 必须包含 `docId/title/produce_by`，且字段名与 schema 一致；允许附加扩展字段但 v0.1 默认不添加。

## 4) 具体技术实现方案（类/方法、错误码/退出码、测试与验收）

### 4.1 建议的最小类与数据结构

核心思想：把“算出要做什么（Plan）”与“真的去做（Execute）”分离，`--dry-run` 就是只跑 Plan + Render。

- `ValidateCommand`（CLI entry）
  - `ExecuteAsync(ValidateOptions options)`
  - 流程：Scan → BuildGraph → Validate →（若 `--fix`）BuildFixPlan → RenderPlan → Confirm → ExecutePlan

- `FixPlanner`
  - `FixPlan Build(DocumentGraph graph, ValidationResult validation)`
  - 输出 `FixPlan`：有序 actions 列表（稳定排序），每个 action 可渲染预览文本。

- `IFixAction`
  - `string TargetPath { get; }`
  - `string Describe()`（一行摘要）
  - `string Preview()`（可选，frontmatter 内容/摘要）
  - `FixActionResult Execute(IFileSystem fs)`

- `CreateArtifactFrontmatterAction : IFixAction`
  - 仅在“目标文件不存在”时创建新文件（v0.1 推荐语义）。
  - 生成内容严格按 [A-WRITE-001] 模板。

- `AtomicWriter`
  - `WriteNewFileAtomically(path, content)`：temp + flush + move；若目标存在则失败。
  - 这里是最需要单测的点（污染/清理/异常路径）。

为可测试性，建议引入非常薄的 `IFileSystem` 抽象（或用 .NET 的临时目录做集成测试），避免把 IO 与业务逻辑耦死。

### 4.2 错误码与退出码设计

建议保持与 api.md 的退出码表一致（0/1/2/3），把 `--fix` 的执行结果折算进去：
- `0`：无 warning，无 error，且（若执行写入）全部成功
- `1`：存在 warning（包括“跳过某个 action 因为前置条件变化”）但无 error，写入全成功
- `2`：validate 阶段存在 error（关系/字段错误），且未进行写入或写入被阻止
- `3`：发生 IO/config/无法交互等 Fatal（包括任何一次写入失败）

错误码方面：不要为“fix 过程”发明新体系，复用 `DOCGRAPH_IO_*` / `DOCGRAPH_PATH_*`，并在报告里加上 action context（target/source）。

### 4.3 测试策略与验收标准（可判定）

对 Curator 方案相关的最小验收集：

1. **Dry-run 零副作用**：运行 `validate --fix --dry-run` 后，目录树字节级不变（无新文件、无 tmp）。
2. **预览稳定性**：同一输入两次运行，plan 输出文本完全一致（排序稳定、时间戳不进入输出）。
3. **确认门禁**：不带 `--yes` 且 stdin 不可读时必须失败并提示；带 `--yes` 则不读 stdin。
4. **原子写入**：模拟写入异常时，目标文件不存在/不被污染，temp 被清理。
5. **部分成功语义**：一个文件可写、另一个权限拒绝：最终存在成功文件；退出码=3；报告包含 created/failed 列表。

实现手段建议：
- 单元测试覆盖 `FixPlanner`（输入 → actions 列表）与 `NormalizePath`。
- 集成测试在临时目录跑 CLI（或直接调用 command），用快照测试对比预览输出。

## 5) 对 Curator 方案的调整建议（实现/规范对齐视角）

1. **默认确认提示建议改为 `[y/N]`**：v0.1 “安全第一”下，回车即执行会更容易误触；`--yes` 已覆盖自动化场景。
2. **模板必须先对齐 spec**：v0.1 默认只写 `docId/title/produce_by`，不要引入 `generatedBy/generatedAt/type`（否则要同步更新 schema/示例/报告，成本不值）。
3. **CLI 外观需要一次性收敛**：推荐主入口 `validate --fix`，把 `fix --write` 从 api.md 示例中移除或改为 alias，避免第一天实现时出现两套解析/两套 help 文案。
4. **“缺失 frontmatter”的修复语义必须先定**：我推荐 v0.1 先做 create-if-missing；若要注入 frontmatter，应推迟到 v1.0（需要更重的回滚与内容保留测试）。

以上建议的目标不是推翻 Curator 的交互策略，而是把它变成“可判定、可测试、与现有 spec 不打架”的最小实现闭环。
---

### Seeker 发言

感谢 Curator 提出的完整交互设计方案，以及 Craftsman 从技术可行性角度进行的严谨审计。我从概念架构视角，分析两位方案与现有规范的一致性，并提出协调方案。

---

## 一、概念边界协调：命令语义的澄清

### 1.1 核心概念问题：`validate` 的语义边界

Craftsman 识别的"规范不一致"本质上是一个**概念边界问题**：`validate` 命令承载的语义是什么？

让我退一步看：在软件工具的心智模型中，存在两种典型命令范式：

| 范式 | 代表 | 语义特征 | 隐喻 |
|:-----|:-----|:---------|:-----|
| **纯观察** | `git status`、`ls` | 只读，零副作用 | 照镜子 |
| **检测+修复** | `eslint --fix`、`go fmt` | 检测为主，修复为参数 | 医生看诊 |

**关键洞见**：`validate --fix` 的概念定位是**"检测+修复"范式**——验证是核心能力，修复是参数化扩展。这与 Curator 的"验证是主操作，修复是副操作"叙事完全一致。

但现有规范条款有一个隐含假设需要显式化：

> **[S-DOCGRAPH-NO-WRITE-ON-FATAL]** 的前提是"validate 纯粹是验证"——它假设 validate 不产生写入，因此用 Fatal 作为"阻止写入"的信号。

当我们引入 `--fix` 后，这个假设被扩展了。需要重新定义：**Fatal 是阻止"修复写入"的门槛，还是阻止"所有后续步骤"的门槛？**

**我的概念建议**：Fatal 应该理解为**"数据完整性无法保证"的信号**——当出现 Fatal 时，不仅不应该写入修复，连验证报告的正确性都存疑。因此：

- `[S-DOCGRAPH-NO-WRITE-ON-FATAL]` 的条款语义可以保持不变
- 它对 `--fix` 的约束是：存在 Fatal 时，不进入修复执行阶段

### 1.2 dry-run 的概念定位

Curator 提出 dry-run 是"只看不做"，Craftsman 要求"零副作用"。从概念层面，我提出一个更精确的定义：

> **dry-run 是"计划可视化"（Plan Visualization）**——它展示的是"如果不带 dry-run 会发生什么"的可判定预测。

这意味着：
1. **dry-run 必须执行与正常路径相同的验证和计划生成**（否则预测不准）
2. **dry-run 的唯一差异是跳过"执行"阶段**
3. **dry-run 的输出应该可以作为"执行"阶段的输入**（概念上的对称性）

**与规范协调**：dry-run 不违反 `[A-DOCGRAPH-WRITE-EXPLICIT]`——它根本不触发写入代码路径。条款 `[F-WRITE-DRYRUN-001]` 的"不得产生任何文件系统写入"是**实现约束**，概念上应该表述为"dry-run 在 Plan 阶段终止，不进入 Execute 阶段"。

### 1.3 "--fix" 与 "--write" 的概念区分

Craftsman 发现 api.md 有 `--write`，Curator 方案用 `--fix`。这不是简单的命名问题，而是**意图表达的差异**：

| 参数 | 意图表达 | 隐喻 |
|:-----|:---------|:-----|
| `--write` | "允许写入文件系统" | 权限开关 |
| `--fix` | "修复发现的问题" | 动作意图 |

**概念建议**：两者不是替代关系，而是**层次关系**：
- `--fix` 表达用户意图："我想修复问题"
- `--write` 是实现层约束："允许写入操作"

在 v0.1 简化原则下，可以合并为一个参数。但如果未来有"修复但只输出到 stdout"的需求，分离会有价值。**v0.1 决策建议**：统一使用 `--fix`，内部视为同时激活"修复意图"和"写入权限"。

---

## 二、设计原则一致性分析

### 2.1 "v0.1 简化优先"原则

Curator 方案的复杂度评估：

| 功能 | 复杂度 | v0.1 必要性 | 理由 |
|:-----|:-------|:------------|:-----|
| `--fix` 基础功能 | 中 | **必要** | 核心用户价值 |
| `--dry-run` | 中 | **必要** | 建立信任的基础（Curator 论证充分）|
| `--yes` 自动确认 | 低 | **应有** | CI/CD 场景，实现简单 |
| 批量预览输出 | 中 | **应有** | 用户体验关键 |
| 部分成功 | 中 | **可选** | 增加复杂度，可简化为"全成功或报错" |

**我的建议**：v0.1 可以采用**更简化的错误策略**——遇到第一个写入错误即停止并报告。理由：
1. v0.1 的修复操作有限（只有创建缺失文件）
2. 部分成功的语义对用户来说不够直觉
3. 简化实现和测试

这与 Craftsman 的"部分成功"建议不同，但符合"v0.1 简化优先"原则。如果实现时发现"fail-fast"体验不好，可以在 v0.1.1 升级。

### 2.2 "安全第一"原则

三个规范条款的协调：

1. **`[S-DOCGRAPH-NO-WRITE-ON-FATAL]`**：当存在 Fatal 错误时，不得写入
2. **`[A-DOCGRAPH-WRITE-EXPLICIT]`**：写入需要显式开关
3. **`[S-DOCGRAPH-WRITE-ATOMIC]`**：原子写入

Curator 方案通过以下机制满足这些原则：
- **Fatal 门禁**：验证阶段的 Fatal 阻止进入修复流程 ✓
- **显式开关**：`--fix` 参数明确激活写入 ✓
- **用户确认**：默认需要确认，`--yes` 显式跳过 ✓
- **原子写入**：temp + rename 策略 ✓

**遗漏的安全考虑**：Craftsman 提到的"外部并发"问题——用户/编辑器在执行过程中修改文件。建议增补条款：

> **[S-DOCGRAPH-FIX-PRECONDITION-RECHECK]** SHOULD：执行每个修复 action 前，重新检查前置条件（如目标文件是否仍不存在）；条件不满足则跳过并警告。

### 2.3 "用户体验一致"原则

Curator 的设计符合生态习惯（eslint、prettier、go fmt 的 `--fix` 模式）。但有一个概念不一致点需要关注：

**默认确认行为**：Curator 建议 `[Y/n]`（默认执行），Craftsman 建议 `[y/N]`（默认不执行）。

从**概念一致性**看，这取决于我们如何定位 `validate --fix`：
- 如果是"日常维护工具"→ `[Y/n]` 更流畅
- 如果是"危险操作工具"→ `[y/N]` 更安全

**我的判断**：v0.1 的 `--fix` 只做"创建缺失文件"，不修改现有文件。这是**追加操作**，风险较低。因此 `[Y/n]` 是合理的。但可以加一条：

> **[A-DOCGRAPH-FIX-CONFIRM-DEFAULT]** SHOULD：当 `--fix` 会创建超过 N 个文件（v0.1 建议 N=5）时，确认提示应改为 `[y/N]`（默认不执行）。

这样在大规模操作时自动升级安全级别。

---

## 三、架构演进建议

### 3.1 v0.1 与 v1.0 的概念连续性

当前设计需要为以下 v1.0 功能预留概念空间：

| v1.0 可能功能 | 概念预留 | v0.1 影响 |
|:-------------|:---------|:----------|
| 修复类型细分（frontmatter/links/all） | `--fix-type` 参数 | `--fix` 应等价于 `--fix-type=all` |
| 注入 frontmatter 到现有文件 | 区分"create"和"inject" | v0.1 明确只做"create"，为"inject"留概念空位 |
| 交互式逐个确认 | `--interactive` 参数 | v0.1 的批量确认是这个的简化形式 |
| 自定义模板 | `.docgraph/templates/` 约定 | v0.1 硬编码模板，但模板生成逻辑应可扩展 |

**概念演进路径建议**：

```
v0.1: validate [--fix [--dry-run] [--yes]]
       │
       │  只支持 create-if-missing
       │
v0.2: validate [--fix [--fix-type=...] [--dry-run] [--yes]]
       │
       │  增加 inject-frontmatter 类型
       │
v1.0: validate [--fix [...]] | fix [subcommand]
       │
       │  独立 fix 命令承载复杂修复场景
```

### 3.2 扩展点的预留设计

Craftsman 的 `IFixAction` 接口设计是正确的扩展点。从概念层面，我建议这个接口的核心方法应该反映"Plan-Execute 分离"：

```
IFixAction
├── CanExecute(context) : bool     // 前置条件检查
├── Describe() : string            // 人类可读描述（用于预览）
├── Preview() : string             // 详细预览（用于 dry-run）
└── Execute(fs) : Result           // 实际执行
```

这样的接口既支持 v0.1 的简单实现，又为 v1.0 的复杂修复类型（如 inject-frontmatter、link-repair）提供统一抽象。

### 3.3 向后兼容性考虑

由于 v0.1 是首版，没有向后兼容负担。但应该为**概念向后兼容**建立基础：

1. **退出码语义应该稳定**：0/1/2/3 的含义一旦定义，后续版本不应改变
2. **参数语义应该单调扩展**：`--fix` 的含义只会变得更丰富，不会收窄
3. **默认行为应该趋向保守**：如果要改变默认行为，使用 `--new-behavior` 而非改变 `--fix` 的默认

---

## 四、规范更新建议

基于以上分析，我建议对现有规范做以下更新：

### 4.1 需要修改的条款

1. **`[A-DOCGRAPH-WRITE-EXPLICIT]`** — 扩展描述：
   ```diff
   - MUST：任何会修改工作区文件的行为必须在显式开关（如 `--write`）开启时才允许。
   + MUST：任何会修改工作区文件的行为必须在显式开关（`--fix`）开启时才允许。
   +       `--fix` 同时表达"修复意图"和"写入权限"。
   ```

2. **`[S-DOCGRAPH-NO-WRITE-ON-FATAL]`** — 明确与 `--fix` 的交互：
   ```diff
   - MUST：当存在 Fatal 错误时，除报告外不得写入/覆盖任何派生文件。
   + MUST：当验证阶段存在 Fatal 错误时，不得进入修复执行阶段。
   +       即使指定了 `--fix`，Fatal 也会阻止修复操作。
   ```

### 4.2 需要新增的条款

1. **`[A-DOCGRAPH-FIX-DRYRUN]`** MUST：`--dry-run` 模式执行完整的验证和计划生成，但在 Execute 阶段前终止；不得产生任何文件系统副作用。

2. **`[A-DOCGRAPH-FIX-CONFIRM]`** MUST：未指定 `--yes` 时，修复执行前必须显示批量预览并获得用户确认；stdin 不可用时必须报错并提示使用 `--yes`。

3. **`[S-DOCGRAPH-FIX-SCOPE-V01]`** MUST（v0.1 限定）：修复功能仅支持"创建缺失的产物文件"；不得修改现有文件内容。

4. **`[A-DOCGRAPH-EXITCODE-FIX]`** MUST：`--fix` 模式的退出码语义扩展：
   - 0：验证通过 + 修复全部成功（或无需修复）
   - 1：验证有警告 + 修复成功
   - 2：验证有错误，未执行修复
   - 3：验证 Fatal 或修复执行失败

### 4.3 概念术语补充

在术语表中增加：

- **Fix Plan（修复计划）**：`--fix` 模式下生成的待执行操作列表，包含每个 action 的目标路径、操作类型、预览内容
- **Fix Action（修复操作）**：修复计划中的单个可执行单元，如"创建文件 X"
- **Plan-Execute 分离**：将"计算需要做什么"与"实际执行"分离的架构模式，支持 dry-run 和用户确认

---

## 五、整合建议

### 5.1 对 Curator 方案的支持

Curator 的交互设计在概念层面是**健全的**：
- 批量预览 + dry-run + 自动确认的组合符合"渐进披露"原则
- `validate --fix` 的命令结构符合生态惯例
- "Error as Navigation" 的错误设计理念与我们的 Agent 友好目标一致

**我支持 Curator 的核心设计**，只建议一处调整：考虑在大规模操作时自动升级确认安全级别。

### 5.2 对 Craftsman 方案的整合

Craftsman 的技术可行性分析非常严谨，尤其是三个"不一致点"的识别。我的整合建议：

1. **规范不一致**：通过上述条款更新解决
2. **实现分叉风险**：采用 Craftsman 建议的"create-if-missing"语义（v0.1），将"inject-frontmatter"推迟到 v1.0
3. **退出码策略**：采用 `[A-DOCGRAPH-EXITCODE-FIX]` 明确定义

### 5.3 剩余待决策项

本次讨论后，仍有一项需要主持人决策：

**部分成功策略**：
- 选项 A（Craftsman）：支持部分成功，失败不阻塞其他文件
- 选项 B（我的简化建议）：fail-fast，遇首错即停

两个选项都有合理性。如果选择 A，需要额外的测试覆盖；如果选择 B，用户体验可能在某些场景下不够友好。

**我的倾向**：v0.1 选择 B（fail-fast），如果用户反馈不好，v0.1.1 升级为 A。这样可以用最小实现成本验证核心功能，再根据实际反馈决定是否增加复杂度。

---

以上是我从概念架构角度的协调分析。核心结论是：

> **Curator 和 Craftsman 的方案在概念层面是兼容的**，只需要通过规范条款的更新来显式化隐含假设、统一术语、明确边界。

---

### 主持人整合与决策 (刘德智)

感谢Seeker、Curator、Craftsman三位专家的深入分析！经过畅谈会，我们成功解决了todo.md中的**问题1：自动维护的交互模式**，并达成了高度共识。

## 【畅谈会成果总结】

### ✅ 问题1：自动维护的交互模式 - 已解决

#### 最终决策方案

**CLI命令设计**：
```bash
# 基础验证
docgraph validate [path]

# 验证并修复（批量预览模式）
docgraph validate --fix [path]

# 只预览不执行
docgraph validate --fix --dry-run [path]

# 自动执行（CI/CD场景）
docgraph validate --fix --yes [path]
```

**核心设计原则**：
1. **渐进式信任**：dry-run → 批量预览 → 自动确认
2. **安全第一**：默认需要确认，大规模操作自动升级安全级别
3. **简化优先**：v0.1只支持"创建缺失文件"，不修改现有文件

#### 技术实现方案

**修复操作语义**：
- **v0.1范围**：仅支持"create-if-missing"（创建缺失的产物文件）
- **前置条件**：目标文件不存在，且源文档有合法的produce关系
- **模板内容**：硬编码模板，包含docId、title、type: artifact等字段

**错误处理策略**：
- **采用fail-fast**：v0.1简化实现，遇首错即停
- **退出码扩展**：新增`[A-DOCGRAPH-EXITCODE-FIX]`条款
- **错误信息**：遵循"Error as Navigation"原则，提供三层建议

#### 规范更新需求

**需要修改的条款**：
1. `[A-DOCGRAPH-WRITE-EXPLICIT]`：明确`--fix`同时表达"修复意图"和"写入权限"
2. `[S-DOCGRAPH-NO-WRITE-ON-FATAL]`：明确Fatal错误阻止修复执行

**需要新增的条款**：
1. `[A-DOCGRAPH-FIX-DRYRUN]`：dry-run模式定义
2. `[A-DOCGRAPH-FIX-CONFIRM]`：确认机制要求
3. `[S-DOCGRAPH-FIX-SCOPE-V01]`：v0.1修复范围限定
4. `[A-DOCGRAPH-EXITCODE-FIX]`：修复模式退出码语义

### 🔄 问题5：路径规范化边界情况 - 部分解决

基于时间考虑，我们决定：
1. **v0.1简化处理**：基本路径规范化（消解`.`/`..`，统一分隔符）
2. **边界情况**：遇到非常规路径时记录警告，继续处理
3. **v1.0完善**：完整的Unicode、符号链接、混合分隔符处理

## 【立即行动项】

### 1. 更新规范文档

需要立即更新以下文档：

#### spec.md更新
- 添加4个新条款（见上文）
- 修改2个现有条款
- 补充概念术语（Fix Plan, Fix Action, Plan-Execute分离）

#### api.md更新  
- 扩展`IDocumentGraphBuilder.Validate()`方法说明
- 添加`--fix`相关参数说明
- 补充错误码定义

### 2. 创建实施任务清单

**第一天编码任务（P0）**：
```
□ 实现 ValidateCommand 基础结构
□ 添加 --fix 参数解析和处理
□ 添加 --dry-run 参数实现
□ 添加 --yes 参数实现
□ 实现批量预览输出格式
□ 实现简单确认提示（Y/n）
□ 实现基础模板生成（create-if-missing）
□ 添加相关错误码定义
```

**第二天编码任务（P1）**：
```
□ 实现完整的错误处理（三层建议结构）
□ 添加大规模操作安全升级逻辑（>5文件时[y/N]）
□ 编写核心功能测试
□ 更新用户文档
```

### 3. 产出具体代码框架

基于Craftsman的建议，创建以下接口设计：

```csharp
// 修复操作接口（v0.1简化版）
public interface IFixAction
{
    bool CanExecute(FixContext context);
    string Describe();
    string Preview();  // dry-run使用
    FixResult Execute(IFileSystem fs);
}

// 修复上下文
public class FixContext
{
    public DocumentGraph Graph { get; }
    public ValidationResult Validation { get; }
    public bool IsDryRun { get; }
    public bool AutoConfirm { get; }
}

// 创建缺失文件的具体实现
public class CreateMissingFileAction : IFixAction
{
    private readonly string targetPath;
    private readonly string sourceDocId;
    
    public bool CanExecute(FixContext context)
    {
        return !File.Exists(targetPath) && 
               context.Graph.ByPath.ContainsKey(sourceDocId);
    }
    
    public string Describe() => $"创建缺失文件: {targetPath}";
    
    public string Preview() => $"将创建文件: {targetPath}\n模板内容: ...";
    
    public FixResult Execute(IFileSystem fs)
    {
        var template = GenerateTemplate(targetPath, sourceDocId);
        fs.WriteAllText(targetPath, template);
        return FixResult.Success();
    }
}
```

## 【畅谈会价值体现】

### 1. "边商讨边实施"再次验证成功
- **实时协作**：三位专家从不同视角同步分析
- **快速决策**：复杂问题在单次畅谈会中解决
- **矛盾协调**：发现并解决了规范不一致问题
- **成果具体**：产出可立即实施的完整方案

### 2. 设计质量显著提升
- **从模糊到清晰**：todo.md的模糊问题 → 具体的CLI设计和实现方案
- **从矛盾到一致**：协调了UX方案与技术规范的矛盾
- **从概念到代码**：抽象设计 → 具体的接口和类设计

### 3. 为立即编码扫清障碍
- **规范明确**：知道需要更新哪些条款
- **任务清晰**：有具体的编码任务清单
- **接口设计**：有具体的类和方法设计
- **优先级明确**：知道第一天做什么、第二天做什么

## 【下一步建议】

### 立即开始实施
基于本次畅谈会的成果，团队可以：

1. **立即更新规范文档**（spec.md、api.md）
2. **立即开始第一天编码任务**
3. **基于代码框架快速实现核心功能**

### 持续跟踪剩余问题
todo.md中还有6个问题，建议：
- **问题2-4、6-7**：优先级较低，可在实施过程中逐步解决
- **问题5**：已部分解决，v1.0完善

### 建立反馈循环
- 实施过程中如发现问题，及时记录
- 保持设计与实现的一致性
- 为v1.0规划收集实际使用反馈

---

**本次畅谈会目标已全部达成！** 我们成功解决了最关键的实施前问题，为立即开始v0.1编码扫清了障碍。团队现在拥有清晰的设计方案和具体的实施任务，可以立即开始编码工作。

期待主持人的决策和后续实施。