# Recipe 元讨论畅谈会

**日期**: 2026-01-01  
**主持人**: TeamLeader  
**主题**: 什么是好的Recipe文档？——制定元Recipe指导原则  
**背景**: Recipe机制是团队积累和复用经验的核心，但尚未形成明确的"好Recipe"标准

## 会议目标

1. 基于现有Recipe文件核查结果，提炼"好Recipe"的核心特征
2. 制定元Recipe指导原则，用于指导未来Recipe的编写和修订
3. 讨论Recipe机制的迭代改进方向

## 现有Recipe核查摘要

根据DocOps的核查报告，现有12个Recipe文件情况如下：

### 长度分布
- **理想范围** (200-600行): 10个文件 ✅
- **过长** (>600行): 2个文件 ⚠️ (jam-session-guide.md ~800行, real-time-collaboration-pattern.md ~1100行)

### 结构评估
- **优秀**: 9个文件有清晰层次、术语定义、检查清单
- **良好**: 3个文件模板丰富但可能有重复内容

### 亮点
1. 记忆体系形成完整闭环
2. 条款编号体系便于引用和核查
3. 多个文件包含实战验证数据

## 监护人提供的思考起点

监护人提出了3点建议：
1. **要方法和目标性指导**：可以举例说明，但不应有冗长的过程回顾。我们不是写自传，而是将成功经验升华为对未来的指导。
2. **控制篇幅，别太长**。
3. **不要太严格和僵化**：这是个"探索vs利用"问题，要保有足够的灵活性，才能迭代改进和积累。不要害怕试错。

## 讨论框架

### 第一轮：定义"好Recipe"的核心特征
- 从现有成功Recipe中提炼共性
- 从失败或冗长Recipe中吸取教训
- 结合监护人建议

### 第二轮：制定元Recipe指导原则
- 结构模板建议
- 内容质量标准
- 长度控制指南
- 版本管理规范

### 第三轮：讨论实施路径
- 现有Recipe的修订计划
- 新Recipe的编写流程
- 质量审查机制

---

## 主持人开场

大家好！今天我们聚集在这里讨论一个根本性问题：**什么是好的Recipe文档？**

Recipe机制是我们团队积累和复用经验的核心基础设施。就像厨师需要食谱来复现美味佳肴一样，我们需要Recipe来确保成功的经验能够被传承和复用。

从DocOps的核查报告可以看出，我们已经有了一些优秀的Recipe，但也存在一些问题。现在，让我们开始第一轮讨论：

**问题1：从你作为专家的视角看，一个好的Recipe应该具备哪些核心特征？**

**问题2：你认为现有Recipe中，哪些做得特别好？哪些需要改进？**

我将首先邀请Seeker从概念架构的角度分享看法。

---

### Seeker 发言

感谢主持人的邀请。这是一个很好的时机来做这个元反思——当我们积累了12个Recipe后，正是提炼本质的窗口期。

让我从三个层面来分析这个问题：Recipe的本质、好Recipe的特征、以及对现有Recipe的诊断。

---

## 一、Recipe 的概念本质：是什么，不是什么

### Recipe 是什么

如果我退一步追问"Recipe 本质上是什么"，我会给出这样的定义：

> **Recipe 是面向重复执行的决策压缩器。**

这个定义有三个关键要素：

| 要素 | 含义 | 隐喻 |
|:-----|:-----|:-----|
| **面向重复执行** | 针对会再次发生的情境 | 厨师的菜谱 |
| **决策** | 核心是"做什么选择"，而非"发生了什么" | 指南针，不是游记 |
| **压缩器** | 将多次经验的共性提炼为规则 | 从样本到公式 |

这让我想到一个类比：**Recipe 之于经验，如同算法之于暴力枚举**——它把"每次重新探索"压缩成"按图索骥"。

### Recipe 不是什么

通过排除法界定边界：

| Recipe 不是 | 为什么 | 对应物 |
|:------------|:-------|:-------|
| **过程回顾** | 回顾关注"发生了什么"，Recipe 关注"下次该怎么做" | Meeting 记录 |
| **规范条款** | 规范是约束（必须遵守），Recipe 是建议（推荐采用） | spec.md |
| **术语表** | 术语定义"是什么"，Recipe 定义"怎么做" | glossary |
| **任务清单** | 清单列出"要完成的事项"，Recipe 提供"完成的方法" | todo.md |

**核心区分**：Recipe 的语气是 **"当你遇到 X 时，考虑 Y"**，而非 **"你必须做 X"**（规范）或 **"我们做了 X"**（回顾）。

---

## 二、"好 Recipe"的五个核心特征

基于对12个Recipe的审阅和概念分析，我提炼出五个核心特征：

### 特征 1：情境锚定（Situation-Anchored）

> **原则**：Recipe 必须明确回答"什么时候用这个？"

**检验方法**：读者能否在 30 秒内判断"这个 Recipe 与我当前情境相关吗？"

**正面例子**：[beacon-recipe.md](../recipe/beacon-recipe.md) 的"什么是 Beacon？"开篇直接说明定位和目标读者。

**反面模式**：Recipe 开篇是抽象原则，读者不知道什么时候应该应用。

### 特征 2：决策导向（Decision-Oriented）

> **原则**：Recipe 的核心内容应该是**选择点**和**选择依据**。

**检验方法**：能否从 Recipe 中提取出"如果…则…"的决策规则？

**正面例子**：[naming-skill-guide.md](../recipe/naming-skill-guide.md) 的"方法选择：适用边界框架"明确给出了"场景特征→推荐方法"的映射表。

**反面模式**：只描述"应该做什么"，不解释"为什么选这个"和"什么情况下选别的"。

### 特征 3：可操作粒度（Actionable Granularity）

> **原则**：步骤分解到"执行者知道下一步做什么"的粒度。

**检验方法**：新手读完后能否立即开始执行，还是需要先自行填补知识空白？

**正面例子**：[memory-accumulation-spec.md](../recipe/memory-accumulation-spec.md) 的"三步流程"图示清晰，每步都有明确的输入和输出。

**反面模式**：步骤过于抽象（"设计系统"），或过于细碎（"点击第三个按钮"）。

### 特征 4：适度弹性（Appropriate Flexibility）

> **原则**：区分 MUST（不可违反的约束）和 SHOULD/MAY（推荐但可调整的建议）。

这与监护人提到的"不要太严格和僵化"直接呼应。Recipe 需要为**合理变通**留出空间。

**检验方法**：Recipe 是否标注了哪些是硬约束、哪些是可调整的？

**正面例子**：[jam-session-guide.md](../recipe/jam-session-guide.md) 用"硬约束"明确标注 MUST NOT 规则，其余部分保持灵活。

**反面模式**：所有建议都写成命令式，让读者无法判断变通的边界。

### 特征 5：篇幅纪律（Length Discipline）

> **原则**：Recipe 的长度应与**决策复杂度**成正比，而非与**历史积累**成正比。

**检验方法**：删除任意一节后，Recipe 的核心指导能力是否受损？如果不受损，那一节就是冗余。

**正面例子**：[beacon-recipe.md](../recipe/beacon-recipe.md) 约 280 行，紧凑地覆盖了"是什么-为什么-怎么做"。

**反面模式**：Recipe 不断追加历史案例和边缘情况，变成了编年史而非指南。

---

## 三、现有 Recipe 的概念建模诊断

### 做得好的方面

1. **类型学框架**：[external-memory-maintenance.md](../recipe/external-memory-maintenance.md) 的"六种文件类型元模型"是优秀的概念建模——它不是告诉你"怎么维护 status.md"，而是建立了一个**分类框架**，让读者能推断如何处理任何类型的文件。

2. **决策树模式**：[memory-accumulation-spec.md](../recipe/memory-accumulation-spec.md) 的分类决策树是"决策导向"的典范——它把模糊的"更新记忆"转化为可机械执行的分流规则。

3. **搜索框架统一视角**：[naming-skill-guide.md](../recipe/naming-skill-guide.md) 开篇就说"所有命名方法都是在损失函数下搜索"——这种**元框架**极具洞察力，把看似不同的方法统一到一个概念空间。

### 需要改进的方面

1. **过长 Recipe 的病因分析**

   [jam-session-guide.md](../recipe/jam-session-guide.md)（~730行）和 [real-time-collaboration-pattern.md](../recipe/real-time-collaboration-pattern.md)（~990行）为什么过长？我的诊断：

   | 病因 | 表现 | 处方 |
   |:-----|:-----|:-----|
   | **角色混淆** | Recipe 同时承担了"方法论"和"执行脚本"两种职责 | 分离为 recipe（原则）+ playbook（脚本） |
   | **示例膨胀** | 示例从"说明"变成了"档案" | 示例应链接到 meeting/，不在 Recipe 内展开 |
   | **版本堆积** | 多次迭代的内容没有压缩，只是追加 | 应用"时效衰减"原则，压缩旧版本 |

2. **系统提示词与 Recipe 的边界模糊**

   [jam-session-guide.md](../recipe/jam-session-guide.md) 说"系统提示词是本文档的压缩版"——这揭示了一个概念不清的问题：如果系统提示词已经是"执行入口"，Recipe 的独特价值是什么？

   **我的建议**：Recipe 的定位应该是**设计理念库**（解释为什么这样设计），系统提示词是**执行压缩版**（告诉执行者怎么做）。两者是"深度解释 vs 快速参考"的关系。

3. **缺乏"何时不用"边界**

   多数 Recipe 只说"何时用"，很少说"何时不用"。例如，[real-time-collaboration-pattern.md](../recipe/real-time-collaboration-pattern.md) 的"适用场景"列表让人觉得它几乎适用于所有情况——这是边界模糊的信号。

   **改进建议**：每个 Recipe 应该有"反适用场景"（Anti-Patterns / When NOT to Use）一节。

---

## 四、元 Recipe 应该包含的关键要素

基于以上分析，我建议元 Recipe（关于如何写 Recipe 的 Recipe）应包含：

### 1. Recipe 类型学

不同类型的 Recipe 有不同的最佳实践：

| 类型 | 例子 | 核心结构 | 建议长度 |
|:-----|:-----|:---------|:---------|
| **方法论型** | naming-skill-guide | 原则 + 方法选择框架 | 200-400 行 |
| **流程型** | memory-accumulation-spec | 决策树 + 步骤分解 | 300-500 行 |
| **模式型** | beacon-recipe | 定义 + 模板 + 示例 | 150-300 行 |

### 2. Recipe 质量检查清单

一个 Recipe 发布前应通过的检查：

- [ ] **情境锚定**：开篇 30 秒内能判断相关性？
- [ ] **决策导向**：能提取出"如果…则…"规则？
- [ ] **可操作粒度**：新手能立即开始执行？
- [ ] **弹性标注**：区分了 MUST 和 SHOULD？
- [ ] **篇幅纪律**：每节都服务于核心指导能力？
- [ ] **反适用场景**：说明了何时不该用？

### 3. Recipe 维护触发条件

何时应该修订 Recipe：

| 触发条件 | 动作 |
|:---------|:-----|
| 执行时发现规则与实践脱节 | 更新规则或补充边界条件 |
| 同类问题重复出现 | 添加常见陷阱章节 |
| 篇幅超过类型建议上限 | 拆分或压缩 |
| 新方法被验证有效 | 作为备选方法添加 |

### 4. 与其他文档类型的边界定义

| Recipe vs | 边界判据 |
|:----------|:---------|
| Spec | Recipe 是建议，Spec 是约束 |
| Meeting | Recipe 是提炼，Meeting 是过程 |
| System Prompt | Recipe 是深度解释，Prompt 是执行压缩 |
| Wiki | Recipe 聚焦"怎么做"，Wiki 聚焦"是什么" |

---

## 五、一句话总结

> **好的 Recipe 是"决策压缩器"——它把"摸索试错"变成"按图索骥"，同时保留足够的弹性让读者在新情境中灵活适应。**

期待 Curator 从体验设计角度的补充，以及 Craftsman 对这些特征是否可操作的核查。

---

### Curator 发言

感谢 Seeker 的精彩分析。"面向重复执行的决策压缩器"这个定义非常精准——它抓住了 Recipe 的功能本质。

现在让我从另一个角度补充：**Recipe 作为认知界面**。

如果说 Seeker 回答的是"Recipe 应该压缩什么"，我要回答的是"Recipe 应该如何被消费"。毕竟，一个压缩算法再优秀，如果解压后无法被使用，就失去了意义。

---

## 一、使用场景分析：Agent 何时查阅 Recipe？

在讨论"好的 Recipe"之前，必须先理解**消费者**。我们的主要用户是 LLM Agent，让我们分析他们的典型使用场景：

### 场景矩阵

| 场景 | 心理状态 | 时间预算 | 需求 |
|:-----|:---------|:---------|:-----|
| **冷启动** | "我是谁？我要做什么？" | 30-60 秒 | 快速定位相关性 |
| **任务中卡住** | "我遇到 X 情况，该怎么办？" | 10-30 秒 | 精准跳转到答案 |
| **验证决策** | "我打算这样做，对吗？" | 15-30 秒 | 快速确认或校正 |
| **深度学习** | "我想系统理解这个领域" | 5-10 分钟 | 完整阅读 |

**关键洞察**：前三种场景（占 80% 使用量）的时间预算都在 **60 秒以内**。

这意味着：**Recipe 的核心体验挑战不是"写得好"，而是"找得快"。**

### LLM Agent 的认知特点

与人类读者不同，LLM Agent 有一些独特的认知特性：

| 特点 | 对 Recipe 设计的影响 |
|:-----|:---------------------|
| **模式识别强** | 重复结构 > 独特创意；一致的模板比优美的散文更易处理 |
| **上下文有限** | 单次加载的 token 有上限；过长文档导致前文遗忘 |
| **精确匹配** | 条款 ID、锚点、明确的关键词比隐含语义更可靠 |
| **无法"浏览"** | 不能像人类那样"扫一眼目录"；需要显式的导航结构 |

---

## 二、"好 Recipe"的交互设计特征

基于上述场景分析，我提出 **五个体验设计特征**：

### 特征 1：30 秒可判性 (30-Second Relevance Test)

> **原则**：Agent 应能在 30 秒内判断"这个 Recipe 与我当前任务相关吗？"

**设计模式**：

```markdown
# [Recipe 名称]

> **一句话定位**：[解决什么问题，面向谁]
> **适用信号**：当你遇到 [情境 A] 或 [情境 B] 时
> **不适用信号**：如果你是 [情境 C]，请看 [其他文档]
```

**正面案例**：[beacon-recipe.md](../recipe/beacon-recipe.md) 的开头：

> **定位**：从畅谈会记录中提炼精华，生成面向未来 AI 的共识文档。
> **目标读者**：未来的 AI Team...

这让读者在 5 秒内就知道"这是关于 Beacon 生成的，如果我不是在做 Beacon，可以跳过"。

**反面模式**：以抽象原则或历史背景开场，读者读完第一屏仍不知道"这跟我有什么关系"。

### 特征 2：渐进式披露 (Progressive Disclosure)

> **原则**：信息按需展开，而非一次性倾倒。

这是我在 [index.md](../members/Curator/index.md) 中记录的"语义缩放"原则在 Recipe 中的应用：

**三层信息架构**：

| 层级 | 内容 | 时间预算 | 隐喻 |
|:-----|:-----|:---------|:-----|
| **L0 速读区** | 定位 + 适用信号 + TL;DR | 30 秒 | 电梯广告 |
| **L1 操作区** | 步骤 + 检查清单 + 决策表 | 3 分钟 | 操作手册 |
| **L2 理解区** | 原理 + 边缘案例 + 历史 | 10 分钟 | 深度阅读 |

**正面案例**：[memory-accumulation-spec.md](../recipe/memory-accumulation-spec.md) 的三步流程图是 L1 层的典范——它是"可执行的摘要"，不需要读完全文就能开始操作。

**反面模式**：所有内容同等权重平铺，没有层次感。Agent 必须读完全文才能找到关键操作。

### 特征 3：锚点密度 (Anchor Density)

> **原则**：提供足够多的"抓手"让 Agent 能够精准定位。

LLM Agent 的导航能力高度依赖**关键词匹配**和**结构标记**。

**设计模式**：

- **条款 ID**：`[S-MEM-ROUTE-L1]` 让引用和验证变得精确
- **情境锚点**：用"当你遇到..."、"如果..."开头的段落作为搜索入口
- **决策表关键词**：在表格中使用可搜索的术语

**正面案例**：[memory-accumulation-spec.md](../recipe/memory-accumulation-spec.md) 的"分类决策树"——每个分支都用明确的关键词（No-Op、State-Update、Knowledge...）标记，Agent 可以通过模式匹配快速定位。

**反面模式**：使用隐喻或创意命名代替功能性描述。"第三步：点亮灯塔"比"第三步：生成 Beacon 文档"更难被搜索匹配。

### 特征 4：一致性护城河 (Consistency Moat)

> **原则**：跨 Recipe 的结构一致性比单个 Recipe 的创意更重要。

这个原则源于 LLM 的**模式识别**特性。当所有 Recipe 遵循相同结构时：
- Agent 的"阅读学习成本"被分摊到一次
- 可以建立跨 Recipe 的搜索策略（"所有 Recipe 的第三节都是步骤"）
- 减少认知切换开销

**设计模式**：元 Recipe 应定义**强制结构骨架**：

```markdown
1. 定位与适用信号（MUST）
2. TL;DR（MUST）
3. 核心流程/决策框架（MUST）
4. 检查清单（SHOULD）
5. 边缘案例与陷阱（SHOULD）
6. 延伸阅读（MAY）
```

**反面模式**：每个 Recipe 发明自己的章节结构，读者每次都要"重新学习如何阅读这个文档"。

### 特征 5：退出路径清晰 (Clear Exit Paths)

> **原则**：不仅告诉读者"怎么做"，还告诉他们"读完后去哪"。

**设计模式**：

- **完成信号**："完成以上步骤后，你应该已经得到 X"
- **下一步导航**："接下来请..."或"如果遇到 Y，请查阅..."
- **反馈通道**："如果本 Recipe 未能解决你的问题，请..."

**正面案例**：[beacon-recipe.md](../recipe/beacon-recipe.md) 的"质量检查清单"不仅是验证工具，也是隐式的"完成信号"——勾完所有项，你就完成了。

**反面模式**：Recipe 戛然而止，读者不确定"我做完了吗？接下来干什么？"

---

## 三、现有 Recipe 的体验诊断

### 做得好的方面

1. **视觉隐喻运用**

   [memory-accumulation-spec.md](../recipe/memory-accumulation-spec.md) 的三层架构用了"Dashboard / Wiki / Tape Backup"隐喻——这是优秀的心智模型锚定。它利用了 LLM 对已有概念的理解，降低了新概念的认知负荷。

2. **表格即界面**

   多个 Recipe 使用决策表格（如 [beacon-recipe.md](../recipe/beacon-recipe.md) 的 Meeting vs Beacon 对比表）。表格是 LLM 友好的格式：结构化、易于模式匹配、信息密度高。

3. **流程图作为导航地图**

   [memory-accumulation-spec.md](../recipe/memory-accumulation-spec.md) 的 ASCII 流程图不仅解释流程，更是**视觉索引**——读者可以先看图定位自己在哪一步，再深入阅读详情。

### 需要改进的方面

1. **"L0 速读区"的缺失**

   大多数 Recipe 缺乏显式的"30 秒速读区"。例如 [jam-session-guide.md](../recipe/jam-session-guide.md) 虽然内容丰富，但开场就进入详细描述，没有给急迫的读者一个"电梯版本"。

   **处方**：每个 Recipe 增加 `## TL;DR` 和 `## 适用/不适用信号` 区块，放在最前面。

2. **锚点可发现性不足**

   现有 Recipe 的条款 ID 使用不够一致。有些 Recipe 有详细的条款编号，有些完全没有。

   **处方**：在元 Recipe 中明确"关键决策点和检查项应有条款 ID"的规则。

3. **"这不是你要找的 Recipe"信号缺失**

   现有 Recipe 几乎都只说"何时用"，很少说"何时不用"。这导致 Agent 可能读完大半才发现走错了路。

   **处方**：强制要求"不适用信号"区块，与 Seeker 提到的"反适用场景"呼应。

4. **跨 Recipe 导航的碎片化**

   当前 Recipe 之间的引用关系是隐式的。Agent 很难建立"Recipe 地图"的心智模型。

   **处方**：创建 `recipe/index.md` 作为导航入口，按场景分类索引所有 Recipe。

---

## 四、设计模式与模板建议

### 建议 1：Recipe 骨架模板

```markdown
# [Recipe 名称]

> **一句话定位**：[解决什么问题]
> **目标读者**：[谁会用这个]
> **前置条件**：[使用前需要什么]

## 适用信号

当你遇到以下情况时，本 Recipe 可能有帮助：
- [情境 A]
- [情境 B]

## 不适用信号

如果你处于以下情况，请查阅其他资源：
- [情境 C] → 请看 [其他文档]

## TL;DR

[3-5 句话的核心要点，足以让急迫的读者开始行动]

---

## 核心流程

[流程图 / 决策树 / 步骤列表]

## 详细说明

### 步骤 1: ...
### 步骤 2: ...

## 检查清单

- [ ] 检查项 1
- [ ] 检查项 2

## 常见陷阱

| 陷阱 | 症状 | 解法 |
|:-----|:-----|:-----|

## 延伸阅读

- [相关 Recipe]
- [相关 Spec]
- [示例 Meeting]

---

*最后更新：YYYY-MM-DD*
```

### 建议 2：Recipe 索引页结构

```markdown
# Recipe 索引

## 按使用场景

### 🚀 冷启动
- [外部记忆维护](external-memory-maintenance.md) — 第一次接触记忆系统
- [Beacon 生成](beacon-recipe.md) — 需要生成 Beacon 时

### 🔧 日常操作
- [记忆积累规范](memory-accumulation-spec.md) — 每次会话结束
- [记忆维护技能书](memory-maintenance-skill.md) — 定期维护

### 🤝 协作
- [畅谈会指南](jam-session-guide.md) — 参与畅谈会
- [实时协作模式](real-time-collaboration-pattern.md) — 多 Agent 协作

## 按角色

### Team Leader
- ...

### 参谋组
- ...

### 前线组
- ...
```

### 建议 3：视觉语言规范

为了保持"一致性护城河"，建议统一以下视觉元素：

| 元素 | 用途 | 格式 |
|:-----|:-----|:-----|
| **引用块** | 定位/原则/重要提示 | `> **关键词**：内容` |
| **表格** | 对比/决策/映射 | 标准 Markdown 表格 |
| **代码块** | 模板/示例/流程图 | 带语言标记的 fenced block |
| **检查清单** | 验证/完成确认 | `- [ ]` 格式 |
| **条款 ID** | 可引用的规则 | `[S-XXX-YYY]` 格式 |

---

## 五、一句话总结

> **好的 Recipe 不仅是"压缩得好"，更是"解压得快"——让 Agent 在 30 秒内判断相关性，在 3 分钟内开始行动，只在必要时才深入阅读。**

Seeker 说 Recipe 是"决策压缩器"，我补充说：**Recipe 的 DX 目标是"零摩擦解压"**。

最后用一个隐喻收尾：

> Recipe 应该像**机场标识系统**——第一次来的旅客能在陌生环境中快速找到登机口，不需要先读完机场运营手册。

期待 Craftsman 对这些建议的可操作性核查。

---

### Craftsman 发言

我从“规范核查 / 质量控制”的角度补位：把“好Recipe”从审美判断变成**可判定、可回归、可演化**的工程对象。

> Seeker 强调“决策压缩器”，Curator 强调“30秒可判性/渐进式披露”。我的补充是：**压缩后的规则必须具备可追溯证据链**，否则它只是“写得像规则”。

## 1) 如何评估Recipe质量：可核查标准（Audit Criteria）

我建议把Recipe质量拆成四类硬指标 + 两类软指标；其中硬指标应尽可能自动化。

### A. 结构与元信息完整性（硬指标）

**可核查标准**：
1. **元信息块齐全**：至少包含 `版本/日期/状态/来源`（来源最好指向meeting或handoff）。
2. **定位三件套**：`一句话定位` + `适用信号` + `不适用信号`（Curator的“退出路径”在这里落地）。
3. **TL;DR 存在且可执行**：3–7条动作句，读者不看正文也能开始。
4. **检查清单存在**：并且是“可勾选、可验证”的动作/产物，不是价值观口号。

**反例信号**：只有“最后更新”但没有版本/变更原因；只有宏观理念没有“下一步做什么”。

### B. 条款体系与编号一致性（硬指标）

Recipe一旦开始使用 MUST/SHOULD/MAY，就等于在定义一种“轻规范”。轻规范也需要**条款ID**做稳定锚点。

**建议的统一编号格式**：`[XX-YY-ZZ]`
- `XX`：域（例如 `RC`=Recipe Clause；或按Recipe名缩写如 `CR`、`EMM`、`MM`）
- `YY`：主题域（建议 2–6 字符，固定闭集，例如 `META/REF/VER/TEST/GATE`）
- `ZZ`：三位序号 `001..999`

**必须可判定的规则**：
1. **ID 不可改名**：改语义只能 `Deprecated:` + `ReplacedBy:`（保持引用稳定）。
2. **同一ID只定义一次**（SSOT）；其它位置只能引用，不复述。
3. **速查表/摘要视图必须声明 informative**：避免“第二权威源”漂移。

### C. 引用关系与依赖管理（硬指标）

Recipe之间的依赖本质上是“前置技能/前置约束”。不显式化会造成：读者走到一半才发现缺前置。

**可核查标准**：
1. **显式依赖清单**：`DependsOn: [recipe-a, recipe-b]` 或“前置技能/相关指南”区块。
2. **引用必须可点击且不漂移**：相对路径链接应通过自动化 dead-link 检查。
3. **外部条款引用需带 specRef**：当Recipe引用 `[S-*/A-*]` 这类外部规范条款时，至少应指明“来自哪个spec文件/版本/commit”，避免“引用了一个会变的东西”。

### D. 版本管理与变更日志（硬指标）

Recipe是“可复用的操作契约”。版本管理至少要能回答：
- 现在的版本是什么？
- 变了什么？为什么变？
- 老读者按旧做法会不会踩坑？

**可核查标准**：
1. **版本格式统一**：建议语义化（`MAJOR.MINOR.PATCH`），避免同仓库混用 `1.0 / v1.0 / 1.0.0`。
2. **变更日志必须存在**：每次实质性修改都追加一条（含日期+变更点+影响范围）。
3. **兼容性声明**：破坏性变化必须在变更日志中标注 `BREAKING:`，并给迁移指引（哪怕是一句话）。

### E. 可测试性（硬指标，但可分级）

Recipe最容易“看起来对、其实不可执行”。我建议把可测试性分三档：
1. **结构可测**：是否存在 TL;DR、检查清单、依赖、变更日志（可自动lint）。
2. **过程可测**：是否提供最小复现步骤（例如“按这3步跑通一次”）。
3. **产物可测**：是否定义验收产物与判定方式（例如输出文件、字段、命名、通过哪些测试/脚本）。

**核查口径**：只要出现 MUST，就至少要能回答“如何验证它已满足”。回答不了的 MUST 应降级为 SHOULD/MAY 或补验证路径。

### F. 抗漂移性与维护成本（软指标，但建议设阈值）

**可核查信号**：
- 关键链接是否集中在“延伸阅读/依赖”区，而不是散落全篇（便于批量维护）。
- 重要规则是否可被“条款索引”检索到（锚点密度）。
- 是否存在“何时不用/反模式”章节（减少误用成本）。

## 2) Recipe质量检查清单（核心项目）

以下是我建议的“发布门禁”最小清单（可作为PR模板或DocOps自动检查的目标）：

### L0：结构门禁（机械可判定）
- [ ] 头部元信息齐全：版本/日期/状态/来源
- [ ] 首屏具备：一句话定位 + 适用信号 + 不适用信号 + TL;DR
- [ ] 存在“检查清单”章节
- [ ] 存在“变更日志/版本历史”章节
- [ ] 全文链接无死链（含跨目录链接）

### L1：规范门禁（半自动 + 人审）
- [ ] 存在 MUST/SHOULD/MAY 时：每条 MUST 有条款ID（`[XX-YY-ZZ]`）且可被引用
- [ ] 条款ID唯一、未复用、未改名（废弃用 Deprecated/ReplaceBy）
- [ ] 速查表/摘要视图标注 informative view（避免第二权威源）
- [ ] 若引用外部spec条款（如 `[S-*]/[A-*]`）：给出 specRef（文件+版本/commit/日期）

### L2：可执行门禁（人审为主）
- [ ] TL;DR 至少可跑通一次最小路径（明确输入/动作/产物）
- [ ] 检查清单每项都能“是/否”判定（或有明确产物证据）
- [ ] 反模式/不适用信号至少 2 条，防止滥用

## 3) 现有Recipe在条款编号、引用关系、版本管理方面的优缺点

基于对现有Recipe抽样（尤其是 `spec-driven-code-review.md` 的条款体系）观察：

### 优点
1. **条款化意识已形成**：例如 `spec-driven-code-review.md` 的 `[CR-01..]`、`external-memory-maintenance.md` 的 `[EMM-01..]`，以及 `memory-maintenance-skill.md` 的完整条款体系，都具备“可引用、可核查”的结构。
2. **多数文件有版本/变更日志**：不少Recipe在文末维护了版本表，具备追溯能力。
3. **依赖/延伸阅读正在出现**：部分Recipe已经开始显式链接其它Recipe、meeting记录，方向正确。
4. **有意识区分informative视图**：`memory-maintenance-skill.md` 明确“速查表是 informative view”，这点是避免SSOT漂移的亮点。

### 主要问题（可作为改进抓手）
1. **条款编号体系不统一**：同一目录下混用 `1.0 / v1.0 / 1.0.0`；条款ID也混用“数字序号式”（如 `CR-01`）与“语义key式”（如 `MM-GEN-ID-STABLE`）。这本身不是错，但会降低跨文档自动核查与引用的一致性。
2. **存在“有MUST但无稳定条款ID”的段落**：有些Recipe用 `[MUST]` 标记规则，但没有给出可被引用的稳定ID，后续讨论/审阅时难以精确指向。
3. **引用关系有漂移风险**：跨目录链接在少数文件中出现疑似路径不一致的情况（典型风险：从 `recipe/` 链到 `wiki/` 但目标实际在 `recipe/`）。这类问题非常适合用自动化 dead-link gate 捕获。
4. **外部条款引用缺少版本锁定**：例如引用 `[S-...]/[A-...]` 时，往往只写了ID，没有声明来自哪个spec版本/commit；一旦spec演进，Recipe的解释可能 silently 失真。

## 4) Recipe维护与演化机制建议（质量门禁 + 审查流程）

我建议把Recipe维护做成“轻量但可回归”的工程流程：

### 4.1 发布/修订流程（建议）
1. **Draft → Pilot → Published → Deprecated** 状态机
   - Draft：允许不完整，但必须标注缺口（TODO/OPEN QUESTIONS）
   - Pilot：至少有一次真实执行记录（链接到meeting/handoff作为证据）
   - Published：通过 L0/L1 门禁；对外作为推荐做法
   - Deprecated：保留但不再推荐，给 `ReplacedBy` 指向

2. **每次修订必须带“验证向量”**
   - 最低要求：更新检查清单中的某一项，或补一条“如何验证”的步骤。

3. **“条款变更”需要更严格审查**
   - 改动 MUST 条款（新增/废弃/语义变化）时：必须更新变更日志，并由至少一名非作者审核。

### 4.2 自动化质量门禁（DocOps可落地）
- **RecipeLint（L0）**：检查必备章节/元信息/变更日志存在性
- **LinkCheck（L0）**：检查相对链接可达
- **ClauseUniq（L1）**：检查条款ID唯一、无复用
- **RefLock（L1）**：当出现外部条款引用时，要求提供 specRef（最简单可以是“引用的spec文件路径+最后更新日期/commit”）

### 4.3 依赖与引用的“显式图谱”

建议引入一个轻量的Recipe索引（可以是 `agent-team/recipe/index.md` 或未来DocGraph派生视图）：
- 列出每个Recipe：版本、状态、owner、dependsOn、supersedes、deprecatedBy
- 形成“Recipe依赖图”，让维护者能快速定位受影响范围（变更传播半径）

---

一句话总结：
> **好的Recipe = 决策压缩（Seeker） + 快速解压（Curator） + 可追溯证据链（Craftsman）**。没有可追溯性，Recipe会在迭代中悄悄漂移，最后变成“看起来很对”的叙事文。
---

### Implementer 发言

感谢三位专家的精彩分析。Seeker 定义了本质（决策压缩器），Curator 设计了体验（30秒可判性），Craftsman 建立了质量门禁。

现在我的任务是：**把这些理论共识落地为可执行的实施计划**。

---

## 一、现状评估：12个Recipe的实施难度分析

首先用数据说话。我统计了现有Recipe的行数分布：

| 文件 | 行数 | 状态 | 修订难度 |
|:-----|:-----|:-----|:---------|
| memory-palace-batch-guide.md | 114 | ✅ 简洁 | 低 |
| beacon-recipe.md | 283 | ✅ 理想 | 低 |
| memory-maintenance-orchestration.md | 297 | ✅ 理想 | 低 |
| naming-skill-guide.md | 350 | ✅ 理想 | 低 |
| external-memory-maintenance.md | 392 | ✅ 理想 | 低 |
| strategic-tactical-dual-session.md | 409 | ✅ 理想 | 低 |
| test-file-splitting.md | 470 | ✅ 理想 | 低 |
| spec-driven-code-review.md | 523 | ⚠️ 接近上限 | 中 |
| memory-accumulation-spec.md | 535 | ⚠️ 接近上限 | 中 |
| memory-maintenance-skill.md | 643 | ⚠️ 超出建议 | 中 |
| jam-session-guide.md | 729 | ❌ 过长 | 高 |
| real-time-collaboration-pattern.md | 991 | ❌ 过长 | 高 |

**关键发现**：
- **8个文件（67%）** 在理想范围内，只需结构微调
- **2个文件（17%）** 需要内容审查和可能的压缩
- **2个文件（16%）** 需要深度重构或拆分

---

## 二、实施路径：三阶段渐进式改造

我建议采用**渐进式**而非激进式修订策略。理由：
1. **风险可控**：每阶段独立验证，不会全盘崩溃
2. **学习曲线**：团队在实践中逐步理解新规范
3. **监护人建议的"探索vs利用"平衡**：保留试错空间

### Phase 0: 基础设施（1-2天）

**目标**：建立工具支撑，不动现有Recipe

| 任务 | 产出 | 执行者 | 验收标准 |
|:-----|:-----|:-------|:---------|
| 创建元Recipe | `recipe/meta-recipe.md` | DocOps | 包含骨架模板+质量检查清单 |
| 创建Recipe索引 | `recipe/index.md` | DocOps | 按场景分类+状态矩阵 |
| 扩展检查脚本 | `scripts/check-recipe-quality.sh` | Implementer | L0门禁自动化 |
| 创建Recipe模板 | `templates/recipe-template.md` | DocOps | 符合Curator骨架结构 |

**check-recipe-quality.sh 功能规格**：

```bash
# L0 结构门禁（完全自动化）
- 检查必备章节存在性：定位/适用信号/TL;DR/检查清单/变更日志
- 检查元信息完整性：版本/日期/状态/来源
- 检查链接有效性（无死链）
- 检查行数阈值警告（>600行）

# L1 规范门禁（半自动）
- 扫描MUST/SHOULD/MAY，检查是否有条款ID
- 检查条款ID唯一性
- 生成条款索引表
```

### Phase 1: 结构对齐（3-5天）

**目标**：让所有Recipe具备统一骨架，不改变核心内容

**优先级排序**（基于使用频率 × 修订难度）：

| 优先级 | Recipe | 动作 | 预计工时 |
|:-------|:-------|:-----|:---------|
| P0 | beacon-recipe.md | 补充"不适用信号"+TL;DR强化 | 0.5h |
| P0 | memory-accumulation-spec.md | 补充"不适用信号"+条款ID规范化 | 1h |
| P1 | naming-skill-guide.md | 补充骨架缺失章节 | 0.5h |
| P1 | external-memory-maintenance.md | 补充骨架缺失章节 | 0.5h |
| P2 | spec-driven-code-review.md | 条款ID规范化+锚点密度增强 | 1h |
| P2 | memory-maintenance-skill.md | 压缩至600行+结构对齐 | 2h |
| P3 | jam-session-guide.md | **拆分**（见下方详细方案） | 3h |
| P3 | real-time-collaboration-pattern.md | **拆分**（见下方详细方案） | 4h |

**拆分策略：jam-session-guide.md (729行)**

Seeker诊断的"角色混淆"正确——它同时是方法论和执行脚本。建议拆分为：

```
recipe/
├── jam-session-recipe.md        # 原则+设计理念（~300行）
└── jam-session-playbook.md      # 执行脚本+模板（~400行）
```

**拆分策略：real-time-collaboration-pattern.md (991行)**

这是最新创建的文件（v1.0草案），内容本身质量不错但过于详尽。建议：

```
recipe/
├── real-time-collaboration-recipe.md  # 核心模式+决策框架（~400行）
└── real-time-collaboration-playbook/  # 详细流程手册
    ├── setup.md                       # 准备工作
    ├── execution.md                   # 实施流程
    └── troubleshooting.md             # 常见问题
```

### Phase 2: 质量深化（持续）

**目标**：建立持续改进机制

| 机制 | 触发条件 | 执行者 |
|:-----|:---------|:-------|
| **发布门禁** | 新Recipe PR | DocOps 审查 |
| **定期检查** | 每月1次 | Craftsman |
| **使用反馈** | 执行时遇到问题 | 执行者提Issue |
| **版本升级** | 累积3个改进需求 | Recipe Owner |

---

## 三、工具支持建议

### 3.1 自动化检查脚本

我建议扩展现有的 `check-terminology-consistency.sh`，创建新脚本 `check-recipe-quality.sh`：

**技术实现要点**：

```bash
#!/bin/bash
# check-recipe-quality.sh - Recipe 质量门禁脚本

# L0 检查项（完全自动化）
check_required_sections() {
    local file="$1"
    local missing=()
    
    # 检查必备章节
    grep -q "^## 适用信号\|^## 适用场景" "$file" || missing+=("适用信号")
    grep -q "^## 不适用信号\|^## 反适用场景" "$file" || missing+=("不适用信号")
    grep -q "^## TL;DR\|^## 摘要" "$file" || missing+=("TL;DR")
    grep -q "^## 检查清单\|^## 质量检查" "$file" || missing+=("检查清单")
    grep -q "^## 更新历史\|^## 变更日志" "$file" || missing+=("变更日志")
    
    echo "${missing[@]}"
}

# L0 检查项：元信息完整性
check_metadata() {
    local file="$1"
    local missing=()
    
    grep -q "版本\|version" "$file" || missing+=("版本")
    grep -q "日期\|date" "$file" || missing+=("日期")
    grep -q "状态\|status" "$file" || missing+=("状态")
    
    echo "${missing[@]}"
}

# L1 检查项：条款ID
check_clause_ids() {
    local file="$1"
    
    # 统计 MUST 数量
    must_count=$(grep -c "\bMUST\b" "$file")
    
    # 统计有 ID 的条款数量（如 [XX-YY-ZZ] 或 [CLAUSE-NAME]）
    id_count=$(grep -cE "\[[-A-Z0-9]+\].*MUST" "$file")
    
    echo "$must_count:$id_count"
}
```

### 3.2 模板系统

建议在 `templates/recipe-template.md` 中提供**填空式模板**，而非纯参考文档：

```markdown
# [Recipe 名称]

> **一句话定位**：[TODO: 解决什么问题，面向谁]
> **版本**：0.1
> **日期**：YYYY-MM-DD
> **状态**：草案
> **来源**：[TODO: 来自哪个meeting/讨论]

---

## 适用信号

<!-- 删除不适用的项，添加具体情境 -->
当你遇到以下情况时，本 Recipe 可能有帮助：
- [TODO: 情境 A]
- [TODO: 情境 B]

## 不适用信号

如果你处于以下情况，请查阅其他资源：
- [TODO: 情境 C] → 请看 [其他文档]

## TL;DR

<!-- 3-5 句话，足以让急迫的读者开始行动 -->
1. [TODO: 核心要点 1]
2. [TODO: 核心要点 2]
3. [TODO: 核心要点 3]

---

## 核心流程

<!-- 选择适合的形式：决策树 / 步骤列表 / 流程图 -->

[TODO: 流程内容]

## 检查清单

- [ ] [TODO: 检查项 1]
- [ ] [TODO: 检查项 2]

## 常见陷阱

| 陷阱 | 症状 | 解法 |
|:-----|:-----|:-----|
| [TODO] | [TODO] | [TODO] |

## 延伸阅读

- [相关 Recipe](./xxx.md)

---

## 更新历史

| 日期 | 变更 |
|:-----|:-----|
| YYYY-MM-DD | 初版创建 |
```

### 3.3 Recipe索引页

建议创建 `recipe/index.md`：

```markdown
# Recipe 索引

> 本文件是 Recipe 目录的导航入口。

## 状态图例

| 状态 | 含义 |
|:-----|:-----|
| ✅ Published | 已发布，可直接使用 |
| 🔄 Pilot | 试行中，欢迎反馈 |
| 📝 Draft | 草案，不建议依赖 |
| ⚠️ Deprecated | 已废弃，见替代方案 |

## 按使用场景索引

### 🚀 冷启动
| Recipe | 状态 | 简介 |
|:-------|:-----|:-----|
| [beacon-recipe](beacon-recipe.md) | ✅ | 从畅谈会生成Beacon |
| [external-memory-maintenance](external-memory-maintenance.md) | ✅ | 外部记忆维护 |

### 📝 日常操作
| Recipe | 状态 | 简介 |
|:-------|:-----|:-----|
| [memory-accumulation-spec](memory-accumulation-spec.md) | ✅ | 会话结束时的记忆写入 |
| [memory-maintenance-skill](memory-maintenance-skill.md) | ✅ | 定期记忆整理 |

### 🤝 协作
| Recipe | 状态 | 简介 |
|:-------|:-----|:-----|
| [jam-session-recipe](jam-session-guide.md) | 🔄 | 畅谈会机制 |
| [real-time-collaboration-pattern](real-time-collaboration-pattern.md) | 📝 | 边商讨边实施模式 |

## 依赖关系图

[memory-accumulation-spec] → [memory-maintenance-skill]
[jam-session-recipe] → [beacon-recipe]
```

---

## 四、实施成本与风险评估

### 成本估算

| 阶段 | 工时 | 人员 | 产出 |
|:-----|:-----|:-----|:-----|
| Phase 0 | 8h | Implementer + DocOps | 基础设施 |
| Phase 1 | 16h | DocOps为主 | 12个Recipe结构对齐 |
| Phase 2 | 持续 | 全员 | 质量持续改进 |

**总投入**：约 24h 一次性投入 + 每月 2h 持续维护

### 风险矩阵

| 风险 | 可能性 | 影响 | 缓解措施 |
|:-----|:-------|:-----|:---------|
| 模板过于僵化 | 中 | 高 | 保留"MAY"弹性，定期收集反馈 |
| 自动化检查误报 | 高 | 低 | 从警告开始，逐步升级为阻断 |
| 拆分后内容重复 | 中 | 中 | 拆分时用链接替代复述 |
| 老Recipe修订遗漏 | 中 | 中 | 建立索引+定期检查 |

### 向后兼容性

**承诺**：
1. **Phase 1 期间**：不删除任何现有内容，只添加缺失章节
2. **拆分操作**：原文件保留重定向说明
3. **条款ID变更**：使用 `Deprecated → ReplacedBy` 映射

---

## 五、团队协作机制

### 责任分配

| 角色 | Recipe相关职责 |
|:-----|:---------------|
| **DocOps** | Recipe Owner，负责结构维护、版本管理 |
| **Craftsman** | 核查员，定期质量检查、条款一致性验证 |
| **执行者** | 反馈员，使用时发现问题提Issue |
| **TeamLeader** | 仲裁者，决策分歧时最终裁定 |

### 修订审查流程

```
执行者发现问题
    ↓
在 recipe/feedback/ 创建 Issue 文件
    ↓
DocOps 评估 + 提出修订草案
    ↓
Craftsman 审查（涉及MUST条款时必须）
    ↓
合并 + 更新变更日志
```

---

## 六、一句话总结

> **从理论到代码的关键是"渐进式工程化"**：先建基础设施（脚本+模板），再批量微调（结构对齐），最后深度重构（过长文件拆分），同时保持试错空间。

**下一步行动**：
1. 创建 `check-recipe-quality.sh` 脚本（Implementer 可立即开始）
2. 创建 `templates/recipe-template.md`（DocOps 可立即开始）
3. 召集 Craftsman 审阅本发言的门禁标准是否过严或过松

期待监护人和其他成员的反馈。

---

### DocOps 发言

感谢四位专家的精彩分析。Seeker定义了Recipe的概念本质，Curator设计了认知界面，Craftsman建立了质量门禁，Implementer制定了落地计划。

现在我从**文档管理与知识连续性**角度补充：**Recipe如何在整个文档生态中定位、索引、发现和演化**。

---

## 一、Recipe在文档体系中的定位

### 1.1 文档类型拓扑图

首先，我基于维护实践绘制了团队文档类型的**拓扑图**：

```
                    ┌─────────────────┐
                    │  AGENTS.md      │ ← 团队入口（冷启动首读）
                    │  (Root Beacon)  │
                    └────────┬────────┘
                             │ 引用
        ┌────────────────────┼────────────────────┐
        │                    │                    │
        ▼                    ▼                    ▼
┌───────────────┐   ┌───────────────┐   ┌───────────────┐
│   wiki/       │   │   recipe/     │   │   meeting/    │
│  (知识库)     │   │  (操作手册)   │   │  (过程记录)   │
│               │   │               │   │               │
│ "是什么"      │   │ "怎么做"      │   │ "发生了什么"  │
│ 定义、概念    │   │ 方法、流程    │   │ 讨论、决策    │
└───────┬───────┘   └───────┬───────┘   └───────┬───────┘
        │                   │                   │
        │                   │                   │
        ▼                   ▼                   ▼
┌───────────────┐   ┌───────────────┐   ┌───────────────┐
│   specs/      │   │   members/    │   │   handoffs/   │
│  (约束条款)   │   │  (私有记忆)   │   │  (交接文档)   │
│               │   │               │   │               │
│ "必须遵守"    │   │ "我的认知"    │   │ "状态快照"    │
└───────────────┘   └───────────────┘   └───────────────┘
        │                   │                   │
        └───────────────────┼───────────────────┘
                            │
                            ▼
                    ┌───────────────┐
                    │   indexes/    │
                    │  (导航枢纽)   │
                    └───────────────┘
```

### 1.2 Recipe的独特定位

从拓扑图可以看出，**Recipe占据了"操作手册"这个独特生态位**：

| 维度 | Wiki | Recipe | Spec | Meeting |
|:-----|:-----|:-------|:-----|:--------|
| **核心问题** | 是什么？ | 怎么做？ | 必须什么？ | 发生了什么？ |
| **时态** | 永恒态 | 祈使态 | 规范态 | 过去态 |
| **约束力** | 解释性 | **建议性** | 强制性 | 记录性 |
| **变更频率** | 低 | **中** | 低 | 只追加 |
| **典型读者** | 想理解概念 | **想执行任务** | 需要合规 | 想追溯历史 |

**关键洞察**：

> **Recipe是知识转化为行动的桥梁**——它把Wiki的"是什么"和Meeting的"怎么做了"，转化为可复用的"下次怎么做"。

### 1.3 Recipe与其他文档类型的关系

基于我的文档维护经验，Recipe与其他类型存在以下**依赖关系**：

| 关系类型 | 从 Recipe 视角 | 说明 |
|:---------|:---------------|:-----|
| **上游输入** | Meeting → Recipe | 畅谈会共识提炼为Recipe |
| **上游输入** | Wiki → Recipe | 术语和概念定义被Recipe引用 |
| **双向引用** | Recipe ↔ Spec | Recipe推荐做法，Spec定义约束 |
| **下游输出** | Recipe → Members | 成员私有记忆引用Recipe |
| **派生物** | Recipe → System Prompt | Prompt是Recipe的执行压缩版 |

**变更传播路径**：

```
Meeting (决策) → Recipe (方法) → System Prompt (执行)
                     ↓
               Members (实践)
                     ↓
               Meeting (反馈)
```

---

## 二、Recipe索引与分类体系建议

### 2.1 索引策略：三维分类法

基于Curator的场景分析和Craftsman的核查需求，我建议采用**三维分类法**：

| 维度 | 分类依据 | 索引位置 |
|:-----|:---------|:---------|
| **场景维度** | 使用时机（冷启动/日常/协作） | `recipe/index.md` 主索引 |
| **角色维度** | 目标读者（Lead/参谋/前线） | `recipe/index.md` 辅助视图 |
| **依赖维度** | Recipe间的前置关系 | `recipe/index.md` 依赖图 |

### 2.2 建议的索引结构

```markdown
# Recipe 索引

> **定位**：Recipe目录的导航入口
> **维护者**：DocOps
> **最后更新**：YYYY-MM-DD

## 状态图例

| 状态 | 含义 | 说明 |
|:-----|:-----|:-----|
| ✅ Published | 已发布 | 经过验证，可直接使用 |
| 🔄 Pilot | 试行中 | 至少执行过一次，欢迎反馈 |
| 📝 Draft | 草案 | 未经验证，不建议依赖 |
| ⚠️ Deprecated | 已废弃 | 见ReplacedBy字段 |

---

## 按使用场景（主索引）

### 🚀 冷启动场景
> 新成员首次激活时应阅读

| Recipe | 状态 | 前置依赖 | 简介 |
|:-------|:-----|:---------|:-----|
| [外部记忆维护](external-memory-maintenance.md) | ✅ | 无 | 记忆文件六种类型元模型 |
| [Beacon生成](beacon-recipe.md) | ✅ | 无 | 从畅谈会提炼Beacon |

### 📝 日常操作场景
> 每次会话结束时参考

| Recipe | 状态 | 前置依赖 | 简介 |
|:-------|:-----|:---------|:-----|
| [记忆积累规范](memory-accumulation-spec.md) | ✅ | 外部记忆维护 | 三步Memory Commit协议 |
| [记忆维护技能书](memory-maintenance-skill.md) | ✅ | 记忆积累规范 | 定期大扫除方法论 |

### 🤝 协作场景
> 多成员协作时参考

| Recipe | 状态 | 前置依赖 | 简介 |
|:-------|:-----|:---------|:-----|
| [畅谈会指南](jam-session-guide.md) | 🔄 | 无 | 畅谈会机制与标签 |
| [实时协作模式](real-time-collaboration-pattern.md) | 📝 | 畅谈会指南 | 边商讨边实施 |

### 🔧 专项技能场景
> 特定任务时查阅

| Recipe | 状态 | 前置依赖 | 简介 |
|:-------|:-----|:---------|:-----|
| [命名技能书](naming-skill-guide.md) | ✅ | 无 | 命名方法论框架 |
| [规范驱动代码审阅](spec-driven-code-review.md) | ✅ | 无 | 条款化审阅流程 |
| [测试文件拆分](test-file-splitting.md) | ✅ | 无 | 大测试文件拆分策略 |

---

## 按角色（辅助视图）

| 角色 | 推荐Recipe | 说明 |
|:-----|:-----------|:-----|
| **TeamLeader** | 所有Recipe概览 | 需要理解团队运作全貌 |
| **参谋组** | 畅谈会指南、Beacon生成 | 主要参与讨论和审阅 |
| **前线组** | 记忆积累、实时协作 | 主要执行任务 |
| **新成员** | 外部记忆维护 → 记忆积累 | 学习路径 |

---

## 依赖关系图

```
[外部记忆维护]
        │
        ▼
[记忆积累规范] ──────→ [记忆维护技能书]
                              │
                              ▼
                      [记忆维护编排]
                              │
                              ▼
                      [批量维护指南]

[畅谈会指南] ────→ [Beacon生成]
      │
      ▼
[实时协作模式]

[命名技能书] (独立)
[规范驱动代码审阅] (独立)
[测试文件拆分] (独立)
[战术-战略双会话] (独立)
```

---

## Changefeed Anchor

> 本索引的变更记录

| Anchor | 日期 | 变更 |
|:-------|:-----|:-----|
| `#delta-recipe-index-v1` | YYYY-MM-DD | 初版创建 |
```

### 2.3 索引维护规则

| 规则ID | 规则 | 触发条件 |
|:-------|:-----|:---------|
| `[IDX-01]` | 新Recipe创建后**24小时内**必须添加到索引 | Recipe合并到主分支 |
| `[IDX-02]` | 状态变更必须同步更新索引 | Recipe状态从Draft→Pilot→Published |
| `[IDX-03]` | 废弃Recipe必须标注ReplacedBy | Recipe被新版本替代 |
| `[IDX-04]` | 依赖图变更需同步更新 | Recipe间依赖关系变化 |

---

## 三、Recipe的知识图谱与依赖管理

### 3.1 依赖类型学

Recipe之间存在多种依赖关系，需要显式化：

| 依赖类型 | 含义 | 标记方式 |
|:---------|:-----|:---------|
| **前置依赖** | 执行本Recipe前需先掌握的Recipe | `DependsOn: [recipe-a]` |
| **推荐顺序** | 建议的学习/执行顺序 | `RecommendedAfter: [recipe-b]` |
| **互补关系** | 相关但独立的Recipe | `SeeAlso: [recipe-c]` |
| **替代关系** | 已废弃，被新版本替代 | `ReplacedBy: [recipe-d]` |

### 3.2 建议的Recipe头部元数据格式

```markdown
# [Recipe名称]

> **版本**：1.0
> **日期**：YYYY-MM-DD
> **状态**：Draft | Pilot | Published | Deprecated
> **来源**：[来源Meeting/讨论]
> **维护者**：[责任人]
>
> **依赖关系**：
> - DependsOn: [前置Recipe列表]
> - SeeAlso: [相关Recipe列表]
> - ReplacedBy: [替代Recipe] (仅Deprecated状态)
```

### 3.3 依赖图的维护机制

| 场景 | 动作 | 执行者 |
|:-----|:-----|:-------|
| 新Recipe创建 | 在头部声明依赖；更新索引依赖图 | 作者 + DocOps |
| Recipe重构/拆分 | 更新所有引用方的依赖声明 | DocOps |
| Recipe废弃 | 标记ReplacedBy；索引标记⚠️ | DocOps |

---

## 四、变更管理与知识连续性

### 4.1 变更影响分析框架

基于我维护术语表和规范文档的经验，Recipe变更有**涟漪效应**：

```
Recipe 变更
    │
    ├──→ System Prompt 需同步更新
    │
    ├──→ 引用该Recipe的其他Recipe需检查
    │
    ├──→ 相关Meeting记录保持原样（历史事实）
    │
    └──→ 索引需更新状态/版本
```

### 4.2 变更传播检查清单

当Recipe发生**实质性变更**时，DocOps应执行以下检查：

| 检查项 | 工具/方法 | 说明 |
|:-------|:---------|:-----|
| 引用方扫描 | `grep -r "recipe-name" --include="*.md"` | 找出所有引用该Recipe的文件 |
| System Prompt同步 | 人工检查 | 确认执行压缩版是否需更新 |
| 索引更新 | 编辑`recipe/index.md` | 更新版本、状态、变更日期 |
| Changefeed记录 | 编辑`indexes/README.md` | 添加变更anchor |

### 4.3 版本策略建议

| 变更类型 | 版本影响 | 兼容性要求 |
|:---------|:---------|:-----------|
| **补充说明** | PATCH (+0.0.1) | 完全兼容 |
| **流程微调** | MINOR (+0.1.0) | 旧做法仍可用 |
| **核心重写** | MAJOR (+1.0.0) | 需迁移指引 |
| **拆分/合并** | 新文件v1.0 + 旧文件Deprecated | ReplacedBy指针 |

### 4.4 历史文档的处理原则

**核心原则**：**历史文档是历史事实的记录，不应被修改**。

| 文档类型 | 更新策略 |
|:---------|:---------|
| Meeting记录 | **绝不修改**（即使引用了旧术语或废弃Recipe） |
| Handoff文档 | **绝不修改**（历史快照） |
| 活跃Recipe | 按版本策略更新 |
| 索引文件 | 反映当前状态 |

---

## 五、新成员发现与引导机制

### 5.1 问题诊断

当前Recipe的发现机制存在以下问题：

| 问题 | 表现 | 影响 |
|:-----|:-----|:-----|
| **入口不明** | 无统一索引，需人工推荐 | 新成员不知道从哪开始 |
| **学习路径模糊** | 前置依赖未显式化 | 跳过基础直接读高级Recipe |
| **场景匹配难** | 按文件名无法判断相关性 | 需要读完才知道是否需要 |

### 5.2 建议的引导体系

#### A. 入口层：AGENTS.md增强

在`AGENTS.md`中添加Recipe导航：

```markdown
## Recipe快速导航

| 你想要... | 阅读 |
|:----------|:-----|
| 理解记忆系统 | [外部记忆维护](recipe/external-memory-maintenance.md) |
| 参与畅谈会 | [畅谈会指南](recipe/jam-session-guide.md) |
| 查找所有Recipe | [Recipe索引](recipe/index.md) |
```

#### B. 索引层：场景化入口

`recipe/index.md`按场景组织（见上文2.2节），让新成员能快速定位。

#### C. Recipe层：30秒可判性

每个Recipe开篇必须回答（Curator的设计原则）：
- 一句话定位：这是干什么的？
- 适用信号：我什么时候需要这个？
- 不适用信号：什么情况下不应该用这个？

#### D. 学习路径：渐进式推荐

为新成员设计推荐学习路径：

```
Day 1: 外部记忆维护 → 理解文件类型
        ↓
Day 2: 记忆积累规范 → 学会写入记忆
        ↓
Day 3: Beacon生成 → 理解知识提炼
        ↓
Week 2: 根据角色选择专项技能Recipe
```

### 5.3 发现机制的工具支持

| 机制 | 实现方式 | 优先级 |
|:-----|:---------|:-------|
| **关键词索引** | `recipe/index.md`中的场景标签 | P0（人工维护） |
| **交叉引用** | Recipe头部的DependsOn/SeeAlso | P0（人工维护） |
| **自动检索** | 未来DocGraph的Recipe节点类型 | P2（工具支持） |

---

## 六、与现有基础设施的集成

### 6.1 与Changefeed系统的集成

现有`indexes/README.md`的Delta Ledger机制可以扩展到Recipe：

```markdown
### YYYY-MM-DD – Recipe Updates
- **#delta-recipe-xxx-v1.1** – [recipe-name] 版本更新
  - 变更摘要
  - 详见: [recipe/xxx.md](../recipe/xxx.md)
  - 相关: [Meeting记录链接]
```

**集成规则**：
- Recipe MAJOR版本变更：必须创建Changefeed Anchor
- Recipe状态变更（Draft→Published）：必须创建Changefeed Anchor
- MINOR/PATCH变更：在Recipe自身变更日志记录即可

### 6.2 与术语体系的集成

现有的三层术语SSOT结构为Recipe提供了参考模型：

| 术语SSOT层 | Recipe对应 | 说明 |
|:-----------|:-----------|:-----|
| Layer 1 (语义) | Recipe正文 | 方法论和流程定义 |
| Layer 2 (写法) | Recipe模板 | 结构和格式规范 |
| Layer 3 (机器可读) | Recipe索引+元数据 | 状态、依赖、版本 |

### 6.3 与成员记忆系统的集成

Recipe与成员记忆系统的关系：

```
Recipe (共享知识)
    │
    │ 引用
    ▼
members/<name>/index.md (私有记忆)
    │
    │ 实践反馈
    ▼
meeting/ (讨论记录)
    │
    │ 提炼
    ▼
Recipe (更新)
```

**集成规则**：
- 成员记忆中不应复述Recipe内容，只引用
- 实践中发现Recipe问题，应创建反馈Issue到`recipe/feedback/`

---

## 七、一句话总结

> **Recipe是团队知识从"发生"到"复用"的转化枢纽——通过场景化索引帮助发现，通过依赖图谱帮助理解，通过变更管理保证一致性，最终实现知识的跨会话、跨成员传承。**

从文档管理角度，我的核心建议是：

1. **建立`recipe/index.md`作为唯一入口**——场景化分类 + 依赖图 + 状态追踪
2. **显式化依赖关系**——Recipe头部必须声明DependsOn/SeeAlso
3. **集成到Changefeed系统**——重大变更必须有Anchor
4. **设计新成员学习路径**——从入口到索引到Recipe的渐进引导

期待监护人的指导和团队的反馈。

---

### Craftsman 审阅意见

> 核查对象：`agent-team/recipe/recipe-meta-recipe-draft.md`（v0.1, 2026-01-01, Draft）
> 
> 核查目标：完整性/一致性、自符合（是否满足其定义的“好Recipe”标准）、质量门禁与审查流程可执行性、版本管理清晰度。

## A. 结论摘要（可执行结论）

1. **结构与覆盖面总体合格**：五特征、模板、门禁、流程、版本策略、生态定位基本齐全。
2. **存在“自我不一致/自符合不足”的硬缺口**：按其自定义的 L0 门禁，当前元Recipe自身缺少显式“检查清单”章节（仅在模板中出现），会让“门禁是否适用于元Recipe本身”变成不可判定争议点。
3. **门禁可执行，但需要最小规范化**：L0 可完全自动化；L1 目前存在“条款ID格式不统一/外部specRef格式未定义/何时触发L1不清晰”三个可落地缺口。
4. **审查流程方向正确，但缺少可回归的 Pilot 证据与回滚条件**：建议把“至少一次真实执行验证”的证据载体与失败处理写成可判定条款。

## B. 完整性与一致性核查（条款化问题清单）

### [MR-A-01] 规范语气与“Recipe是建议”的边界未显式化

- **证据**：草案同时强调“Recipe是建议（推荐采用）”与“使用 MUST/SHOULD/MAY 标签”。
- **风险**：读者会困惑：这些 MUST 是对“执行者”的强制，还是对“Recipe作者”的格式强制？造成审查时争议（不可判定）。
- **建议修订**：在草案前半部加入一段“规范语气范围声明”：
   - MUST/SHOULD/MAY 在本元Recipe中**仅约束 Recipe 文档作者/维护流程**，不直接约束任务执行者；执行者约束以 spec 为准。

### [MR-A-02] L0 门禁条目与“元Recipe是否豁免”缺少明确规则

- **证据**：L0 要求每个 Recipe “存在‘检查清单’章节”；但本元Recipe正文没有独立“检查清单”章节。
- **风险**：元Recipe作为“示范样本”却无法通过自身门禁，会削弱权威性与可回归性（门禁本身也失去可测试基线）。
- **建议修订（二选一，建议选 1）**：
   1) **让元Recipe也通过门禁**：在正文补 `## 检查清单（本文件自审）`，并补 `## 常见陷阱（写Recipe时）`；
   2) 明确“Meta-Recipe Exemption”：元Recipe可豁免哪些 L0 条目，以及豁免理由与替代验收方式（但这会降低“以身作则”的示范价值）。

### [MR-A-03] “条款ID”规则不够可操作：格式/范围/唯一性边界未定义

- **证据**：L1 写“每条 MUST 有条款ID（`[XX-YY-ZZ]`）”，但：
   - 未定义 XX/YY/ZZ 的闭集或示例；
   - 未说明“唯一性”是**文件内唯一**还是**仓库全局唯一**；
   - 与仓库既有 `CR-01`、`EMM-01` 等风格可能不兼容。
- **风险**：自动化无法落地；人工审查会陷入格式争论。
- **建议修订**：增加一个“条款ID最低兼容规范”小节（MVP）：
   - 允许两种格式（兼容存量）：`[AAA-001]`（前缀+序号）或 `[AA-BB-001]`（域-主题-序号）；
   - **唯一性边界**：至少要求“文件内唯一”；若要全局唯一，则要求前缀含 Recipe 名缩写；
   - 明确“改名禁令”与废弃机制：`Deprecated:` + `ReplacedBy:`。

### [MR-A-04] “specRef（文件+版本/commit）”要求可执行但需给出最低格式

- **证据**：L1 要求引用外部 spec 条款时提供 specRef（文件+版本/commit）。
- **风险**：在没有统一 commit/permalink 习惯时，这条会被大量跳过，导致门禁形同虚设。
- **建议修订**：定义 specRef 的最小可接受形态（按可得性分级）：
   - `specRef: <path>@<commit>`（最佳）
   - `specRef: <path>#<anchor> (as-of YYYY-MM-DD)`（可接受）
   - 并明确“引用 meeting 不要求 specRef”。

### [MR-A-05] “索引必须在 recipe/index.md 注册”的前提文件尚未落地

- **证据**：草案提出索引要求，但当前仓库未必已有 `recipe/index.md`。
- **风险**：规则落空或造成路径争议。
- **建议修订**：把“索引要求”写成路线图的硬前置（Phase 0 必须先创建索引），并在元Recipe中标注“当前状态：待创建”。

## C. 草案是否符合其定义的五特征（逐项对照）

### [MR-C-01] 情境锚定：通过（强）

- 证据：开篇 `适用信号/不适用信号` 明确，30 秒可判性达标。

### [MR-C-02] 决策导向：部分通过（中）

- 证据：对“Recipe是什么/不是什么”、长度阈值、发布状态机等提供了决策框架。
- 缺口：缺少“关键决策点”的显式表格/树，例如：
   - 何时应拆分为 `recipe + playbook`？
   - 何时把内容移到 `meeting/` 作为证据而非正文？
   - 何时把 MUST 升级成 spec 条款？
- 建议：新增 1 张决策表（MVP 就够），把上述分流规则写成“如果…则…”。

### [MR-C-03] 可操作粒度：通过，但可更强（中-强）

- 证据：给出完整模板、L0/L1 检查项与流程。
- 缺口：缺少“最小可执行示例”（例如一个 TL;DR 的好例子/坏例子对照，或一个条款ID+specRef 的示例）。

### [MR-C-04] 适度弹性：基本通过，但需边界声明（中）

- 证据：引入 MUST/SHOULD/MAY；版本影响表也体现弹性。
- 风险：未声明“哪些 MUST 是硬门禁、哪些是建议”。建议把 L0/L1 作为门禁硬约束，其余为 SHOULD。

### [MR-C-05] 篇幅纪律：通过（强），但缺“拆分策略模板”

- 证据：给出 200–500 理想区间、>600 拆分建议。
- 建议：补充 2–3 种常见拆分模式（例如“原则/流程/案例分离”，“recipe vs playbook”，“索引页+分卷”）。

## D. 质量门禁（L0/L1）与审查流程可行性评估

### [MR-D-01] L0 可执行性：高

- 可自动化：章节/元信息存在性、链接死链、行数阈值。
- 建议把 L0 规则“标题同义词”列出来（例如 `更新历史/变更日志` 视为同一类），避免误报。

### [MR-D-02] L1 可执行性：中（需要补齐约定）

- 目前 L1 的三项（MUST→条款ID、ID唯一、specRef）都可实现半自动，但前提是：
   - 条款ID正则定义稳定；
   - 唯一性边界明确（文件内 or 全局）；
   - specRef 最小格式明确。

### [MR-D-03] 审查流程合理性：高，但缺“证据载体”与“失败语义”

- 缺口：Pilot 的“至少一次真实执行验证”需要明确**证据写在哪里**、由谁追加、失败时如何回退到 Draft。
- 建议修订：
   - Pilot 必须在文末新增一条“执行记录”（可链接 meeting/handoff/issue）；
   - 若验证失败：状态回退 Draft，并在更新历史中记录原因与链接。

## E. 版本管理策略清晰度评估

### [MR-E-01] 策略方向正确，但建议补两个边界

- 边界 1：`0.x` 阶段是否允许 breaking change？建议写清楚：`0.x` 仍按 MAJOR/MINOR/PATCH 记录，但兼容承诺较弱。
- 边界 2：拆分/合并的“旧文件处置模板”建议固化（Deprecated + ReplacedBy + 索引标记 + 不删除）。

## F. 需要澄清/补充的问题（OPEN QUESTIONS）

1. **条款ID唯一性范围**：文件内唯一即可，还是仓库全局唯一？若全局唯一，推荐前缀方案是什么？
2. **specRef 的权威来源**：以 git commit 为准，还是允许“as-of 日期+文件路径+锚点”？
3. **元Recipe是否必须自通过 L0/L1？** 若豁免，豁免清单与理由是什么？
4. **Recipe与spec的升级路径**：当某 Recipe 中的 MUST 被证明是硬约束时，是否有明确迁移到 spec 的流程与责任人？

## G. 具体修订建议（最小改动集，建议优先级 P0→P2）

### P0（必须修）

1. 补一段“规范语气范围声明”（解决 MUST 的对象歧义）。
2. 补 `## 检查清单（本文件自审）`，让元Recipe自身通过 L0，形成可回归基线。
3. 明确条款ID的最低兼容格式 + 唯一性范围（至少文件内唯一）。
4. 明确定义 specRef 最小格式（含 fallback 方案）。

### P1（强烈建议）

1. 增补 1 张“Recipe拆分/升级决策表”（决策导向落地）。
2. 增补 1 个“好TL;DR/坏TL;DR”示例（可操作粒度提升）。
3. 在 L0 规则中列出允许的章节同义名，减少脚本误报。

### P2（可选增强）

1. 增补“常见陷阱”章节，覆盖：模板僵化、双写漂移、示例膨胀、无不适用边界等。
2. 把“索引要求”与 Phase 0 的落地状态关联（当前若未创建索引，标注 TODO + owner）。

## H. 实施可行性（工程化落地评估）

- **2–4 小时可落地 P0**：主要是补充规范段落、清单与格式定义；不会引发大规模改动。
- **L0 自动化成本低**：grep/markdownlint 级别即可；误报主要来自标题别名与路径漂移，可通过“同义词表 + 允许列表”降低。
- **L1 自动化成本中等**：条款ID解析与唯一性检查需要一个稳定正则与边界定义；specRef 校验可先做“存在性检查”再逐步升级为“可解析性检查”。
- **流程落地依赖角色协作**：Pilot 证据载体与回退机制一旦写成条款，DocOps/Craftsman 的协作边界会更清晰，争议更少。
