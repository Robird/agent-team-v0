# 畅谈会：术语命名规范制定

> **日期**：2025-12-31
> **标签**：#design #decision
> **主持人**：刘德智 (Team Leader)
> **参与者**：Seeker, Curator, Craftsman, DocOps
> **状态**：进行中

---

## 背景

基于监护人提出的规范修订需求，我们需要制定统一的术语命名规范，特别是：

1. **多单词术语的连接方式**：是否统一采用"减号连接的首字母大写形式"（如 `Why-Layer`、`App-For-LLM`）
2. **缩写的大小写规则**：两种候选方案：
   - 方案1：不论是否是缩写，统一用仅首字母大写形式，如 `Dna`/`Id`/`Ui`
   - 方案2：仅2个字母的缩写可以全大写作为例外，例如 `ID`/`UI`/`UX`/`DX`，但三个及更多字母的缩写则像一般单词一样用仅首字母大写，如 `Dna`/`Llm`

**核心目标**：为后续的 DocGraph 铺路，方便搜索和机读。

## 参考材料

1. 现有规范文件：`atelia/docs/spec-conventions.md`
2. 现有术语表：`agent-team/wiki/terminology.md`
3. 现有实践：
   - 连字符术语：`Why-Layer`、`Shape-Layer`、`App-For-LLM`、`Context-Projection`、`Capability-Provider`
   - 缩写使用：`ID`、`UI`、`UX`、`DX`、`LLM`、`API`、`MVP`、`SSOT`、`CRC`、`RBF`

## 畅谈目标

1. 评估现有实践的优缺点
2. 分析两种缩写方案的 tradeoff
3. 形成统一的命名规范
4. 制定迁移和过渡方案

---

## 💬 畅谈记录

### 主持人开场 (刘德智)

大家好！今天我们讨论术语命名规范。这是一个看似简单但影响深远的问题。

**当前现状**：
- 连字符连接的多单词术语已经在项目中广泛使用（如 `Why-Layer`、`App-For-LLM`）
- 缩写的大小写使用不一致（既有 `ID` 也有 `Llm`）
- 需要为 DocGraph 的搜索和机读需求制定明确规范

**核心问题**：
1. 多单词术语的连接方式是否应该标准化为"减号连接的首字母大写形式"？
2. 缩写的大小写应该采用哪种方案？还是需要第三种方案？

**讨论框架**：
1. **Seeker**：从概念本质和搜索友好性角度分析
2. **Curator**：从 UX/DX（用户体验/开发者体验）角度评估
3. **Craftsman**：从规范一致性和代码可维护性角度分析
4. **DocOps**：从文档管理和迁移成本角度评估

让我们从 **Seeker** 开始，从概念本质角度分析这个问题。

---

### Seeker 发言

感谢主持人的邀请。我将从概念本质、搜索友好性和语义清晰性角度分析术语命名规范问题。

---

## 一、多单词术语的连接方式分析

### 1.1 现有实践评估

当前项目中已经存在多种多单词术语连接方式：

| 格式 | 示例 | 出现频率 | 优点 | 缺点 |
|:-----|:-----|:---------|:-----|:-----|
| **连字符连接** | `Why-Layer`, `App-For-LLM` | 高 | 1. 视觉分隔清晰<br>2. 便于搜索（减号是有效分隔符）<br>3. 避免单词粘连 | 1. 输入稍麻烦<br>2. 在某些编程语言中可能受限 |
| **驼峰式** | `AppForLLM` | 低 | 1. 代码友好<br>2. 输入方便 | 1. 视觉粘连<br>2. 搜索困难（`AppForLLM` vs `App-For-LLM`）<br>3. 大小写敏感 |
| **空格分隔** | `Why Layer` | 中 | 1. 自然语言友好 | 1. 代码中无法使用<br>2. 文件命名受限 |

### 1.2 概念本质分析

**连字符的本质**：连字符在语言学中是**复合词连接符**，用于连接多个单词形成一个单一概念。这与我们的需求完美匹配：
- `Why-Layer` 不是"为什么"和"层"的简单组合，而是一个**单一概念**
- `App-For-LLM` 是一个**专有名词**，描述特定类型的应用

**搜索友好性分析**：
- 连字符作为分隔符，搜索引擎可以正确分词：搜索 `Why-Layer` 可以匹配 `Why Layer`、`WhyLayer` 等变体
- 驼峰式在搜索中容易漏匹配：`AppForLLM` 不会匹配 `App-For-LLM`

**语义清晰性**：连字符明确标识了"这是一个复合术语"，避免了歧义。

### 1.3 建议

**[S-TERM-MULTIWORD-HYPHENATED]** 多单词术语 SHOULD 使用连字符连接的首字母大写形式。

**理由**：
1. **概念完整性**：连字符标识单一概念
2. **搜索友好**：便于 DocGraph 等工具进行文本分析和索引
3. **视觉清晰**：人类阅读时易于识别单词边界
4. **现有惯性**：项目已广泛使用此格式

**例外情况**：
- 代码中的类名、接口名等标识符 MAY 使用 PascalCase（如 `AppForLLM`）
- 文件命名 SHOULD 使用小写连字符（如 `app-for-llm.md`）

---

## 二、缩写的大小写规则分析

### 2.1 两种候选方案的本质差异

**方案1（统一首字母大写）**：
- 哲学：**一致性优先**，将所有缩写视为普通单词
- 示例：`Dna`、`Id`、`Ui`、`Llm`、`Api`
- 优点：规则简单，无需记忆例外
- 缺点：违反常见约定（`ID` 通常全大写）

**方案2（长度区分）**：
- 哲学：**惯例兼容性优先**，尊重常见缩写习惯
- 示例：`ID`、`UI`、`UX`、`DX`（2字母） vs `Dna`、`Llm`、`Api`（3+字母）
- 优点：符合行业惯例，减少认知摩擦
- 缺点：规则稍复杂，需要记忆分界线

### 2.2 搜索和机读需求分析

**DocGraph 需求**：
1. **精确匹配**：需要能准确识别术语边界
2. **变体处理**：需要处理不同大小写形式
3. **概念关联**：需要建立 `UI` ↔ `User Interface` 的映射

**方案对比**：

| 维度 | 方案1（统一首字母） | 方案2（长度区分） |
|:-----|:-------------------|:-----------------|
| **搜索精确性** | 高（统一格式） | 中（需要处理两种格式） |
| **概念关联** | 容易（`Ui` → `User Interface`） | 较复杂（`UI` vs `Ui`） |
| **行业兼容性** | 低（违反惯例） | 高（尊重惯例） |
| **实现复杂度** | 低（单一规则） | 中（需要长度判断） |

### 2.3 实际用例分析

**常见缩写分类**：

| 类别 | 示例 | 行业惯例 | 方案1 | 方案2 |
|:-----|:-----|:---------|:-----|:-----|
| **2字母技术缩写** | `ID`, `UI`, `UX`, `DX` | 全大写 | `Id`, `Ui`, `Ux`, `Dx` | `ID`, `UI`, `UX`, `DX` |
| **3+字母技术缩写** | `API`, `MVP`, `SSOT`, `CRC` | 通常全大写 | `Api`, `Mvp`, `Sshot`, `Crc` | `Api`, `Mvp`, `Sshot`, `Crc` |
| **生物/科学缩写** | `DNA`, `RNA` | 全大写 | `Dna`, `Rna` | `Dna`, `Rna` |
| **新兴领域缩写** | `LLM`, `AI` | 通常全大写 | `Llm`, `Ai` | `Llm`, `AI` |

**关键观察**：
1. **2字母缩写**：行业强烈倾向于全大写（`ID`、`UI`）
2. **3+字母缩写**：惯例较灵活，但技术领域倾向于全大写
3. **新兴缩写**：惯例正在形成中

### 2.4 概念本质建议

**缩写的大小写本质上是"约定 vs 一致性"的权衡**。

我提出**第三种方案**：**基于语义角色区分**

**[S-TERM-ABBREV-SEMANTIC]** 缩写的大小写 SHOULD 基于其语义角色决定：

1. **作为独立术语**：当缩写作为独立概念使用时，使用全大写
   - 示例：`ID`（标识符）、`UI`（用户界面）、`API`（应用程序接口）
   - 理由：这些是完整的专有名词

2. **作为复合术语的一部分**：当缩写作为复合术语的一部分时，使用首字母大写
   - 示例：`App-For-LLM`（不是 `App-For-LLM`）、`Context-Projection`（如果 `CP` 成为缩写）
   - 理由：在复合词中，缩写应融入整体格式

3. **代码标识符**：代码中的变量、类名等 MAY 使用 PascalCase
   - 示例：`AppForLLM`、`ContextProjection`
   - 理由：代码命名约定优先

### 2.5 具体规则建议

**[S-TERM-ABBREV-STANDALONE]** 独立使用的技术缩写 SHOULD 使用全大写形式，特别是：
- 2字母缩写：`ID`、`UI`、`UX`、`DX`
- 常见技术缩写：`API`、`MVP`、`SSOT`、`CRC`、`RBF`
- 科学缩写：`DNA`、`RNA`

**[S-TERM-ABBREV-COMPOUND]** 作为复合术语一部分的缩写 SHOULD 使用首字母大写形式：
- `App-For-LLM`（不是 `App-For-LLM`）
- 如果 `CP` 成为 `Context-Projection` 的缩写，则写为 `Cp` 在复合词中

**[S-TERM-ABBREV-CODE]** 代码中的标识符命名遵循编程语言惯例，MAY 与文档约定不同。

---

## 三、搜索友好性专项分析

### 3.1 DocGraph 需求细化

DocGraph 需要：
1. **术语提取**：从文本中识别术语
2. **概念映射**：建立不同形式间的关联
3. **引用分析**：统计术语使用频率

### 3.2 对命名规范的要求

**理想特性**：
1. **确定性**：每个术语有唯一的标准形式
2. **可逆性**：可以从标准形式推导出常见变体
3. **一致性**：类似术语采用类似格式

### 3.3 建议的规范体系

**三层规范**：

1. **标准形式（SSOT）**：文档中使用的规范格式
   - 多单词术语：`Why-Layer`
   - 独立缩写：`ID`、`API`
   - 复合术语中的缩写：`App-For-LLM`

2. **代码形式**：代码中使用的格式
   - 类名：`WhyLayer`、`AppForLLM`
   - 变量名：`id`、`ui`（遵循语言惯例）

3. **搜索变体**：DocGraph 应识别的变体
   - `Why-Layer` → `Why Layer`、`WhyLayer`、`why-layer`
   - `ID` → `Id`、`id`
   - `App-For-LLM` → `AppForLLM`、`app-for-llm`

### 3.4 实现建议

**术语注册表**：建立中央术语注册表，包含：
- 标准形式
- 定义
- 允许的变体
- 概念关联

**DocGraph 扩展**：添加术语规范化模块，将各种变体映射到标准形式。

---

## 四、总结与建议

### 4.1 核心建议

1. **多单词术语**：✅ 采用连字符连接的首字母大写形式
2. **缩写规则**：✅ 采用**基于语义角色的混合方案**
   - 独立术语：全大写（`ID`、`API`）
   - 复合术语部分：首字母大写（`App-For-LLM`）
   - 代码标识符：遵循语言惯例

### 4.2 规范条款草案

**[S-TERM-FORMAT-HYPHENATED]** 多单词概念术语 MUST 使用连字符连接的首字母大写形式（如 `Why-Layer`、`App-For-LLM`）。

**[S-TERM-ABBREV-STANDALONE-CAPS]** 独立使用的技术缩写 SHOULD 使用全大写形式，特别是2字母缩写（如 `ID`、`UI`、`API`）。

**[S-TERM-ABBREV-COMPOUND-TITLECASE]** 作为复合术语组成部分的缩写 SHOULD 使用首字母大写形式（如 `App-For-LLM` 中的 `LLM`）。

**[S-TERM-CODE-VS-DOC]** 代码标识符的命名 MAY 与文档约定不同，但 SHOULD 在文档中说明映射关系。

### 4.3 迁移策略

1. **渐进更新**：新文档使用新规范，旧文档在修改时更新
2. **术语注册表**：建立中央术语库作为 SSOT
3. **工具支持**：通过 DocGraph 检查术语一致性

### 4.4 待决问题

1. **例外处理**：哪些缩写应该作为例外保持全大写？
2. **过渡期限**：旧文档需要多长时间迁移？
3. **工具支持**：需要哪些工具来支持新规范？

期待 Curator、Craftsman 和 DocOps 的补充视角。

---

### Curator 发言

感谢 Seeker 的系统性分析。我将从 UX/DX（用户体验/开发者体验）角度审视术语命名规范，聚焦于**人在使用这些术语时的真实感受**。

---

## 一、核心体验洞见

在深入分析前，我想先分享一个关键洞见：

> **命名规范的隐形成本**：开发者在阅读和写作时做出的每一个"这个词怎么写？"的微决策，都是认知税。好的命名规范应该让这个问题"消失"——要么因为规则直觉到不需要思考，要么因为一致性足够高让人形成肌肉记忆。

---

## 二、人类可读性分析

### 2.1 视觉解析效率

| 格式 | 示例 | 视觉评估 | 认知负荷 |
|:-----|:-----|:---------|:---------|
| **连字符分隔** | `Why-Layer` | ⭐⭐⭐⭐⭐ 单词边界清晰 | 低 |
| **驼峰式** | `WhyLayer` | ⭐⭐⭐ 需要靠大小写解析 | 中 |
| **空格分隔** | `Why Layer` | ⭐⭐⭐⭐⭐ 自然语言友好 | 低 |
| **纯大写缩写** | `ID`、`API` | ⭐⭐⭐⭐ 高辨识度 | 低 |
| **首字母大写缩写** | `Id`、`Api` | ⭐⭐ 看起来像普通单词 | 中-高 |

**关键洞察**：

1. **`Id` 的"伪装效应"**：`Id` 看起来像英语单词 "Id"（弗洛伊德的"本我"概念），造成语义干扰。而 `ID` 明确传达"这是一个缩写"的信号。
   - 类比：这就像路标——全大写是"STOP"标志（强视觉信号），首字母大写是普通路名（弱信号）。

2. **`Llm` 的"发音障碍"**：`Llm` 让人困惑"这怎么读？"——它既不像缩写也不像单词。相比之下，`LLM` 明确是缩写，读者自然会拼读字母。

3. **2 字母 vs 3+ 字母的视觉感知差异**：
   - `UI`、`ID` → 全大写时视觉紧凑，像一个原子单位
   - `API`、`MVP` → 全大写时视觉尚可，但开始显得"大声喊叫"
   - `SSOT`、`RBAF` → 全大写时视觉沉重，阅读时需要解码

### 2.2 扫描阅读体验

当开发者快速扫描文档时：

- **连字符术语**（如 `Why-Layer`）：像路标一样醒目，容易定位
- **全大写缩写**（如 `API`、`ID`）：像高亮标记，吸引注意力
- **首字母大写缩写**（如 `Api`、`Id`）：融入普通文本，容易被忽略

**体验建议**：缩写的全大写形式实际上提供了**视觉锚点**功能，帮助快速扫描。方案 1（统一首字母大写）会丧失这种锚点效应。

---

## 三、输入便利性分析

### 3.1 打字成本对比

| 动作 | `Why-Layer` | `ID` | `Id` | `LLM` | `Llm` |
|:-----|:------------|:-----|:-----|:------|:------|
| 按键次数 | 10 | 2 | 2 | 3 | 3 |
| Shift 键使用 | 2次（W、L） | 2次（I、D） | 1次（I） | 3次（L、L、M） | 1次（L） |
| 连字符输入 | 需要 | - | - | - | - |

**关键发现**：

1. **连字符的摩擦力**：连字符需要特殊按键，这是有意阻尼。它迫使写作者意识到"我在创建一个复合术语"——这种摩擦力是**有益的**，防止随意创造术语。

2. **全大写的 Shift 成本**：`LLM` 需要持续按 Shift，输入成本较高。但这个成本在实践中不显著——术语的输入频率远低于普通代码。

3. **IDE 自动补全的缓解效应**：现代 IDE 的自动补全大幅降低了输入成本。一旦术语被项目识别，输入体验趋同。

### 3.2 编辑和修改体验

**场景**：开发者在文档中发现一个错误的术语格式需要修正。

- **规则越简单，修正越容易**：方案 1（统一首字母大写）的修正规则最简单——只需首字母大写
- **规则越复杂，犹豫越多**：方案 2/3 需要判断"这是 2 字母还是 3 字母？""这是独立使用还是复合使用？"

**体验权衡**：简单规则降低修正成本，但可能增加阅读成本。需要找到平衡点。

---

## 四、学习曲线分析

### 4.1 规则复杂度评估

| 方案 | 规则描述 | 决策树深度 | 记忆负担 |
|:-----|:---------|:-----------|:---------|
| **方案1** | "所有缩写首字母大写" | 1 层 | 低（1条规则） |
| **方案2** | "2字母全大写，3+字母首字母" | 2 层 | 中（2条规则 + 长度判断） |
| **方案3** (Seeker) | "独立时全大写，复合时首字母" | 2 层 | 中-高（需理解语境） |

### 4.2 内化难度曲线

根据我之前总结的**内化曲线原则**：

- **方案 1**：内化周期最短（1-2 天），但初期会产生"看起来很奇怪"的不适感
- **方案 2**：内化周期中等（1 周），规则机械可记
- **方案 3**：内化周期最长（2-4 周），需要对"语境"形成直觉

**关键洞察**：

> 方案 3 的复杂度来自于**语境判断**——"独立 vs 复合"需要理解句法结构。这对母语者可能是直觉的，但对非母语开发者（我们团队的重要受众）可能是持续的认知负担。

### 4.3 新成员上手体验

想象一个新 Agent（或新开发者）加入项目：

**方案 1**：
> "哦，所有缩写都用首字母大写，简单。虽然 `Id` 看起来有点怪，但规则清晰。"

**方案 3**：
> "`ID` 在句子开头全大写...在 `App-For-LLM` 里也是全大写？等等，Seeker 说复合术语里应该首字母大写...那 `App-For-LLM` 是不是应该写成 `App-For-Llm`？还是因为它在术语末尾所以还是全大写？"

**体验建议**：规则应该能用**一句话**解释清楚，这是低学习曲线的关键指标。

---

## 五、错误预防分析

### 5.1 常见错误类型

| 错误类型 | 示例 | 方案1风险 | 方案2风险 | 方案3风险 |
|:---------|:-----|:----------|:----------|:----------|
| 大小写混淆 | `ID` vs `Id` | 低 | 中 | 高 |
| 边界判断错误 | 2字母 vs 3字母 | - | 中 | - |
| 语境判断错误 | 独立 vs 复合 | - | - | 高 |
| 连字符遗漏 | `WhyLayer` vs `Why-Layer` | 中 | 中 | 中 |

### 5.2 错误的发现成本

**自检难度**：
- 方案 1：容易自检——"有没有首字母大写？"
- 方案 2：需要计数——"这个缩写是几个字母？"
- 方案 3：需要分析语境——"这是独立使用吗？"

**工具检测难度**：
- 方案 1：正则匹配简单
- 方案 2：正则匹配需要长度判断
- 方案 3：需要语法分析

**体验建议**：从错误预防角度，**方案 1 明显优于方案 2/3**。但方案 1 的问题是它的"正确形式"看起来可能是错误的（`Id` 看起来像拼写错误）。

---

## 六、搜索体验分析

### 6.1 用户搜索行为模式

开发者搜索术语时的典型行为：

1. **记忆搜索**：记得术语，直接输入（如搜索 `ID`）
2. **模糊搜索**：记得部分，依赖模糊匹配（如输入 `ui layer`）
3. **浏览搜索**：不确定术语，通过浏览发现（如看到 `UI` 后点击）

### 6.2 搜索体验矩阵

| 场景 | 用户输入 | 期望匹配 | 方案1体验 | 方案2体验 | 方案3体验 |
|:-----|:---------|:---------|:----------|:----------|:----------|
| 精确搜索 | `ID` | `ID` | ❌ 不匹配 `Id` | ✅ 匹配 | ✅ 匹配 |
| 大小写不敏感 | `id` | `ID` 或 `Id` | ✅ 匹配 | ✅ 匹配 | ✅ 匹配 |
| 复合术语 | `Why-Layer` | `Why-Layer` | ✅ 匹配 | ✅ 匹配 | ✅ 匹配 |
| 习惯输入 | `LLM` | `LLM` 或 `Llm` | ❌ 需变体处理 | ❌ 需变体处理 | ⚠️ 部分匹配 |

**关键洞察**：

> 大多数现代搜索工具支持大小写不敏感搜索，因此大小写差异的**搜索影响被高估了**。真正的搜索痛点是**变体统一**——确保 DocGraph 能识别 `ID`、`Id`、`id` 是同一概念。

### 6.3 搜索友好性建议

无论采用哪种方案，都需要：
1. **术语规范化层**：搜索时自动归一化大小写
2. **变体注册表**：记录每个术语的所有合法变体
3. **模糊匹配支持**：容忍小的格式差异

从搜索角度看，**三个方案差异不大**，关键在于工具层的处理能力。

---

## 七、工具兼容性分析

### 7.1 IDE 支持

| 功能 | 连字符术语 | 全大写缩写 | 首字母缩写 |
|:-----|:-----------|:-----------|:-----------|
| 自动补全 | ⚠️ 需配置 | ✅ 标准支持 | ✅ 标准支持 |
| 重命名重构 | ⚠️ 受限 | ✅ 标准支持 | ✅ 标准支持 |
| 符号导航 | ⚠️ 文档工具需适配 | ✅ 良好 | ✅ 良好 |

**连字符术语的 IDE 挑战**：连字符在大多数编程语言中不是有效标识符字符，这意味着 `Why-Layer` 在代码和文档之间存在"翻译"需求。

### 7.2 Markdown 和文档工具

- **连字符术语**：在 Markdown 中完全支持，且视觉清晰
- **全大写缩写**：完全支持
- **首字母缩写**：完全支持

### 7.3 版本控制（Git）

文件名格式：
- `why-layer.md`（小写连字符）：✅ 跨平台安全
- `Why-Layer.md`（混合大小写）：⚠️ macOS/Windows 大小写不敏感
- `WHY-LAYER.md`（全大写）：⚠️ 同上

**建议**：文件名统一使用小写连字符格式。

---

## 八、体验优化建议

### 8.1 Curator 推荐方案：务实的混合策略

基于以上 UX/DX 分析，我提出一个**以可预测性为核心**的方案：

**[C-TERM-ABBREV-VISUAL-ANCHOR]** 高频 2 字母缩写 SHOULD 保持全大写形式，作为视觉锚点。

**白名单**：`ID`、`UI`、`UX`、`DX`、`AI`、`IO`

**理由**：这些缩写：
1. 使用频率极高，开发者已有肌肉记忆
2. 全大写形式提供扫描时的视觉锚点
3. 首字母形式会造成语义干扰（`Id` → "本我"、`Ai` → 日语名字）

**[C-TERM-ABBREV-NORMALIZE-REST]** 其他缩写 SHOULD 使用首字母大写形式。

**示例**：`Api`、`Mvp`、`Llm`、`Ssot`、`Dna`

**理由**：
1. 规则简单：非白名单即首字母大写
2. 避免"全文大喊"效应（过多全大写词降低可读性）
3. 与 PascalCase 代码标识符兼容度高

**[C-TERM-COMPOUND-PRESERVE]** 复合术语中的缩写 SHOULD 保持其独立形式。

**示例**：`App-For-LLM`（不是 `App-For-Llm`）

**理由**：
1. 连字符已经提供了单词边界，无需再通过大小写区分
2. 保持缩写的原始形式减少规则复杂度
3. `App-For-LLM` 比 `App-For-Llm` 更符合直觉

### 8.2 简化后的完整规则

一句话版本：
> **"白名单缩写全大写，其他首字母大写，复合术语用连字符分隔。"**

决策树版本：
```
这个词是缩写吗？
├─ 否 → 首字母大写（如 `Layer`）
└─ 是 → 在白名单里吗？(ID, UI, UX, DX, AI, IO)
    ├─ 是 → 全大写（如 `ID`）
    └─ 否 → 首字母大写（如 `Api`、`Llm`）

这是复合术语吗？
├─ 否 → 应用上面的规则
└─ 是 → 用连字符连接，每部分保持独立规则（如 `App-For-LLM`）
```

### 8.3 迁移体验建议

**渐进式迁移策略**：

1. **零阻力阶段**（立即）：新文档使用新规范
2. **提示阶段**（1 个月内）：CI 检查报 warning 但不阻断
3. **强制阶段**（3 个月后）：CI 检查报 error

**配套工具**：
- 术语检查脚本：扫描文档，提示不符合规范的术语
- 术语字典文件：作为 SSOT 和自动补全数据源

---

## 九、总结：体验权衡表

| 维度 | 方案1（统一首字母） | 方案2（长度区分） | 方案3（语义角色） | Curator 方案（白名单） |
|:-----|:-------------------|:-----------------|:-----------------|:---------------------|
| **可读性** | ⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **输入便利** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| **学习曲线** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| **错误预防** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ |
| **搜索友好** | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| **行业惯例** | ⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **综合推荐** | 不推荐 | 可接受 | 可接受 | **推荐** |

### 9.1 核心取舍

- **方案 1** 虽然规则最简单，但牺牲了行业惯例和可读性，`Id`/`Ui` 看起来像拼写错误
- **方案 2/3** 规则较复杂，需要额外的判断步骤
- **白名单方案** 通过**明确列举高频例外**，在简单性和惯例兼容之间取得平衡

### 9.2 待 Craftsman 和 DocOps 确认

1. **白名单范围**：`ID`、`UI`、`UX`、`DX`、`AI`、`IO` 是否足够？是否需要加入 `OK`？
2. **文件命名规范**：是否统一小写连字符格式？
3. **代码-文档映射表**：是否需要维护一份正式的对照表？

期待后续发言！

---

### Craftsman 发言

我从“规范工程 / 代码可维护性”的角度看，这个问题的关键不在于“哪种写法更好看”，而在于：

1) 规则是否**可判定**（能写成 lint / 测试），2) 是否能形成**单一 SSOT**（避免多套命名体系互相打架），3) 是否能把“文档术语 / 代码标识符 / 条款锚点 / 文件名”分清楚，减少跨域混用。

下面按主持人提出的 6 个维度给出结论与实施方案。

---

## 1) 规范一致性：建议采用“分域命名 + 缩写注册表”的单一体系

我建议明确把命名分成 4 个互不混淆的“域”（namespace），每个域只有 1 条主规则：

1. **条款锚点（Requirement IDs）域**：沿用 `atelia/docs/spec-conventions.md`，即 `[F-*] / [A-*] / [S-*] / [R-*]` 使用 `SCREAMING-KEBAB-CASE`。
2. **术语（Glossary/Docs）域**：多单词术语使用 **Title-Kebab（首字母大写 + 连字符）**，即当前讨论的 `Why-Layer` / `App-For-LLM`。
3. **文件名域**：统一 `lower-kebab-case`（全小写 + 连字符），避免跨平台大小写问题。
4. **代码标识符域**：遵循语言/生态惯例（C# PascalCase 等），不强行要求与文档完全同形，但需要可追踪映射。

这样做的好处是：规范体系不会出现“同一概念在不同文档层级被迫改大小写导致漂移”，尤其不会干扰已存在的 `SCREAMING-KEBAB-CASE` 锚点体系。

---

## 2) 代码可维护性：不建议方案1；方案2不够；更推荐“缩写注册表 + 保持缩写全大写”

### 2.1 多单词连接方式（`Why-Layer` / `App-For-LLM`）

从维护性角度，我支持你们“连字符 + 首字母大写”的大方向，原因不是审美，而是：

- **引用稳定性**：文档里反复出现的术语更像“符号”，而不是自然语言句子；`Why-Layer` 这种形式比 `Why Layer` 更像符号，更不容易在复制/换行/排版时被破坏。
- **对 DocGraph 友好**：`-` 明确分隔 token，提取与归一化更简单。
- **与现有实践一致**：仓库内 Wish 相关文档/模板已大量使用 `Why-Layer → Craft-Layer` 这条链。

额外维护性建议：既然术语表已经规定 `Rule-Layer` 使用单数以避免 `Rules` 冲突，那就在规范中把“Layer 五件套”作为**闭集枚举**固定下来（只允许这 5 个）。

### 2.2 缩写大小写（方案1 vs 方案2）

我明确反对“方案1：所有缩写都首字母大写（`Id`/`Ui`/`Api`/`Llm`）”作为**文档术语域**的规则：

- **与仓库现状冲突大**：`ID` / `API` / `SSOT` / `LLM` 已经在多处作为缩写使用；强行改成 `Id` / `Api` / `Ssot` / `Llm` 会带来大量机械替换与审阅噪声。
- **与规范锚点精神冲突**：条款锚点明确使用全大写风格（`SCREAMING-KEBAB-CASE`）；如果文档术语反而系统性避免全大写，会出现“规范体系内部风格割裂”。
- **维护风险**：`Id` 这类写法在混合语境（英语单词/专有名词/代码）里可读性差，容易被二次编辑者“纠正”回 `ID`，造成反复震荡。

“方案2：仅 2 字母全大写”比方案1好，但仍不足：因为 `API` / `LLM` / `SSOT` 这类 3+ 字母缩写在工程里同样高频、也同样有强惯例。

### 2.3 我建议的可维护方案：**缩写注册表（Acronym Registry）**

规则一句话版本：

> 在“术语域（文档）”中，缩写是否全大写不靠长度/语境猜测，而靠“注册表”。注册表里的缩写一律全大写；不在表里的按普通词 TitleCase。

这本质上是 Curator 的“白名单策略”，但我建议把它工程化成**显式的 Registry**，并规定增删流程（否则白名单会变成口头传统）。

初始注册表建议至少包含（从现有材料出发）：`ID`、`UI`、`UX`、`DX`、`AI`、`LLM`、`API`、`MVP`、`SSOT`、`CRC`、`RBF`、`IO`。

对应到复合术语：`App-For-LLM` 的 `LLM` 仍保持全大写，不写成 `Llm`。

---

## 3) 自动化检查：能做成“纯文本判定”，不需要语法树

自动化的关键是把规则变成“只看字符串就能判定”。我的建议落地形态：

1. **SSOT 数据源**：新增一个机器可读的 Registry（例如 `terminology-registry.json/yaml`），至少包含：
   - `layers`: `Why-Layer` / `Shape-Layer` / `Rule-Layer` / `Plan-Layer` / `Craft-Layer`
   - `acronyms`: `ID`, `UI`, `UX`, ...
   - `terms`: 可选（若未来要做更强的术语链接与别名）

2. **Lint 规则（Markdown 扫描）**：
   - 检查 `Why-Layer` 等 5 个 Layer 术语只能取闭集枚举（拒绝 `Rules-Layer` / `Why Layer` / `WhyLayer` 作为“术语引用形式”）。
   - 检查缩写：出现 `Id` / `Ui` / `Llm` 等时给出修复建议（→ `ID` / `UI` / `LLM`），但只对“术语引用位置”强制（例如 code span、标题、表格单元格），对正文自然语言可先给 warning。
   - 忽略 `[S-...]` / `[A-...]` 等锚点与代码块，避免误报。

3. **自动修复（可选）**：对最常见的错写提供 safe fix（例如 `` `Llm` `` → `` `LLM` ``），其余只报提示。

这套机制不需要 NLP，也不需要理解“语义角色”，因此可维护且可持续。

---

## 4) 迁移成本：把成本分层，避免“全库大替换”

我建议把迁移对象分成 3 类（成本从低到高）：

1. **模板/规范/术语表（SSOT 类文档）**：必须迁移（因为它们定义未来写作的默认值）。
2. **活跃设计文档（正在被引用/将被 DocGraph 扫描的）**：推荐迁移（收益高，DocGraph 会反复读）。
3. **历史会议记录/归档**：不做硬迁移（保留历史事实），只在索引或新文档引用时做 alias。

对缩写大小写而言：

- 若选方案1，会触发大量 `ID/API/LLM/SSOT` → `Id/Api/Llm/Ssot` 的替换，且很可能引入二次分歧（编辑者凭习惯改回全大写）。这属于“迁移成本高 + 回归风险高”。
- 若选“注册表 + 全大写缩写保留”，迁移成本主要是：补齐规则描述 + 做少量收敛（把零星的 `Llm`/`Api` 统一回 `LLM`/`API`）。这属于“迁移成本可控 + 收益立即”。

推荐的过渡节奏（与 Curator 的 0 阻力/提示/强制三阶段一致）：
- 第 1 周：只对模板/SSOT 文档启用 error；其他文档 warning。
- 第 1 个月：活跃文档升为 error。
- 之后：新增文档必须全符合；历史归档仅在被编辑时触发检查。

---

## 5) 长期维护：用“Registry 变更流程”把白名单变成工程资产

白名单策略长期容易腐化的点是：新增缩写时大家不知道“要不要加入白名单”。为避免“口口相传”，我建议写成一个明确流程：

1. 新缩写出现时，先以 TitleCase 写（例如 `Foo`），并在文档第一次引入处给出全称。
2. 只有当满足“跨文档高频 / 行业通用 / 会出现在表格/标题/索引中”时，才提 PR 把它加入 `acronyms` 注册表。
3. 注册表变更需要同步更新：术语表（人读）+ lint（机读）。

这样白名单不会无边界膨胀，且每次膨胀都可追溯。

---

## 6) 与现有规范兼容性：与 `spec-conventions.md` 可自然对齐

关键对齐点：

- `spec-conventions.md` 已经固定了“条款锚点命名 = `SCREAMING-KEBAB-CASE`”。因此我们应避免把“术语域的缩写规则”反向施加到锚点域。
- 术语表 `agent-team/wiki/terminology.md` 已经明确 `Why-Layer` 等格式，并强调 `Rule` 单数避免冲突。建议把本次会议的结论回写到术语表的“统一术语格式”段落中，作为**Primary Definition**；会议记录只保留决策理由。

---

## 可执行的结论（供主持人收敛）

1. 多单词术语连接：继续采用 `Title-Kebab`（`Why-Layer`/`App-For-LLM`），文件名使用 `lower-kebab-case`。
2. 缩写大小写：采用“**缩写注册表**”策略——注册表内缩写全大写（`ID/UI/LLM/API/...`），不在表内按普通词 TitleCase。
3. 自动化：引入机器可读 Registry + Markdown lint（先 warning 后 error），避免依赖语境判断。

如果主持人希望今天就形成可落地的决议，我建议把“注册表初始条目”写死为上面那一组，并明确增删流程即可。
---

### DocOps 发言

感谢前面三位的系统性分析。我从文档管理与迁移成本角度审视这次术语命名规范制定，结合最近执行的几次术语迁移任务的实操经验。

---

## 一、文档管理影响：现状评估

### 1.1 仓库文档规模

| 统计维度 | 数量 | 说明 |
|:---------|:-----|:-----|
| **全仓库 Markdown 文件** | 957 | 包含所有项目 |
| **核心文档区** (agent-team/wishes/atelia) | 591 | 主要维护目标 |
| **涉及缩写使用的文档** | 462 | 含 `ID`/`UI`/`API`/`LLM`/`SSOT` 等 |
| **使用层级术语的文档** | 9 | `Why-Layer`/`Shape-Layer` 等 |

### 1.2 影响分层分析

基于我此前总结的**涟漪效应模型**，术语变更的影响从核心向外扩散：

| 影响层级 | 文件类型 | 预估文件数 | 迁移必要性 | 迁移紧迫度 |
|:---------|:---------|:-----------|:-----------|:-----------|
| **SSOT 层** | 术语表、模板 | 3-5 | MUST | 立即 |
| **规范层** | 规范条款文档 | 10-15 | MUST | 1 周内 |
| **活跃文档层** | 当前活跃 Wish/设计文档 | 20-30 | SHOULD | 1 个月内 |
| **历史层** | 归档/会议记录 | 500+ | MAY (保持原样) | N/A |

**关键洞见**：真正需要强制迁移的只有 **SSOT + 规范层**（约 15-20 个文件），其他可渐进式更新。

### 1.3 当前不一致性评估

根据我之前的文档核查经验，术语不一致主要体现在：

| 不一致类型 | 现状 | 风险等级 |
|:-----------|:-----|:---------|
| **层级术语格式** | 已收敛到 `Why-Layer` 格式 | 低 — 已统一 |
| **缩写大小写** | `ID`/`API` 全大写 vs `Llm`/`Ai` 混用 | 中 — 需收敛 |
| **复合术语中的缩写** | `App-For-LLM` 惯例已形成 | 低 — 保持现状 |

---

## 二、迁移成本评估

### 2.1 方案对比：迁移成本矩阵

| 迁移维度 | 方案1（统一首字母） | 方案2（长度区分） | 注册表方案 |
|:---------|:-------------------|:-----------------|:----------|
| **文件修改量** | ~462 文件 | ~200 文件 | ~50 文件 |
| **高风险修改** | 全量 `ID`→`Id` 替换 | 部分 `API`→`Api` 替换 | 仅规范化零散不一致 |
| **回归风险** | 高 — 违反惯例易反弹 | 中 — 边界判断可能误操作 | 低 — 与现状最接近 |
| **工具复杂度** | 简单（统一规则） | 中等（需长度判断） | 低（白名单查表） |
| **人工审阅成本** | 高 — 需全量复查 | 中 | 低 — 仅复查偏离项 |

### 2.2 迁移风险实操经验

基于我在 2025-12-30 执行的五层级术语迁移（What→Shape, How→Plan, Build→Craft），总结以下经验：

**教训 1：涟漪效应难以穷尽**

当时只更新了模板和规范文件，后来发现实例文档（wish-0001、wish-0002）也需要同步，险些造成双术语并存。

**教训 2：grep 验证是最后防线**

每次迁移必须用 grep 验证：
- 旧术语残留 = 0
- 新术语应用正确

**教训 3：版本号管理差异**

- 规范文件：需更新版本号和变更历史
- 模板文件：不需要版本号
- 索引文件：需更新 changefeed anchor

### 2.3 推荐迁移时间线

基于风险可控原则，建议采用 **三阶段渐进式迁移**：

```
Week 1 (立即)     Week 2-4          Month 2+
─────────────────────────────────────────────────►
  Phase 1           Phase 2           Phase 3
  ─────────         ─────────         ─────────
  SSOT + 规范      活跃文档          按需更新
  
  - terminology.md  - wish-0001       - 历史会议记录
  - spec-*.md       - wish-0002       - 归档文档
  - templates/*.md  - mvp-design-v2   - 新引用时更新
  - Registry 初建   - DocGraph docs
  
  验收：grep 清零   验收：lint 通过   验收：CI 绿色
```

---

## 三、索引管理影响

### 3.1 现有索引体系

当前 `agent-team/indexes/` 维护以下索引：

| 索引 | 作用 | 术语规范影响 |
|:-----|:-----|:-------------|
| `README.md` (Delta Ledger) | Changefeed anchor 时间线 | 需新增本次决策的 anchor |
| `core-docs-index.md` | 核心文档用途与 Owner | 需更新术语表条目 |
| `oi-backlog.md` | OI 任务列表 | 无直接影响 |

### 3.2 搜索与交叉引用

**DocGraph 工具需求**：无论采用哪种方案，DocGraph 都需要支持：

1. **术语规范化**：`ID` / `Id` / `id` → 统一内部表示
2. **变体注册**：每个术语的所有合法形式
3. **双向链接**：术语引用 ↔ 术语定义

**影响评估**：**注册表方案对 DocGraph 最友好**——注册表本身就是 DocGraph 可消费的 SSOT。

### 3.3 Changefeed Anchor 管理

本次规范决策需要创建新的 changefeed anchor：

```markdown
### 2025-12-31 – Terminology Naming Convention
- **#delta-2025-12-31-terminology-convention** – 术语命名规范制定：
  - 多单词术语：`Title-Kebab` 格式（`Why-Layer`、`App-For-LLM`）
  - 缩写规则：注册表白名单全大写，其他首字母大写
  - Registry 位置：`agent-team/wiki/terminology-registry.yaml`
  - 畅谈会记录：`meeting/2025-12-31-terminology-naming-convention.md`
```

---

## 四、版本控制与向后兼容

### 4.1 规范版本管理

| 受影响规范 | 当前版本 | 建议新版本 | 变更类型 |
|:-----------|:---------|:-----------|:---------|
| `terminology.md` | v1.0.0 | v1.1.0 | Minor（新增命名规则） |
| `spec-conventions.md` | — | — | 需检查是否需要更新 |
| `wish-system-rules.md` | v0.2.0 | v0.3.0 | Minor（术语格式澄清） |

### 4.2 向后兼容策略

**核心原则**：历史文档保持原样，不做回溯性修改。

| 文档类型 | 兼容策略 | 理由 |
|:---------|:---------|:-----|
| **会议记录** | 保持原样 | 历史事实，不应篡改 |
| **归档文档** | 保持原样 | 已冻结，无人引用 |
| **活跃规范** | 逐步更新 | 正在使用，需保持一致 |
| **术语表** | 维护别名表 | 提供 v0.1 → v1.0 映射 |

**已有实践**：术语表中的"术语对照表（向后兼容）"正是为此设计。

### 4.3 Git 变更管理

**建议的 commit 策略**：

```
feat(terminology): add naming convention rules for abbreviations

- Add acronym registry with initial entries (ID, UI, API, LLM, etc.)
- Update terminology.md with Title-Kebab format rules
- Create terminology-registry.yaml as machine-readable SSOT

Related: #delta-2025-12-31-terminology-convention
```

---

## 五、团队协作影响

### 5.1 新成员上手成本

| 方案 | 学习曲线 | 上手文档 | 首次错误率预估 |
|:-----|:---------|:---------|:---------------|
| **方案1** | 最简单 | 1 段话 | 低（但"正确形式看起来像错误"） |
| **方案2** | 中等 | 1 页 | 中（需记忆长度规则） |
| **注册表方案** | 低 | 注册表 + 1 段话 | 低（不确定时查表） |

**新成员引导路径**：

1. 阅读 `terminology.md` 的"统一术语格式"章节（5 分钟）
2. 查看 `terminology-registry.yaml` 了解全大写缩写白名单（2 分钟）
3. 首次提交时 CI lint 自动检查（即时反馈）

### 5.2 跨会话协作

对于 AI 团队成员，术语规范的一致性直接影响：

- **上下文加载**：统一格式便于 grep 快速定位
- **文档生成**：规则明确则生成质量更高
- **审阅效率**：减少"这个词怎么写"的讨论

**注册表方案优势**：Agent 可以直接加载 `terminology-registry.yaml` 作为约束，无需理解复杂规则。

---

## 六、工具需求与建议

### 6.1 必要工具清单

| 工具 | 用途 | 实现优先级 | 复杂度 |
|:-----|:-----|:-----------|:-------|
| **terminology-registry.yaml** | 机器可读的术语 SSOT | P0 | 低 |
| **Markdown lint 脚本** | CI 检查术语一致性 | P1 | 中 |
| **迁移 grep 脚本** | 验证旧术语清零 | P1 | 低 |
| **DocGraph 术语模块** | 自动术语提取与规范化 | P2 | 高 |

### 6.2 Registry 文件设计草案

建议在 `agent-team/wiki/` 下创建 `terminology-registry.yaml`：

```yaml
# terminology-registry.yaml
# 机器可读的术语规范 SSOT
version: "1.0"
last_updated: "2025-12-31"

# 全大写缩写白名单
acronyms_uppercase:
  - ID    # Identifier
  - UI    # User Interface
  - UX    # User Experience
  - DX    # Developer Experience
  - AI    # Artificial Intelligence
  - IO    # Input/Output
  - API   # Application Programming Interface
  - LLM   # Large Language Model
  - MVP   # Minimum Viable Product
  - SSOT  # Single Source of Truth
  - CRC   # Cyclic Redundancy Check
  - RBF   # (项目特有缩写)

# 层级术语闭集
layer_terms:
  - Why-Layer
  - Shape-Layer
  - Rule-Layer
  - Plan-Layer
  - Craft-Layer

# 其他复合术语示例
compound_terms:
  - App-For-LLM
  - Context-Projection
  - Capability-Provider
```

### 6.3 Lint 规则建议

**Phase 1（warning）**：
```
规则: 检测 `Id`/`Ui`/`Llm`/`Api` 等形式
建议: 替换为注册表中的全大写形式
范围: `*.md` 文件，排除代码块
```

**Phase 2（error）**：
```
规则: 强制执行 Phase 1 规则
例外: 代码块、引用块
```

---

## 七、风险管理与缓解

### 7.1 风险识别

| 风险 | 可能性 | 影响 | 缓解措施 |
|:-----|:-------|:-----|:---------|
| **迁移遗漏** | 中 | 中 | grep 验证脚本 + 二次扫描 |
| **规则反弹** | 低 | 中 | CI 强制检查 + 即时反馈 |
| **白名单膨胀** | 中 | 低 | 明确增删流程 + 审批机制 |
| **DocGraph 不兼容** | 低 | 高 | Registry 设计时考虑 DocGraph 消费需求 |
| **历史文档破坏** | 低 | 高 | 明确"历史保持原样"原则 |

### 7.2 回滚方案

如果迁移后发现问题：
1. **Phase 1 可回滚**：SSOT 文件数量少，可手动恢复
2. **Phase 2 可暂停**：lint 规则可调为 warning
3. **Registry 可扩展**：白名单增删不影响已迁移文档

---

## 八、总结：DocOps 建议

### 8.1 方案推荐

从文档管理角度，**强烈支持 Craftsman 提出的"缩写注册表"方案**，理由：

1. **迁移成本最低**：与现状最接近，只需规范化零散不一致
2. **索引友好**：Registry 本身就是 DocGraph 的数据源
3. **可追溯**：白名单增删有明确记录
4. **渐进式**：不需要一次性大规模替换

### 8.2 具体行动项

| 优先级 | 行动项 | Owner | 时间 |
|:-------|:-------|:------|:-----|
| **P0** | 创建 `terminology-registry.yaml` | DocOps | 本周 |
| **P0** | 更新 `terminology.md` 增加命名规范章节 | DocOps | 本周 |
| **P1** | 创建迁移验证 grep 脚本 | DocOps/Implementer | 1 周内 |
| **P1** | 更新 `indexes/README.md` 增加 changefeed | DocOps | 决策后 |
| **P2** | 实现 Markdown lint 规则 | Implementer | 2 周内 |
| **P3** | DocGraph 术语规范化模块 | Implementer | 与 W-0002 协调 |

### 8.3 验收标准

迁移完成的验收检查清单：

- [ ] `grep -ri "\\bId\\b\\|\\bUi\\b\\|\\bApi\\b\\|\\bLlm\\b" --include="*.md"` 在规范层返回 0 结果
- [ ] `terminology-registry.yaml` 存在且格式正确
- [ ] `terminology.md` 包含命名规范章节
- [ ] `indexes/README.md` 包含本次决策的 changefeed anchor
- [ ] CI lint 对新文档生效（至少 warning 级别）

---

以上是我从文档管理与迁移成本角度的分析。期待主持人收敛决策！
### 主持人总结与决策 (刘德智)

感谢 Seeker、Curator、Craftsman 和 DocOps 的精彩发言！经过四轮深入分析，我们已经从概念本质、UX/DX、规范一致性、文档管理等四个维度全面评估了术语命名规范问题。

## 一、共识总结

### 1.1 已达成共识

✅ **多单词术语连接方式**：统一采用 **Title-Kebab 格式**（首字母大写 + 连字符）
- 示例：`Why-Layer`、`App-For-LLM`、`Context-Projection`
- 理由：视觉清晰、搜索友好、与现有实践一致

✅ **分域命名体系**：明确区分四个命名域，避免跨域污染
1. **条款锚点域**：`SCREAMING-KEBAB-CASE`（`[F-*]`/`[A-*]`/`[S-*]`/`[R-*]`）
2. **术语域**：`Title-Kebab`（文档中使用的术语）
3. **文件名域**：`lower-kebab-case`（全小写连字符）
4. **代码标识符域**：遵循语言惯例（C# PascalCase 等）

✅ **渐进式迁移策略**：三阶段迁移，避免一次性大规模替换

### 1.2 核心决策：缩写大小写规则

经过充分讨论，我们决定采用 **Craftsman 提出的"缩写注册表"方案**，这也是 Curator 和 DocOps 共同推荐的方案。

**决策理由**：
1. **迁移成本最低**：与现状最接近，只需规范化零散不一致
2. **行业惯例兼容**：尊重 `ID`、`UI`、`API` 等常见缩写惯例
3. **可扩展性强**：通过注册表管理，避免规则膨胀
4. **工具友好**：Registry 本身就是 DocGraph 可消费的数据源

## 二、具体规范条款

### 2.1 多单词术语规范

**[S-TERM-FORMAT-TITLE-KEBAB]** 多单词概念术语 MUST 使用连字符连接的首字母大写形式（Title-Kebab）。
- 示例：`Why-Layer`、`App-For-LLM`、`Context-Projection`
- 例外：文件名使用 `lower-kebab-case`（如 `why-layer.md`）

### 2.2 缩写大小写规范

**[S-TERM-ABBREV-REGISTRY]** 缩写的大小写 SHOULD 由术语注册表决定：
1. 注册表中的缩写使用全大写形式
2. 不在注册表中的缩写使用首字母大写形式
3. 复合术语中的缩写保持其独立形式

**[S-TERM-ABBREV-COMPOUND-PRESERVE]** 复合术语中的缩写 SHOULD 保持其独立形式，不因复合而改变大小写。
- 示例：`App-For-LLM`（不是 `App-For-Llm`）

### 2.3 注册表管理规范

**[S-TERM-REGISTRY-MANAGEMENT]** 术语注册表 MUST 作为机器可读的 SSOT，并遵循以下管理原则：
1. **初始条目**：基于现有高频使用和行业惯例确定
2. **增删流程**：需通过 PR 评审，记录变更理由
3. **版本控制**：注册表应有版本号和变更历史

## 三、实施计划

### 3.1 立即行动（本周内）

| 任务 | Owner | 验收标准 |
|:-----|:------|:---------|
| 创建 `terminology-registry.yaml` | DocOps | 文件存在且格式正确 |
| 更新 `terminology.md` 命名规范章节 | DocOps | 包含完整规范条款 |
| 更新 `indexes/README.md` changefeed | DocOps | 包含本次决策 anchor |

### 3.2 短期行动（1-2 周内）

| 任务 | Owner | 验收标准 |
|:-----|:------|:---------|
| 创建迁移验证 grep 脚本 | DocOps/Implementer | 脚本可运行，输出清晰 |
| 更新 SSOT 和规范层文档 | DocOps | grep 验证通过 |
| 实现 Markdown lint 规则（warning） | Implementer | CI 检查生效 |

### 3.3 中期行动（1 个月内）

| 任务 | Owner | 验收标准 |
|:-----|:------|:---------|
| 更新活跃文档层 | 各文档 Owner | 逐步完成迁移 |
| 升级 lint 规则为 error | Implementer | 新文档强制检查 |
| DocGraph 术语模块集成 | Implementer | 与 W-0002 协调 |

## 四、注册表初始条目

基于现有实践和讨论，建议初始注册表包含以下全大写缩写：

```yaml
acronyms_uppercase:
  # 2字母高频技术缩写
  - ID    # Identifier
  - UI    # User Interface
  - UX    # User Experience
  - DX    # Developer Experience
  - AI    # Artificial Intelligence
  - IO    # Input/Output
  
  # 3+字母高频技术缩写
  - API   # Application Programming Interface
  - LLM   # Large Language Model
  - MVP   # Minimum Viable Product
  - SSOT  # Single Source of Truth
  - CRC   # Cyclic Redundancy Check
  - RBF   # (项目特有缩写)
  - COW   # Copy-On-Write
  
  # 其他常见缩写
  - OK    # Okay (高频使用)
```

## 五、风险控制

### 5.1 回滚机制

如果实施后发现问题：
1. **Phase 1 可回滚**：SSOT 文件数量少，可手动恢复
2. **Phase 2 可暂停**：lint 规则可调为 warning
3. **Registry 可调整**：白名单增删不影响已迁移文档

### 5.2 验收检查清单

迁移完成的验收标准：
- [ ] `grep -ri "\\bId\\b\\|\\bUi\\b\\|\\bApi\\b\\|\\bLlm\\b" --include="*.md"` 在规范层返回 0 结果
- [ ] `terminology-registry.yaml` 存在且格式正确
- [ ] `terminology.md` 包含命名规范章节
- [ ] `indexes/README.md` 包含本次决策的 changefeed anchor
- [ ] CI lint 对新文档生效（至少 warning 级别）

## 六、畅谈会结论

本次畅谈会成功形成了以下共识：

1. **规范采纳**：在 `atelia/docs/spec-conventions.md` 中加入术语命名规范章节
2. **实施路径**：采用渐进式迁移策略，优先更新 SSOT 和规范层
3. **工具支持**：建立术语注册表作为机器可读的 SSOT
4. **长期维护**：通过注册表管理机制确保规范的可持续性

**最终决策**：
- ✅ 多单词术语：统一采用 Title-Kebab 格式
- ✅ 缩写规则：采用注册表白名单方案
- ✅ 迁移策略：三阶段渐进式迁移

感谢各位的深入分析和建设性讨论！本次畅谈会圆满结束。

---

**会议状态**：✅ 已完成
**决策记录**：已形成可执行的规范条款和实施计划
**后续跟进**：由 DocOps 负责协调实施
