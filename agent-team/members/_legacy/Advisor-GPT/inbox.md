# Inbox — 待处理便签

> 这是你的便签收集箱。
> 写下洞见、经验、状态变更，MemoryPalaceKeeper 会定期整理归档。
>
> **格式**：每条便签用 `## 便签 YYYY-MM-DD HH:MM` 开头，用 `---` 分隔。

---

<!-- 在下方添加你的便签 -->

## 便签 2025-12-28 14:40

本轮审阅“简单套壳类型”时，一个可重复的判据是：**约束是否进入类型的可判定面**（构造/校验/行为），还是仅停留在文档注释。

- 若 wrapper 的定义条款仅等价于“这是某个原始类型”，且同时声明“RBF/L0 不解释语义、无保留值域”，则类型安全收益在规范层面不可判定，容易变成纯 API 摩擦（典型：`FrameTag(uint)`）。
- 若 wrapper 存在硬约束（如对齐/null），但约束 SSOT 分散在 wire 文档与接口文档，且类型本身不提供 `IsAligned` / `TryCreate` / `CreateChecked` 等机制，则容易形成“约束双写 + 漂移”风险（典型：`Address64(ulong)` 同时出现在 `rbf-format.md` 与 `rbf-interface.md`）。

---

## 便签 2025-12-28 16:55

第二轮“简单套壳类型”审阅里，一个易漏点是：**文档术语表可能把概念映射为原始类型，但实现已引入 wrapper**（如 `ObjectId(ulong)`）。这会产生 SSOT 分叉：实现者/审阅者无法仅凭规范判断“强类型是否存在/应被依赖”。

可复用的审计问句：
- 该 wrapper 的关键约束是否进入了类型的可判定面（构造/校验/方法），还是仅停留在规范条款？
- 若 wrapper 的收益主要来自“防混淆”，但又提供隐式转换回原始类型，它是否已经退化为“注释型别名”？

---

## 便签 2025-12-28 19:05

关于“合并 Design Advisor + CodexReviewer”为单一高能力审阅子代理：合并在能力上可行，但**必须**在 persona 内部协议化“两种审阅镜头”（规范契约 vs 代码实现），否则会出现输出混层与优先级漂移。

- 建议把输出固定为双段：`Spec/Contract Audit`（条款/可判定性/冲突）与 `Code/Compliance Review`（L1/bug/安全/性能）。
- 合并会把“上下文窗口/注意力预算”变成主要风险源；需要强制：证据引用（文件/符号）+ Finding 结构化 + 去重键。
- 命名上优先选择可机械解析且中性的 `Craftsman-*` 家族，避免 `Overseer` 这类带治理含义的词导致职责外延膨胀。
